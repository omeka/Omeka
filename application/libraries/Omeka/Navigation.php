<?php
/**
 * Omeka
 * 
 * @copyright Copyright 2007-2012 Roy Rosenzweig Center for History and New Media
 * @license http://www.gnu.org/licenses/gpl-3.0.txt GNU GPLv3
 */

/**
 * Customized subclass of Zend Framework's Zend_Navigation class.
 * 
 * @package Omeka\Navigation
 */
class Omeka_Navigation extends Zend_Navigation
{
    const PUBLIC_NAVIGATION_MAIN_OPTION_NAME = 'public_navigation_main';
           
    /**
     * Creates a new navigation container
     *
     * @param array|Zend_Config $pages    [optional] pages to add
     * @throws Zend_Navigation_Exception  if $pages is invalid
     */
    public function __construct($pages = null)
    {
        parent::__construct($pages);
    }
    
    /**
     * Saves the navigation in the global options table.
     *
     * @param String $optionName    The name of the option
     */
    public function saveAsOption($optionName) 
    {
        set_option($optionName, json_encode($this->toArray()));
    }
    
    /**
     * Loads the navigation from the global options table
     *
     * @param String $optionName    The name of the option
     */
    public function loadAsOption($optionName) 
    {
        if ($navPages = json_decode(get_option($optionName), true)) {
            $this->setPages($navPages);
        }
    }
    
    /**
     * Adds a page to the container.  If a page does not have a valid id, it will give it one.
     * and is an instance of Zend_Navigation_Page_Mvc or Omeka_Navigation_Page_Uri.
     * If a page already has another page with the same uid then it will not add the page.
     *
     * This method will inject the container as the given page's parent by
     * calling {@link Zend_Navigation_Page::setParent()}.
     *
     * @param  Zend_Navigation_Page|array|Zend_Config $page  page to add
     * @return Zend_Navigation_Container                     fluent interface,
     *                                                       returns self
     * @throws Zend_Navigation_Exception                     if page is invalid
     */
    public function addPage($page)
    {
         // normalize the page and its subpages            
        $page = $this->_normalizePageRecursive($page);        
                
        $page->uid = $this->createPageUid($page->getHref());
        if (!($fPage = $this->findByUid($page->uid))) {
            return parent::addPage($page);
        }
        
        return $this;
    }
    
    /**
     * Adds pages generated by Omeka plugins and other contributors via a filter (e.x. 'public_navigation_main').
     * The filter should provide an array pages like they are added to Zend_Navigation_Container::addPages
     * However, the page types should only be one of the following types:
     * Omeka_Navigation_Page_Uri or Zend_Navigation_Page_Mvc.  
     * If the associated uri of any page is invalid, it will not add that page to the navigation. 
     * Also, it removes expired pages from formerly active plugins and other former handlers of the filter.
     * 
     * @param String $filterName    The name of the filter
     * @throws Zend_Navigation_Exception if a filter page is invalid  
     */
    public function addPagesFromFilter($filterName='public_navigation_main') 
    {                
        // get default pages for the filter
        $pageLinks = array();
        switch($filterName) {
            case 'public_navigation_main':
                // add the standard Browse Items and Browse Collections links to the main nav
                $pageLinks = array(  
                    new Zend_Navigation_Page_Mvc(array(
                        'label' => __('Browse Items'),
                        'controller' => 'items',
                        'action' => 'browse',
                        'visible' => true
                    )), 
                    new Zend_Navigation_Page_Mvc(array(
                        'label' => __('Browse Collections'),
                        'controller' => 'collections',
                        'action' => 'browse',
                        'visible' => true,
                    )),
                );
            break;
        }
        
        // gather other page links from filter handlers (e.g. plugins)      
        $pageLinks = apply_filters($filterName, $pageLinks);        
                                        
        // add pages from filter handlers (e.g. plugins)
        $pageUids = array();
        foreach($pageLinks as $pageLink) {
                                     
            // normalize the page and its subpages            
            $page = $this->_normalizePageRecursive($pageLink, array('can_delete' => false));
    
            if ($page) {
                // if the navigation does not have the page, then add it
                $pUid = $this->createPageUid($page->getHref());
                $pageUids[] = $pUid; // gather the uids of pages offered by filters
                
                if (!($fPage = $this->getPageByUid($pUid))) {                    
                    parent::addPage($page); // add the new page
                }
            }
        }
                        
        // remove old pages that cannot be deleted and which are not provided by plugins or other filter handlers
        $expiredPages = array();
        foreach($this as $page) {
            if (!$page->can_delete && !in_array($page->uid, $pageUids)) {
                $expiredPages[] = $page;
            }
        }
        foreach($expiredPages as $expiredPage) {
            $this->removePageRecursive($expiredPage);
        }
    }
        
    /**
     * Returns the navigation page associated with uid.  If not page is associated, then it returns null.
     *
     * @param String $pageUid The uid of the page
     * @return Omeka_Zend_Navigation_Page_Uri|Zend_Navigation_Page_Mvc|null
     */
    public function getPageByUid($pageUid)
    {
        if ($page = $this->findOneBy('uid', $pageUid)) {
            return $page;
        }
        return null;
    }
    
    /**
     * Returns the unique id for the page, which can be used to determine whether it can be added to the navigation
     *
     * @param String $href The href of the page.
     * @return String
     */
    public function createPageUid($href) 
    {
        return $href;
    }

    /**
     * Recursively removes the given page from the navigation, including all subpages
     *
     * @param Zend_Navigation_Page $page
     * @return boolean Whether the page was removed
     */
    public function removePageRecursive(Zend_Navigation_Page $page)
    {        
        $removed = $this->removePage($page);

        $iterator = new RecursiveIteratorIterator($this, RecursiveIteratorIterator::SELF_FIRST);
        foreach ($iterator as $pageContainer) {
            $removed = $removed || $pageContainer->removePage($page);
        }

        return $removed;
    }
    
    /**
     * Returns the option value associated with the default navigation during installation 
     *
     * @param String $optionName The option name for a stored navigation object.
     * @return String The option value associated with the default navigation during installation.
     * If no option is found for the option name, then it returns an empty string.
     */
    public static function getNavigationOptionValueForInstall($optionName) 
    {
        $value = '';
        $nav = new Omeka_Navigation();
        switch($optionName) {
            case self::PUBLIC_NAVIGATION_MAIN_OPTION_NAME:
                $nav->addPagesFromFilter('public_navigation_main');
            break;
        }
                
        if ($nav->count()) {
            $value = json_encode($nav->toArray());
        }
        return $value;
    }
    
    /**
     * Normalizes a page and its subpages so it can be added
     *
     * @param  Zend_Navigation_Page|array|Zend_Config $page  Page to normalize
     * @param  $pageOptions  The options to set during normalization for every page and subpage
     * @return Omeka_Navigation_Page_Uri|Zend_Navigation_Page_Mvc|null The normalized page
     * @throws Zend_Navigation_Exception if a page or subpage is invalid  
     */
    protected function _normalizePageRecursive($page, $pageOptions = array()) 
    {
        if ($page === $this) {
            require_once 'Zend/Navigation/Exception.php';
            throw new Zend_Navigation_Exception(
                'A page cannot have itself as a parent');
        }
                
        // convert an array or Zend_Config to a Zend_Navigation_Page 
        if (is_array($page) || $page instanceof Zend_Config) {
            require_once 'Zend/Navigation/Page.php';
            $page = Zend_Navigation_Page::factory($page);
        }
        
        // convert a Zend_Navigation_Page_Uri page to an Omeka_Navigation_Page_Uri page
        if (get_class($page) == 'Zend_Navigation_Page_Uri') {
            $page = $this->_convertZendToOmekaNavigationPageUri($page);
        }
        
        if ($page instanceof Omeka_Navigation_Page_Uri) {
            $page->setHref($page->getHref());  // sets the href, which normalizes the uri from an href
        } elseif ($page instanceof Zend_Navigation_Page_Mvc) {
            if ($page->getRoute() === null) {
                $page->setRoute('default');
            }
        }
        
        if (!($page instanceof Zend_Navigation_Page_Mvc || $page instanceof Omeka_Navigation_Page_Uri)) {
            require_once 'Zend/Navigation/Exception.php';
            throw new Zend_Navigation_Exception(
                    'Invalid argument: $page must resolve to an instance of ' .
                    'Zend_Navigation_Page_Mvc or Omeka_Navigation_Page_Uri');
        }
        
        // set options for the page
        $page->setOptions($pageOptions);
        
        // set the uid
        $uid = $this->createPageUid($page->getHref());
        $page->set('uid', $uid);
        
        // normalize sub pages
        $subPages = array();
        foreach($page->getPages() as $subPage) {
            $subPages[] = $this->_normalizePageRecursive($subPage, $pageOptions);
        }
        $page->setPages($subPages);
            
        return $page;
    }
    
    /**
     * Converts a Zend_Navigation_Page_Uri to an Omeka_Navigation_Page_Uri
     *
     * @param Zend_Navigation_Page_Uri $page The page to convert
     * @return Omeka_Navigation_Page_Uri The converted page
     */
    protected function _convertZendToOmekaNavigationPageUri(Zend_Navigation_Page_Uri $page) 
    {   
        // change the type of page     
        $pageOptions = $this->_conditionalReplaceValueInArray($page->toArray(), 
                                                              'pages', 
                                                              'type', 
                                                              'Zend_Navigation_Page_Uri', 
                                                              'Omeka_Navigation_Page_Uri');
                
        $convertedPage = new Omeka_Navigation_Page_Uri();
        $convertedPage->setOptions($pageOptions);
        
        return $convertedPage;
    }
    
    
    /**
     * Returns an nested associative array such that all array elements have replaced an key value to 
     * a new key value only if it is equal to a specific old key value.   
     *
     * @param array $array The associative array
     * @param string $childKey The associative array
     * @param string $targetKey The target key whose value can be replaced
     * @param mixed $oldValue The old value of the element associated with the 
     * target key used to determine if the value should be changed
     * @param mixed $newValue The new value of the element associated with the target key
     * @return array The replaced associative array
     */
    protected function _conditionalReplaceValueInArray($array, $childKey, $targetKey, $oldValue, $newValue)
    {
        // change the current key value to the newValue if it is equal to the old value 
        if (isset($array[$targetKey])) {
            if ($array[$targetKey] == $oldValue) {
                $array[$targetKey] = $newValue;
            }
        }
        // change the nested subarrays located in the childKey
        if (isset($array[$childKey])) {
            $subArrays = $array[$childKey]; 
            $newSubArrays = array();
            foreach ($subArrays as $subArray) {
                $newSubArrays[] = $this->_conditionalReplaceValueInArray($subArray, 
                                                                         $childKey, 
                                                                         $targetKey, 
                                                                         $oldValue, 
                                                                         $newValue);
            }
            $array[$childKey] = $newSubArrays;
        }
        return $array;
    }
}
