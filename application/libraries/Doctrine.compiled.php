<?php class InvalidKeyException extends Exception { }final class Doctrine { const ERR = -1; const ERR_SYNTAX = -2; const ERR_CONSTRAINT = -3; const ERR_NOT_FOUND = -4; const ERR_ALREADY_EXISTS = -5; const ERR_UNSUPPORTED = -6; const ERR_MISMATCH = -7; const ERR_INVALID = -8; const ERR_NOT_CAPABLE = -9; const ERR_TRUNCATED = -10; const ERR_INVALID_NUMBER = -11; const ERR_INVALID_DATE = -12; const ERR_DIVZERO = -13; const ERR_NODBSELECTED = -14; const ERR_CANNOT_CREATE = -15; const ERR_CANNOT_DELETE = -16; const ERR_CANNOT_DROP = -17; const ERR_NOSUCHTABLE = -18; const ERR_NOSUCHFIELD = -19; const ERR_NEED_MORE_DATA = -20; const ERR_NOT_LOCKED = -21; const ERR_VALUE_COUNT_ON_ROW = -22; const ERR_INVALID_DSN = -23; const ERR_CONNECT_FAILED = -24; const ERR_EXTENSION_NOT_FOUND = -25; const ERR_NOSUCHDB = -26; const ERR_ACCESS_VIOLATION = -27; const ERR_CANNOT_REPLACE = -28; const ERR_CONSTRAINT_NOT_NULL = -29; const ERR_DEADLOCK = -30; const ERR_CANNOT_ALTER = -31; const ERR_MANAGER = -32; const ERR_MANAGER_PARSE = -33; const ERR_LOADMODULE = -34; const ERR_INSUFFICIENT_DATA = -35; const ERR_CLASS_NAME = -36; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; const ATTR_AUTOCOMMIT = 0; const ATTR_PREFETCH = 1; const ATTR_TIMEOUT = 2; const ATTR_ERRMODE = 3; const ATTR_SERVER_VERSION = 4; const ATTR_CLIENT_VERSION = 5; const ATTR_SERVER_INFO = 6; const ATTR_CONNECTION_STATUS = 7; const ATTR_CASE = 8; const ATTR_CURSOR_NAME = 9; const ATTR_CURSOR = 10; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_STATEMENT_CLASS = 13; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_DRIVER_NAME = 16; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_LISTENER = 100; const ATTR_QUOTE_IDENTIFIER = 101; const ATTR_FIELD_CASE = 102; const ATTR_IDXNAME_FORMAT = 103; const ATTR_SEQNAME_FORMAT = 104; const ATTR_CMPNAME_FORMAT = 118; const ATTR_DBNAME_FORMAT = 117; const ATTR_TBLCLASS_FORMAT = 119; const ATTR_SEQCOL_NAME = 105; const ATTR_PORTABILITY = 106; const ATTR_VLD = 107; const ATTR_COLL_KEY = 108; const ATTR_QUERY_LIMIT = 109; const ATTR_AUTO_LENGTH_VLD = 110; const ATTR_AUTO_TYPE_VLD = 111; const ATTR_DEFAULT_TABLE_TYPE = 112; const ATTR_DEF_TEXT_LENGTH = 113; const ATTR_DEF_VARCHAR_LENGTH = 114; const ATTR_DEF_TABLESPACE = 115; const ATTR_EMULATE_DATABASE = 116; const ATTR_FETCHMODE = 118; const ATTR_BATCH_SIZE = 119; const ATTR_LOCKMODE = 120; const ATTR_NAME_PREFIX = 121; const ATTR_CREATE_TABLES = 122; const ATTR_COLL_LIMIT = 123; const ATTR_ACCESSORS = 124; const ATTR_ACCESSOR_PREFIX_GET = 125; const ATTR_ACCESSOR_PREFIX_SET = 126; const ATTR_NS_ROOT_COLUMN_NAME = 130; const ATTR_NS_GAP_SIZE = 131; const ATTR_NS_GAP_DECREASE_EXP = 132; const LIMIT_ROWS = 1; const LIMIT_RECORDS = 2; const FETCH_IMMEDIATE = 0; const FETCH_BATCH = 1; const FETCH_OFFSET = 3; const FETCH_LAZY_OFFSET = 4; const FETCH_VHOLDER = 1; const FETCH_RECORD = 2; const FETCH_ARRAY = 3; const ACCESSOR_NONE = 0; const ACCESSOR_GET = 1; const ACCESSOR_SET = 2; const ACCESSOR_BOTH = 3; const PORTABILITY_NONE = 0; const PORTABILITY_FIX_CASE = 1; const PORTABILITY_RTRIM = 2; const PORTABILITY_DELETE_COUNT = 4; const PORTABILITY_EMPTY_TO_NULL = 8; const PORTABILITY_FIX_ASSOC_FIELD_NAMES = 16; const PORTABILITY_ALL = 17; const LOCK_OPTIMISTIC = 0; const LOCK_PESSIMISTIC = 1; const IDENTIFIER_AUTOINC = 1; const IDENTIFIER_SEQUENCE = 2; const IDENTIFIER_NATURAL = 3; const IDENTIFIER_COMPOSITE = 4; public function __construct() { throw new Doctrine_Exception('Doctrine is static class. No instances can be created.'); } private static $path; public static function getPath() { if (! self::$path) { self::$path = dirname(__FILE__); } return self::$path; } public static function loadAll() { $classes = Doctrine_Compiler::getRuntimeClasses(); foreach ($classes as $class) { Doctrine::autoload($class); } } public static function import($directory, array $databases = array()) { return Doctrine_Manager::connection()->import->import($directory, $databases); } public static function export($directory) { Doctrine_Export::export(); } public static function compile($target = null) { Doctrine_Compiler::compile($target); } public static function autoload($classname) { if (class_exists($classname, false)) { return false; } if (! self::$path) { self::$path = dirname(__FILE__); } $class = self::$path . DIRECTORY_SEPARATOR . str_replace('_', DIRECTORY_SEPARATOR,$classname) . '.php'; if ( ! file_exists($class)) { return false; } require_once($class); return true; } public static function dump($var) { $ret = array(); switch (gettype($var)) { case 'array': $ret[] = 'Array('; foreach ($var as $k => $v) { $ret[] = $k . ' : ' . Doctrine::dump($v); } $ret[] = ')'; break; case 'object'; $ret[] = 'Object(' . get_class($var) . ')'; break; default: $ret[] = var_export($var, true); } return implode("\n", $ret); } public static function tableize($classname) { return strtolower(preg_replace('~(?<=\\w)([A-Z])~', '_$1', $classname)); } public static function classify($tablename) { return preg_replace('~(_?)(_)([\w])~e', '"$1".strtoupper("$3")', ucfirst($tablename)); } public static function isValidClassname($classname) { if (preg_match('~(^[a-z])|(_[a-z])|([\W])|(_{2})~', $classname)) return false; return true; } } abstract class Doctrine_Access implements ArrayAccess { public function setArray(array $array) { foreach ($array as $k=>$v) { $this->set($k,$v); }; return $this; } public function __set($name,$value) { $this->set($name,$value); } public function __get($name) { return $this->get($name); } public function __isset($name) { return $this->contains($name); } public function __unset($name) { return $this->remove($name); } public function offsetExists($offset) { return $this->contains($offset); } public function offsetGet($offset) { return $this->get($offset); } public function offsetSet($offset, $value) { if ( ! isset($offset)) { $this->add($value); } else { $this->set($offset,$value); } } public function offsetUnset($offset) { return $this->remove($offset); } } interface Doctrine_Adapter_Interface { public function prepare($prepareString); public function query($queryString); public function quote($input); public function exec($statement); public function lastInsertId(); public function beginTransaction(); public function commit(); public function rollBack(); public function errorCode(); public function errorInfo(); } interface Doctrine_Adapter_Statement_Interface { public function bindColumn($column, $param, $type = null); public function bindValue($param, $value, $type = null); public function bindParam($column, $variable, $type = null, $length = null, $driverOptions = array()); public function closeCursor(); public function columnCount(); public function errorCode(); public function errorInfo(); public function execute($params = null); public function fetch($fetchStyle = Doctrine::FETCH_BOTH, $cursorOrientation = Doctrine::FETCH_ORI_NEXT, $cursorOffset = null); public function fetchAll($fetchStyle = Doctrine::FETCH_BOTH); public function fetchColumn($columnIndex = 0); public function fetchObject($className = 'stdClass', $args = array()); public function getAttribute($attribute); public function getColumnMeta($column); public function nextRowset(); public function rowCount(); public function setAttribute($attribute, $value); public function setFetchMode($mode, $arg1 = null, $arg2 = null); } abstract class Doctrine_Adapter_Statement { public function bindValue($no, $value) { } public function fetch() { } public function nextRowset() { } public function execute() { } public function errorCode() { } public function errorInfo() { } public function rowCount() { } public function setFetchMode($mode) { } public function columnCount(){ } } class Doctrine_Adapter { const ATTR_AUTOCOMMIT = 0; const ATTR_CASE = 8; const ATTR_CLIENT_VERSION = 5; const ATTR_CONNECTION_STATUS = 7; const ATTR_CURSOR = 10; const ATTR_CURSOR_NAME = 9; const ATTR_DRIVER_NAME = 16; const ATTR_ERRMODE = 3; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_PREFETCH = 1; const ATTR_SERVER_INFO = 6; const ATTR_SERVER_VERSION = 4; const ATTR_STATEMENT_CLASS = 13; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_TIMEOUT = 2; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERR_ALREADY_EXISTS = NULL; const ERR_CANT_MAP = NULL; const ERR_CONSTRAINT = NULL; const ERR_DISCONNECTED = NULL; const ERR_MISMATCH = NULL; const ERR_NO_PERM = NULL; const ERR_NONE = '00000'; const ERR_NOT_FOUND = NULL; const ERR_NOT_IMPLEMENTED = NULL; const ERR_SYNTAX = NULL; const ERR_TRUNCATED = NULL; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; } class Doctrine_Cache_Query_Sqlite extends Doctrine_Connection_Module implements Countable { const CACHE_TABLE = 'doctrine_query_cache'; public function __construct($conn = null) { parent::__construct($conn); $dir = 'cache'; $this->path = $dir . DIRECTORY_SEPARATOR; try { if ($this->session->getAttribute(Doctrine::ATTR_CREATE_TABLES) === true) { $columns = array(); $columns['query_md5'] = array('type' => 'string', 'length' => 32, 'notnull' => true); $columns['query_result'] = array('type' => 'array', 'length' => 100000, 'notnull' => true); $columns['expires'] = array('type' => 'integer', 'length' => 11, 'notnull' => true); $this->conn->createTable(self::CACHE_TABLE, $columns); } } catch(PDOException $e) { } } public function store($query, array $result, $lifespan) { $sql = 'INSERT INTO ' . self::CACHE_TABLE . ' (query_md5, query_result, expires) VALUES (?,?,?)'; $params = array(md5($query), serialize($result), (time() + $lifespan)); $this->conn->execute($sql, $params); } public function fetch($md5) { $sql = 'SELECT query_result, expires FROM ' . self::CACHE_TABLE . ' WHERE query_md5 = ?'; $result = $this->conn->fetchAssoc($sql, array($md5)); return unserialize($result['query_result']); } public function deleteAll() { $sql = 'DELETE FROM '.self::CACHE_TABLE; return $this->conn->exec($sql); } public function deleteExpired() { $sql = 'DELETE FROM ' . self::CACHE_TABLE . ' WHERE expired < ?'; $stmt = $this->dbh->prepare($sql); $stmt->execute(array(time())); } public function delete($md5) { $sql = 'DELETE FROM ' . self::CACHE_TABLE . ' WHERE query_md5 = ?'; return (bool) $this->conn->exec($sql, array($md5)); } public function count() { $stmt = $this->dbh->query('SELECT COUNT(*) FROM ' . self::CACHE_TABLE); $data = $stmt->fetch(PDO::FETCH_NUM); return $data[0]; } } class Doctrine_Collection extends Doctrine_Access implements Countable, IteratorAggregate, Serializable { protected $data = array(); protected $table; protected $reference; protected $reference_field; protected $relation; protected $expandable = true; protected $expanded = array(); protected $keyColumn; protected static $null; protected $aggregateValues = array(); public function __construct($table) { if ( ! ($table instanceof Doctrine_Table)) { $table = Doctrine_Manager::getInstance() ->getCurrentConnection() ->getTable($table); } $this->table = $table; $name = $table->getAttribute(Doctrine::ATTR_COLL_KEY); if ($name !== null) { $this->keyColumn = $name; } } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function getTable() { return $this->table; } public function setAggregateValue($name, $value) { $this->aggregateValues[$name] = $value; } public function getAggregateValue($name) { return $this->aggregateValues[$name]; } public function serialize() { $vars = get_object_vars($this); unset($vars['reference']); unset($vars['reference_field']); unset($vars['relation']); unset($vars['expandable']); unset($vars['expanded']); unset($vars['generator']); $vars['table'] = $vars['table']->getComponentName(); return serialize($vars); } public function unserialize($serialized) { $manager = Doctrine_Manager::getInstance(); $connection = $manager->getCurrentConnection(); $array = unserialize($serialized); foreach ($array as $name => $values) { $this->$name = $values; } $this->table = $connection->getTable($this->table); $this->expanded = array(); $this->expandable = true; $name = $this->table->getAttribute(Doctrine::ATTR_COLL_KEY); if ($name !== null) { $this->keyColumn = $name; } } public function isExpanded($offset) { return isset($this->expanded[$offset]); } public function isExpandable() { return $this->expandable; } public function setKeyColumn($column) { $this->keyColumn = $column; } public function getKeyColumn() { return $this->column; } public function getData() { return $this->data; } public function addData(array $data) { $this->data[] = $data; } public function getFirst() { return reset($this->data); } public function getLast() { return end($this->data); } public function setReference(Doctrine_Record $record, Doctrine_Relation $relation) { $this->reference = $record; $this->relation = $relation; if ($relation instanceof Doctrine_Relation_ForeignKey || $relation instanceof Doctrine_Relation_LocalKey ) { $this->reference_field = $relation->getForeign(); $value = $record->get($relation->getLocal()); foreach ($this->getNormalIterator() as $record) { if ($value !== null) { $record->set($this->reference_field, $value, false); } else { $record->set($this->reference_field, $this->reference, false); } } } elseif ($relation instanceof Doctrine_Relation_Association) { } } public function getReference() { return $this->reference; } public function expand($key) { $where = array(); $params = array(); $limit = null; $offset = null; switch (get_class($this)) { case "Doctrine_Collection_Offset": $limit = $this->getLimit(); $offset = (floor($key / $limit) * $limit); if ( ! $this->expandable && isset($this->expanded[$offset])) { return false; } $fields = implode(", ",$this->table->getColumnNames()); break; default: if ( ! $this->expandable) { return false; } if ( ! isset($this->reference)) { return false; } $id = $this->reference->obtainIdentifier(); if (empty($id)) { return false; } switch (get_class($this)) { case "Doctrine_Collection_Immediate": $fields = implode(", ",$this->table->getColumnNames()); break; default: $fields = implode(", ",$this->table->getPrimaryKeys()); }; }; if (isset($this->relation)) { if ($this->relation instanceof Doctrine_Relation_ForeignKey) { $params[] = $this->reference->getIncremented(); $where[] = $this->reference_field." = ?"; if ( ! isset($offset)) { $ids = $this->getPrimaryKeys(); if ( ! empty($ids)) { $where[] = $this->table->getIdentifier()." NOT IN (".substr(str_repeat("?, ",count($ids)),0,-2).")"; $params = array_merge($params,$ids); } $this->expandable = false; } } elseif ($this->relation instanceof Doctrine_Relation_Association) { $asf = $this->relation->getAssociationFactory(); $query = 'SELECT '.$foreign." FROM ".$asf->getTableName()." WHERE ".$local."=".$this->getIncremented(); $table = $fk->getTable(); $graph = new Doctrine_Query($table->getConnection()); $q = 'FROM ' . $table->getComponentName() . ' WHERE ' . $table->getComponentName() . '.' . $table->getIdentifier()." IN ($query)"; } } $query = "SELECT ".$fields." FROM ".$this->table->getTableName(); $map = $this->table->inheritanceMap; foreach ($map as $k => $v) { $where[] = $k." = ?"; $params[] = $v; } if ( ! empty($where)) { $query .= " WHERE ".implode(" AND ",$where); } $coll = $this->table->execute($query, $params, $limit, $offset); if ( ! isset($offset)) { foreach ($coll as $record) { if (isset($this->reference_field)) { $record->set($this->reference_field,$this->reference, false); } $this->reference->addReference($record, $this->relation); } } else { $i = $offset; foreach ($coll as $record) { if (isset($this->reference)) { $this->reference->addReference($record, $this->relation, $i); } else { $this->data[$i] = $record; } $i++; } $this->expanded[$offset] = true; if (count($coll) < $limit) { $this->expandable = false; } } return $coll; } public function remove($key) { if ( ! isset($this->data[$key])) { $this->expand($key); throw new Doctrine_Collection_Exception('Unknown key ' . $key); } $removed = $this->data[$key]; unset($this->data[$key]); return $removed; } public function contains($key) { return isset($this->data[$key]); } public function get($key) { if ($key === null) { $record = $this->table->create(); if (isset($this->reference_field)) { $record->set($this->reference_field, $this->reference, false); } $this->data[] = $record; return $record; } if ( ! isset($this->data[$key])) { $this->expand($key); if ( ! isset($this->data[$key])) { $this->data[$key] = $this->table->create(); } if (isset($this->reference_field)) { $value = $this->reference->get($this->relation->getLocal()); if ($value !== null) { $this->data[$key]->set($this->reference_field, $value, false); } else { $this->data[$key]->set($this->reference_field, $this->reference, false); } } } return $this->data[$key]; } public function getPrimaryKeys() { $list = array(); $name = $this->table->getIdentifier(); foreach ($this->data as $record) { if (is_array($record) && isset($record[$name])) { $list[] = $record[$name]; } else { $list[] = $record->getIncremented(); } }; return $list; } public function getKeys() { return array_keys($this->data); } public function count() { return count($this->data); } public function set($key, Doctrine_Record $record) { if (isset($this->reference_field)) { $record->set($this->reference_field, $this->reference, false); } $this->data[$key] = $record; } public function add(Doctrine_Record $record,$key = null) { if (isset($this->reference_field)) { $record->set($this->reference_field, $this->reference, false); } foreach ($this->data as $val) { if ($val === $record) { return false; } } if (isset($key)) { if (isset($this->data[$key])) { return false; } $this->data[$key] = $record; return true; } if (isset($this->keyColumn)) { $value = $record->get($this->keyColumn); if ($value === null) { throw new Doctrine_Collection_Exception("Couldn't create collection index. Record field '".$this->keyColumn."' was null."); } $this->data[$value] = $record; } else { $this->data[] = $record; } return true; } public function loadRelated($name = null) { $list = array(); $query = new Doctrine_Query($this->table->getConnection()); if ( ! isset($name)) { foreach ($this->data as $record) { $value = $record->getIncremented(); if ($value !== null) { $list[] = $value; } }; $query->from($this->table->getComponentName() . '(' . implode(", ",$this->table->getPrimaryKeys()) . ')'); $query->where($this->table->getComponentName() . '.id IN (' . substr(str_repeat("?, ", count($list)),0,-2) . ')'); return $query; } $rel = $this->table->getRelation($name); if ($rel instanceof Doctrine_Relation_LocalKey || $rel instanceof Doctrine_Relation_ForeignKey) { foreach ($this->data as $record) { $list[] = $record[$rel->getLocal()]; } } else { foreach ($this->data as $record) { $value = $record->getIncremented(); if ($value !== null) { $list[] = $value; } } } $dql = $rel->getRelationDql(count($list), 'collection'); $coll = $query->query($dql, $list); $this->populateRelated($name, $coll); } public function populateRelated($name, Doctrine_Collection $coll) { $rel = $this->table->getRelation($name); $table = $rel->getTable(); $foreign = $rel->getForeign(); $local = $rel->getLocal(); if ($rel instanceof Doctrine_Relation_LocalKey) { foreach ($this->data as $key => $record) { foreach ($coll as $k => $related) { if ($related[$foreign] == $record[$local]) { $this->data[$key]->setRelated($name, $related); } } } } elseif ($rel instanceof Doctrine_Relation_ForeignKey) { foreach ($this->data as $key => $record) { if ($record->state() == Doctrine_Record::STATE_TCLEAN || $record->state() == Doctrine_Record::STATE_TDIRTY ) { continue; } $sub = new Doctrine_Collection($table); foreach ($coll as $k => $related) { if ($related[$foreign] == $record[$local]) { $sub->add($related); $coll->remove($k); } } $this->data[$key]->setRelated($name, $sub); } } elseif ($rel instanceof Doctrine_Relation_Association) { $identifier = $this->table->getIdentifier(); $asf = $rel->getAssociationFactory(); $name = $table->getComponentName(); foreach ($this->data as $key => $record) { if ($record->state() == Doctrine_Record::STATE_TCLEAN || $record->state() == Doctrine_Record::STATE_TDIRTY ) { continue; } $sub = new Doctrine_Collection($table); foreach ($coll as $k => $related) { if ($related->get($local) == $record[$identifier]) { $sub->add($related->get($name)); } } $this->data[$key]->setRelated($name, $sub); } } } public function getNormalIterator() { return new Doctrine_Collection_Iterator_Normal($this); } public function save(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->table->getConnection(); } $conn->beginTransaction(); foreach ($this as $key => $record) { $record->save(); }; $conn->commit(); } public function delete(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->table->getConnection(); } $conn->beginTransaction(); foreach ($this as $key => $record) { $record->delete(); } $conn->commit(); $this->data = array(); } public function getIterator() { $data = $this->data; return new ArrayIterator($data); } public function __toString() { return Doctrine_Lib::getCollectionAsString($this); } } abstract class Doctrine_Collection_Iterator implements Iterator { protected $collection; protected $keys; protected $key; protected $index; protected $count; public function __construct(Doctrine_Collection $collection) { $this->collection = $collection; $this->keys = $this->collection->getKeys(); $this->count = $this->collection->count(); } public function rewind() { $this->index = 0; $i = $this->index; if (isset($this->keys[$i])) { $this->key = $this->keys[$i]; } } public function key() { return $this->key; } public function current() { return $this->collection->get($this->key); } public function next() { $this->index++; $i = $this->index; if (isset($this->keys[$i])) { $this->key = $this->keys[$i]; } } } class Doctrine_Collection_Batch extends Doctrine_Collection { private $batchSize; private $loaded = array(); public function __construct(Doctrine_Table $table) { parent::__construct($table); $this->batchSize = $this->getTable()->getAttribute(Doctrine::ATTR_BATCH_SIZE); } public function setBatchSize($batchSize) { $batchSize = (int) $batchSize; if ($batchSize <= 0) { return false; } $this->batchSize = $batchSize; return true; } public function getBatchSize() { return $this->batchSize; } public function load(Doctrine_Record $record) { if (empty($this->data)) { return false; } $id = $record->obtainIdentifier(); $identifier = $this->table->getIdentifier(); foreach ($this->data as $key => $v) { if (is_object($v)) { if ($v->obtainIdentifier() == $id) { break; } } elseif (is_array($v[$identifier])) { if ($v[$identifier] == $id) { break; } } } $x = floor($key / $this->batchSize); if ( ! isset($this->loaded[$x])) { $e = $x * $this->batchSize; $e2 = ($x + 1)* $this->batchSize; $a = array(); $proxies = array(); for ($i = $e; $i < $e2 && $i < $this->count(); $i++) { if ($this->data[$i] instanceof Doctrine_Record) { $id = $this->data[$i]->getIncremented(); } elseif (is_array($this->data[$i])) { $id = $this->data[$i][$identifier]; } $a[$i] = $id; }; $c = count($a); $pk = $this->table->getPrimaryKeys(); $query = $this->table->getQuery()." WHERE "; $query .= ($c > 1)?$identifier." IN (":$pk[0]." = "; $query .= substr(str_repeat("?, ",count($a)),0,-2); $query .= ($c > 1)?") ORDER BY ".$pk[0]." ASC":""; $stmt = $this->table->getConnection()->execute($query,array_values($a)); foreach ($a as $k => $id) { $row = $stmt->fetch(PDO::FETCH_ASSOC); if ($row === false) { break; } $this->table->setData($row); if (is_object($this->data[$k])) { $this->data[$k]->factoryRefresh($this->table); } else { $this->data[$k] = $this->table->getRecord(); } } $this->loaded[$x] = true; return true; } else { return false; } } public function get($key) { if (isset($this->data[$key])) { switch (gettype($this->data[$key])) { case "array": $this->table->setData($this->data[$key]); $this->data[$key] = $this->table->getProxy(); $this->data[$key]->addCollection($this); break; }; } else { $this->expand($key); if ( ! isset($this->data[$key])) { $this->data[$key] = $this->table->create(); } } if (isset($this->reference_field)) { $this->data[$key]->set($this->reference_field, $this->reference, false); } return $this->data[$key]; } public function getIterator() { return new Doctrine_Collection_Iterator_Expandable($this); } } class Doctrine_Collection_Exception extends Doctrine_Exception { } class Doctrine_Collection_Immediate extends Doctrine_Collection { public function __construct(Doctrine_Table $table) { parent::__construct($table); } } class Doctrine_Collection_Iterator_Expandable extends Doctrine_Collection_Iterator { public function valid() { if ($this->index < $this->count) { return true; } elseif ($this->index == $this->count) { $coll = $this->collection->expand($this->index); if ($coll instanceof Doctrine_Collection) { $count = count($coll); if ($count > 0) { $this->keys = array_merge($this->keys, $coll->getKeys()); $this->count += $count; return true; } } return false; } } } class Doctrine_Collection_Iterator_Normal extends Doctrine_Collection_Iterator { public function valid() { return ($this->index < $this->count); } } class Doctrine_Collection_Iterator_Offset extends Doctrine_Collection_Iterator { public function valid() { } } class Doctrine_Collection_Lazy extends Doctrine_Collection_Batch { public function __construct(Doctrine_Table $table) { parent::__construct($table); parent::setBatchSize(1); } } class Doctrine_Collection_Offset extends Doctrine_Collection { private $limit; public function __construct(Doctrine_Table $table) { parent::__construct($table); $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); } public function getLimit() { return $this->limit; } public function getIterator() { return new Doctrine_Collection_Iterator_Expandable($this); } } class Doctrine_Compiler_Exception extends Doctrine_Exception { } class Doctrine_Compiler { private static $classes = array( 'Doctrine', 'Access', 'Adapter_Interface', 'Adapter_Statement_Interface', 'Adapter_Statement', 'Adapter', 'Cache_Query_Sqlite', 'Collection', 'Collection_Iterator', 'Collection_Batch', 'Collection_Exception', 'Collection_Immediate', 'Collection_Iterator_Expandable', 'Collection_Iterator_Normal', 'Collection_Iterator_Offset', 'Collection_Lazy', 'Collection_Offset', 'Compiler_Exception', 'Compiler', 'Configurable', 'Connection', 'Connection_Common', 'Connection_Db2', 'Connection_Exception', 'Connection_Firebird_Exception', 'Connection_Firebird', 'Connection_Informix_Exception', 'Connection_Informix', 'Connection_Mock', 'Connection_Module', 'Connection_Mssql_Exception', 'Connection_Mssql', 'Connection_Mysql_Exception', 'Connection_Mysql', 'Connection_Oracle_Exception', 'Connection_Oracle', 'Connection_Pgsql_Exception', 'Connection_Pgsql', 'Connection_Sqlite_Exception', 'Connection_Sqlite', 'Connection_UnitOfWork', 'DataDict_Exception', 'DataDict_Firebird', 'DataDict_Informix', 'DataDict_Mssql', 'DataDict_Mysql', 'DataDict_Oracle', 'DataDict_Pgsql', 'DataDict_Sqlite', 'DataDict', 'Db', 'Db_Event', 'Db_EventListener_Chain', 'Db_EventListener_Interface', 'Db_EventListener', 'Db_Exception', 'Db_Mock', 'Db_Profiler_Exception', 'Db_Profiler_Query', 'Db_Profiler', 'Db_Statement', 'EventListener_Interface', 'EventListener', 'EventListener_AccessorInvoker', 'EventListener_Chain', 'EventListener_Debugger', 'EventListener_Empty', 'Exception', 'Export', 'Export_Exception', 'Export_Firebird', 'Export_Mssql', 'Export_Mysql', 'Export_Oracle', 'Export_Pgsql', 'Export_Reporter', 'Export_Sqlite', 'Expression', 'Expression_Exception', 'Expression_Firebird', 'Expression_Informix', 'Expression_Mssql', 'Expression_Mysql', 'Expression_Oracle', 'Expression_Pgsql', 'Expression_Sqlite', 'Hook', 'Hook_Parser', 'Hook_Parser_Complex', 'Hook_Equal', 'Hook_Integer', 'Hook_WordLike', 'Hydrate_Alias', 'Hydrate', 'Identifier', 'Import_Builder', 'Import_Builder_BaseClass', 'Import_Builder_Exception', 'Import', 'Import_Exception', 'Import_Firebird', 'Import_Informix', 'Import_Mssql', 'Import_Mysql', 'Import_Oracle', 'Import_Pgsql', 'Import_Reader_Db', 'Import_Reader', 'Import_Sqlite', 'Lib', 'Locking_Exception', 'Locking_Manager_Pessimistic', 'Manager_Exception', 'Manager', 'Null', 'Overloadable', 'Query', 'Query_Part', 'Query_Condition', 'Query_Exception', 'Query_From', 'Query_Groupby', 'Query_Having', 'Query_JoinCondition', 'Query_Orderby', 'Query_Set', 'Query_Where', 'RawSql_Exception', 'RawSql', 'Record', 'Record_Exception', 'Record_Iterator', 'Record_State_Exception', 'Relation', 'Relation_Association_Self', 'Relation_Association', 'Relation_ForeignKey', 'Relation_LocalKey', 'Reporter', 'Schema_Object', 'Schema_Column', 'Schema_Database', 'Schema_Exception', 'Schema_Relation', 'Schema_Table', 'Schema', 'Sequence', 'Sequence_Db2', 'Sequence_Exception', 'Sequence_Firebird', 'Sequence_Informix', 'Sequence_Mssql', 'Sequence_Mysql', 'Sequence_Oracle', 'Sequence_Pgsql', 'Sequence_Sqlite', 'Table_Exception', 'Table', 'Table_Repository_Exception', 'Table_Repository', 'Transaction', 'Transaction_Exception', 'Transaction_Firebird', 'Transaction_Informix', 'Transaction_Mssql', 'Transaction_Mysql', 'Transaction_Oracle', 'Transaction_Pgsql', 'Transaction_Sqlite', 'Validator', 'Validator_Country', 'Validator_Creditcard', 'Validator_Date', 'Validator_Email', 'Validator_Enum', 'Validator_ErrorStack', 'Validator_Exception', 'Validator_Htmlcolor', 'Validator_Ip', 'Validator_Nospace', 'Validator_Notblank', 'Validator_Notnull', 'Validator_Range', 'Validator_Regexp', 'Validator_Unique', 'Validator_Usstate', 'ValueHolder', 'View_Exception', 'View', ); public static function getRuntimeClasses() { return self::$classes; } public static function compile($target = null) { $path = Doctrine::getPath(); $classes = self::$classes; $ret = array(); foreach ($classes as $class) { if ($class !== 'Doctrine') $class = 'Doctrine_'.$class; $file = $path.DIRECTORY_SEPARATOR.str_replace("_",DIRECTORY_SEPARATOR,$class).".php"; echo "Adding $file" . PHP_EOL; if ( ! file_exists($file)) { throw new Doctrine_Compiler_Exception("Couldn't compile $file. File $file does not exists."); } Doctrine::autoload($class); $refl = new ReflectionClass ( $class ); $lines = file( $file ); $start = $refl -> getStartLine() - 1; $end = $refl -> getEndLine(); $ret = array_merge($ret, array_slice($lines, $start, ($end - $start))); } if ($target == null) { $target = $path.DIRECTORY_SEPARATOR.'Doctrine.compiled.php'; } $fp = @fopen($target, 'w'); if ($fp === false) { throw new Doctrine_Compiler_Exception("Couldn't write compiled data. Failed to open $target"); } fwrite($fp, "<?php". " class InvalidKeyException extends Exception { }". implode('', $ret) ); fclose($fp); $stripped = php_strip_whitespace($target); $fp = @fopen($target, 'w'); if ($fp === false) { throw new Doctrine_Compiler_Exception("Couldn't write compiled data. Failed to open $file"); } fwrite($fp, $stripped); fclose($fp); } } abstract class Doctrine_Configurable { private $attributes = array(); private $parent; public function setAttribute($attribute,$value) { switch ($attribute) { case Doctrine::ATTR_BATCH_SIZE: if ($value < 0) { throw new Doctrine_Exception("Batch size should be greater than or equal to zero"); } break; case Doctrine::ATTR_FETCHMODE: if ($value < 0) { throw new Doctrine_Exception("Unknown fetchmode. See Doctrine::FETCH_* constants."); } break; case Doctrine::ATTR_LISTENER: $this->setEventListener($value); break; case Doctrine::ATTR_LOCKMODE: if ($this instanceof Doctrine_Connection) { if ($this->transaction->getState() != Doctrine_Transaction::STATE_SLEEP) { throw new Doctrine_Exception("Couldn't set lockmode. There are transactions open."); } } elseif ($this instanceof Doctrine_Manager) { foreach ($this as $connection) { if ($connection->transaction->getState() != Doctrine_Transaction::STATE_SLEEP) { throw new Doctrine_Exception("Couldn't set lockmode. There are transactions open."); } } } else { throw new Doctrine_Exception("Lockmode attribute can only be set at the global or connection level."); } break; case Doctrine::ATTR_CREATE_TABLES: $value = (bool) $value; break; case Doctrine::ATTR_ACCESSORS: $accessors = array('none','get','set','both'); break; case Doctrine::ATTR_COLL_LIMIT: if ($value < 1) { throw new Doctrine_Exception("Collection limit should be a value greater than or equal to 1."); } break; case Doctrine::ATTR_COLL_KEY: if ( ! ($this instanceof Doctrine_Table)) { throw new Doctrine_Exception("This attribute can only be set at table level."); } if ($value !== null && ! $this->hasColumn($value)) { throw new Doctrine_Exception("Couldn't set collection key attribute. No such column '$value'"); } break; case Doctrine::ATTR_VLD: case Doctrine::ATTR_AUTO_LENGTH_VLD: case Doctrine::ATTR_AUTO_TYPE_VLD: case Doctrine::ATTR_QUERY_LIMIT: case Doctrine::ATTR_QUOTE_IDENTIFIER: case Doctrine::ATTR_PORTABILITY: case Doctrine::ATTR_DEFAULT_TABLE_TYPE: case Doctrine::ATTR_ACCESSOR_PREFIX_GET: case Doctrine::ATTR_ACCESSOR_PREFIX_SET: case Doctrine::ATTR_EMULATE_DATABASE: break; case Doctrine::ATTR_SEQCOL_NAME: if ( ! is_string($value)) { throw new Doctrine_Exception('Sequence column name attribute only accepts string values'); } break; case Doctrine::ATTR_FIELD_CASE: if ($value != 0 && $value != CASE_LOWER && $value != CASE_UPPER) throw new Doctrine_Exception('Field case attribute should be either 0, CASE_LOWER or CASE_UPPER constant.'); break; case Doctrine::ATTR_SEQNAME_FORMAT: case Doctrine::ATTR_IDXNAME_FORMAT: if ($this instanceof Doctrine_Table) { throw new Doctrine_Exception('Sequence / index name format attributes cannot be set' . 'at table level (only at connection or global level).'); } break; default: throw new Doctrine_Exception("Unknown attribute."); }; $this->attributes[$attribute] = $value; } public function setEventListener($listener) { return $this->setListener($listener); } public function addListener($listener, $name = null) { if ( ! ($this->attributes[Doctrine::ATTR_LISTENER] instanceof Doctrine_EventListener_Chain)) { $this->attributes[Doctrine::ATTR_LISTENER] = new Doctrine_EventListener_Chain(); } $this->attributes[Doctrine::ATTR_LISTENER]->add($listener, $name); return $this; } public function getListener() { if ( ! isset($this->attributes[Doctrine::ATTR_LISTENER])) { if (isset($this->parent)) { return $this->parent->getListener(); } return null; } return $this->attributes[Doctrine::ATTR_LISTENER]; } public function setListener($listener) { if ( ! ($listener instanceof Doctrine_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_Exception("Couldn't set eventlistener. EventListeners should implement either Doctrine_EventListener_Interface or Doctrine_Overloadable"); } $this->attributes[Doctrine::ATTR_LISTENER] = $listener; return $this; } public function getAttribute($attribute) { $attribute = (int) $attribute; if ($attribute < 0) throw new Doctrine_Exception('Unknown attribute.'); if ( ! isset($this->attributes[$attribute])) { if (isset($this->parent)) { return $this->parent->getAttribute($attribute); } return null; } return $this->attributes[$attribute]; } public function getAttributes() { return $this->attributes; } public function setParent(Doctrine_Configurable $component) { $this->parent = $component; } public function getParent() { return $this->parent; } } abstract class Doctrine_Connection extends Doctrine_Configurable implements Countable, IteratorAggregate { protected $dbh; protected $tables = array(); protected $driverName; protected $supported = array(); private $modules = array('transaction' => false, 'expression' => false, 'dataDict' => false, 'export' => false, 'import' => false, 'sequence' => false, 'unitOfWork' => false, ); protected $properties = array('sql_comments' => array(array('start' => '--', 'end' => "\n", 'escape' => false), array('start' => '/*', 'end' => '*/', 'escape' => false) ), 'identifier_quoting' => array('start' => '"', 'end' => '"', 'escape' => '"' ), 'string_quoting' => array('start' => "'", 'end' => "'", 'escape' => false, 'escape_pattern' => false ), 'wildcards' => array('%', '_'), 'varchar_max_length' => 255, ); protected $serverInfo = array(); private static $availableDrivers = array( 'Mysql', 'Pgsql', 'Oracle', 'Informix', 'Mssql', 'Sqlite', 'Firebird' ); public function __construct(Doctrine_Manager $manager, $adapter) { if ( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) { throw new Doctrine_Connection_Exception("First argument should be an instance of PDO or implement Doctrine_Adapter_Interface"); } $this->dbh = $adapter; $this->modules['unitOfWork'] = new Doctrine_Connection_UnitOfWork($this); $this->setParent($manager); $this->dbh->setAttribute(PDO::ATTR_CASE, PDO::CASE_NATURAL); $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $this->getAttribute(Doctrine::ATTR_LISTENER)->onOpen($this); } public function getName() { return $this->driverName; } public function __get($name) { if (isset($this->properties[$name])) return $this->properties[$name]; if ( ! isset($this->modules[$name])) { throw new Doctrine_Connection_Exception('Unknown module / property ' . $name); } if ($this->modules[$name] === false) { switch ($name) { case 'unitOfWork': $this->modules[$name] = new Doctrine_Connection_UnitOfWork($this); break; default: $class = 'Doctrine_' . ucwords($name) . '_' . $this->getName(); $this->modules[$name] = new $class($this); } } return $this->modules[$name]; } public function escapePattern($text) { if ($this->string_quoting['escape_pattern']) { $text = str_replace($this->string_quoting['escape_pattern'], $this->string_quoting['escape_pattern'] . $this->string_quoting['escape_pattern'], $text); foreach ($this->wildcards as $wildcard) { $text = str_replace($wildcard, $this->string_quoting['escape_pattern'] . $wildcard, $text); } } return $text; } public function convertBooleans(array $items) { foreach ($items as $k => $item) { if (is_bool($item)) { $items[$k] = (int) $item; } } return $items; } public function quoteIdentifier($str, $checkOption = true) { if ($checkOption && ! $this->getAttribute(Doctrine::ATTR_QUOTE_IDENTIFIER)) { return $str; } $str = str_replace($this->properties['identifier_quoting']['end'], $this->properties['identifier_quoting']['escape'] . $this->properties['identifier_quoting']['end'], $str); return $this->properties['identifier_quoting']['start'] . $str . $this->properties['identifier_quoting']['end']; } public function getManager() { return $this->getParent(); } public function getDbh() { return $this->dbh; } public function driverName($name) { } public function supports($feature) { return (isset($this->supported[$feature]) && ($this->supported[$feature] === 'emulated' || $this->supported[$feature] ) ); } public function quote($input, $type = null) { if ($type == null) { $type = gettype($input); } switch ($type) { case 'integer': case 'enum': case 'boolean': case 'double': case 'float': case 'bool': case 'int': return $input; case 'array': case 'object': $input = serialize($input); case 'string': case 'char': case 'varchar': case 'text': case 'gzip': case 'blob': case 'clob': return $this->dbh->quote($input); } } public function fixSequenceName($sqn) { $seqPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT)).'$/i'; $seqName = preg_replace($seqPattern, '\\1', $sqn); if ($seqName && ! strcasecmp($sqn, $this->getSequenceName($seqName))) { return $seqName; } return $sqn; } public function fixIndexName($idx) { $indexPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT)).'$/i'; $indexName = preg_replace($indexPattern, '\\1', $idx); if ($indexName && ! strcasecmp($idx, $this->getIndexName($indexName))) { return $indexName; } return $idx; } public function getSequenceName($sqn) { return sprintf($this->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT), preg_replace('/[^a-z0-9_\$.]/i', '_', $sqn)); } public function getIndexName($idx) { return sprintf($this->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT), preg_replace('/[^a-z0-9_\$]/i', '_', $idx)); } public function replace($table, array $fields, array $keys) { if (empty($keys)) { throw new Doctrine_Connection_Exception('Not specified which fields are keys'); } $condition = $values = array(); foreach ($fields as $name => $value) { $values[$name] = $value; if (in_array($name, $keys)) { if ($value === null) throw new Doctrine_Connection_Exception('key value '.$name.' may not be null'); $condition[] = $name . ' = ?'; $conditionValues[] = $value; } } $query = 'DELETE FROM '. $table . ' WHERE ' . implode(' AND ', $condition); $affectedRows = $this->exec($query); $this->insert($table, $values); $affectedRows++; return $affectedRows; } public function insert($table, array $values = array()) { if (empty($values)) { return false; } $cols = array_keys($values); $query = "INSERT INTO $table " . '(' . implode(', ', $cols) . ') ' . 'VALUES (' . substr(str_repeat('?, ', count($values)), 0, -2) . ')'; $this->execute($query, array_values($values)); return true; } public function setCharset($charset) { } public function setDateFormat($format = null) { } public function fetchAll($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(PDO::FETCH_ASSOC); } public function fetchOne($statement, array $params = array(), $colnum = 0) { return $this->execute($statement, $params)->fetchColumn($colnum); } public function fetchRow($statement, array $params = array()) { return $this->execute($statement, $params)->fetch(PDO::FETCH_ASSOC); } public function fetchArray($statement, array $params = array()) { return $this->execute($statement, $params)->fetch(PDO::FETCH_NUM); } public function fetchColumn($statement, array $params = array(), $colnum = 0) { return $this->execute($statement, $params)->fetchAll(PDO::FETCH_COLUMN, $colnum); } public function fetchAssoc($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(PDO::FETCH_ASSOC); } public function fetchBoth($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(PDO::FETCH_BOTH); } public function query($query, array $params = array()) { $parser = new Doctrine_Query($this); return $parser->query($query, $params); } public function queryOne($query, array $params = array()) { $parser = new Doctrine_Query($this); $coll = $parser->query($query, $params); if ( ! $coll->contains(0)) { return false; } return $coll[0]; } public function select($query,$limit = 0,$offset = 0) { if ($limit > 0 || $offset > 0) { $query = $this->modifyLimitQuery($query, $limit, $offset); } return $this->dbh->query($query); } public function standaloneQuery($query, $params = array()) { return $this->execute($query, $params); } public function execute($query, array $params = array()) { try { if ( ! empty($params)) { $stmt = $this->dbh->prepare($query); $stmt->execute($params); return $stmt; } else { return $this->dbh->query($query); } } catch(Doctrine_Adapter_Exception $e) { } catch(PDOException $e) { } $this->rethrowException($e); } public function exec($query, array $params = array()) { try { if ( ! empty($params)) { $stmt = $this->dbh->prepare($query); $stmt->execute($params); return $stmt->rowCount(); } else { return $this->dbh->exec($query); } } catch(Doctrine_Adapter_Exception $e) { } catch(PDOException $e) { } $this->rethrowException($e); } private function rethrowException(Exception $e) { $name = 'Doctrine_Connection_' . $this->driverName . '_Exception'; $exc = new $name($e->getMessage(), (int) $e->getCode()); if ( ! is_array($e->errorInfo)) { $e->errorInfo = array(null, null, null, null); } $exc->processErrorInfo($e->errorInfo); throw $exc; } public function hasTable($name) { return isset($this->tables[$name]); } public function getTable($name, $allowExport = true) { if (isset($this->tables[$name])) { return $this->tables[$name]; } $class = $name . 'Table'; if (class_exists($class) && in_array('Doctrine_Table', class_parents($class))) { $table = new $class($name, $this, $allowExport); } else { $table = new Doctrine_Table($name, $this, $allowExport); } $this->tables[$name] = $table; return $table; } public function getTables() { return $this->tables; } public function getIterator() { return new ArrayIterator($this->tables); } public function count() { return count($this->tables); } public function addTable(Doctrine_Table $objTable) { $name = $objTable->getComponentName(); if (isset($this->tables[$name])) { return false; } $this->tables[$name] = $objTable; return true; } public function create($name) { return $this->getTable($name)->create(); } public function flush() { $this->beginTransaction(); $this->unitOfWork->saveAll(); $this->commit(); } public function clear() { foreach ($this->tables as $k => $table) { $table->getRepository()->evictAll(); $table->clear(); } } public function evictTables() { $this->tables = array(); } public function close() { $this->getAttribute(Doctrine::ATTR_LISTENER)->onPreClose($this); $this->clear(); $this->getAttribute(Doctrine::ATTR_LISTENER)->onClose($this); } public function getTransactionLevel() { return $this->transaction->getTransactionLevel(); } public function beginTransaction() { $this->transaction->beginTransaction(); } public function commit() { $this->transaction->commit(); } public function rollback() { $this->transaction->rollback(); } public function save(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreSave($record); switch ($record->state()) { case Doctrine_Record::STATE_TDIRTY: $this->unitOfWork->insert($record); break; case Doctrine_Record::STATE_DIRTY: case Doctrine_Record::STATE_PROXY: $this->unitOfWork->update($record); break; case Doctrine_Record::STATE_CLEAN: case Doctrine_Record::STATE_TCLEAN: break; }; $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onSave($record); } public function delete(Doctrine_Record $record) { if ( ! $record->exists()) { return false; } $this->beginTransaction(); $record->getTable()->getListener()->onPreDelete($record); $this->unitOfWork->deleteComposites($record); $this->transaction->addDelete($record); $record->getTable()->getListener()->onDelete($record); $this->commit(); return true; } public function __toString() { return Doctrine_Lib::getConnectionAsString($this); } } class Doctrine_Connection_Common extends Doctrine_Connection { public function modifyLimitQuery($query,$limit = false,$offset = false,$isManip=false) { if ($limit && $offset) { $query .= " LIMIT ".$limit." OFFSET ".$offset; } elseif ($limit && ! $offset) { $query .= " LIMIT ".$limit; } elseif ( ! $limit && $offset) { $query .= " LIMIT 999999999999 OFFSET ".$offset; } return $query; } } class Doctrine_Connection_Db2 extends Doctrine_Connection { public function modifyLimitQuery($query, $limit, $offset) { if ($limit <= 0) return $sql; if ($offset == 0) { return $sql . ' FETCH FIRST '. $count .' ROWS ONLY'; } else { $sqlPieces = explode('from', $sql); $select = $sqlPieces[0]; $table = $sqlPieces[1]; $col = explode('select', $select); $sql = 'WITH OFFSET AS(' . $select . ', ROW_NUMBER() ' . 'OVER(ORDER BY ' . $col[1] . ') AS dctrn_rownum FROM ' . $table . ')' . $select . 'FROM OFFSET WHERE dctrn_rownum BETWEEN ' . $offset . 'AND ' . ($offset + $count - 1); return $sql; } } } class Doctrine_Connection_Exception extends Doctrine_Exception { protected static $errorMessages = array( Doctrine::ERR => 'unknown error', Doctrine::ERR_ALREADY_EXISTS => 'already exists', Doctrine::ERR_CANNOT_CREATE => 'can not create', Doctrine::ERR_CANNOT_ALTER => 'can not alter', Doctrine::ERR_CANNOT_REPLACE => 'can not replace', Doctrine::ERR_CANNOT_DELETE => 'can not delete', Doctrine::ERR_CANNOT_DROP => 'can not drop', Doctrine::ERR_CONSTRAINT => 'constraint violation', Doctrine::ERR_CONSTRAINT_NOT_NULL=> 'null value violates not-null constraint', Doctrine::ERR_DIVZERO => 'division by zero', Doctrine::ERR_INVALID => 'invalid', Doctrine::ERR_INVALID_DATE => 'invalid date or time', Doctrine::ERR_INVALID_NUMBER => 'invalid number', Doctrine::ERR_MISMATCH => 'mismatch', Doctrine::ERR_NODBSELECTED => 'no database selected', Doctrine::ERR_NOSUCHFIELD => 'no such field', Doctrine::ERR_NOSUCHTABLE => 'no such table', Doctrine::ERR_NOT_CAPABLE => 'Doctrine backend not capable', Doctrine::ERR_NOT_FOUND => 'not found', Doctrine::ERR_NOT_LOCKED => 'not locked', Doctrine::ERR_SYNTAX => 'syntax error', Doctrine::ERR_UNSUPPORTED => 'not supported', Doctrine::ERR_VALUE_COUNT_ON_ROW => 'value count on row', Doctrine::ERR_INVALID_DSN => 'invalid DSN', Doctrine::ERR_CONNECT_FAILED => 'connect failed', Doctrine::ERR_NEED_MORE_DATA => 'insufficient data supplied', Doctrine::ERR_EXTENSION_NOT_FOUND=> 'extension not found', Doctrine::ERR_NOSUCHDB => 'no such database', Doctrine::ERR_ACCESS_VIOLATION => 'insufficient permissions', Doctrine::ERR_LOADMODULE => 'error while including on demand module', Doctrine::ERR_TRUNCATED => 'truncated', Doctrine::ERR_DEADLOCK => 'deadlock detected', ); protected $portableCode; public function getPortableCode() { return $this->portableCode; } public function getPortableMessage() { return self::errorMessage($this->portableCode); } public static function errorMessage($value = null) { return isset(self::$errorMessages[$value]) ? self::$errorMessages[$value] : self::$errorMessages[Doctrine::ERR]; } } class Doctrine_Connection_Firebird_Exception extends Doctrine_Connection_Exception { protected static $errorCodeMap = array( -104 => Doctrine::ERR_SYNTAX, -150 => Doctrine::ERR_ACCESS_VIOLATION, -151 => Doctrine::ERR_ACCESS_VIOLATION, -155 => Doctrine::ERR_NOSUCHTABLE, -157 => Doctrine::ERR_NOSUCHFIELD, -158 => Doctrine::ERR_VALUE_COUNT_ON_ROW, -170 => Doctrine::ERR_MISMATCH, -171 => Doctrine::ERR_MISMATCH, -172 => Doctrine::ERR_INVALID, -205 => Doctrine::ERR_NOSUCHFIELD, -206 => Doctrine::ERR_NOSUCHFIELD, -208 => Doctrine::ERR_INVALID, -219 => Doctrine::ERR_NOSUCHTABLE, -297 => Doctrine::ERR_CONSTRAINT, -303 => Doctrine::ERR_INVALID, -413 => Doctrine::ERR_INVALID_NUMBER, -530 => Doctrine::ERR_CONSTRAINT, -551 => Doctrine::ERR_ACCESS_VIOLATION, -552 => Doctrine::ERR_ACCESS_VIOLATION, -625 => Doctrine::ERR_CONSTRAINT_NOT_NULL, -803 => Doctrine::ERR_CONSTRAINT, -804 => Doctrine::ERR_VALUE_COUNT_ON_ROW, -904 => Doctrine::ERR_CONNECT_FAILED, -922 => Doctrine::ERR_NOSUCHDB, -923 => Doctrine::ERR_CONNECT_FAILED, -924 => Doctrine::ERR_CONNECT_FAILED ); protected static $errorRegexps = array( '/generator .* is not defined/' => Doctrine::ERR_SYNTAX, '/table.*(not exist|not found|unknown)/i' => Doctrine::ERR_NOSUCHTABLE, '/table .* already exists/i' => Doctrine::ERR_ALREADY_EXISTS, '/unsuccessful metadata update .* failed attempt to store duplicate value/i' => Doctrine::ERR_ALREADY_EXISTS, '/unsuccessful metadata update .* not found/i' => Doctrine::ERR_NOT_FOUND, '/validation error for column .* value "\*\*\* null/i' => Doctrine::ERR_CONSTRAINT_NOT_NULL, '/violation of [\w ]+ constraint/i' => Doctrine::ERR_CONSTRAINT, '/conversion error from string/i' => Doctrine::ERR_INVALID_NUMBER, '/no permission for/i' => Doctrine::ERR_ACCESS_VIOLATION, '/arithmetic exception, numeric overflow, or string truncation/i' => Doctrine::ERR_INVALID, '/table unknown/i' => Doctrine::ERR_NOSUCHTABLE, ); public function processErrorInfo(array $errorInfo) { foreach (self::$errorRegexps as $regexp => $code) { if (preg_match($regexp, $errorInfo[2])) { $errorInfo[3] = $code; break; } } if (isset(self::$errorCodeMap[$errorInfo[1]])) { $errorInfo[3] = self::$errorCodeMap[$errorInfo[1]]; } return $errorInfo; } } class Doctrine_Connection_Firebird extends Doctrine_Connection { protected $driverName = 'Firebird'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => true, 'indexes' => true, 'affected_rows' => true, 'summary_functions' => true, 'order_by_text' => true, 'transactions' => true, 'savepoints' => true, 'current_id' => true, 'limit_queries' => 'emulated', 'LOBs' => true, 'replace' => 'emulated', 'sub_selects' => true, 'auto_increment' => true, 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => true, 'identifier_quoting' => false, 'pattern_escaping' => true ); parent::__construct($manager, $adapter); } public function setCharset($charset) { $query = 'SET NAMES '.$this->dbh->quote($charset); $this->exec($query); } public function modifyLimitQuery($query, $limit, $offset) { if ($limit > 0) { $query = preg_replace('/^([\s(])*SELECT(?!\s*FIRST\s*\d+)/i', "SELECT FIRST $limit SKIP $offset", $query); } return $query; } } class Doctrine_Connection_Informix_Exception extends Doctrine_Connection_Exception { } class Doctrine_Connection_Informix extends Doctrine_Connection { protected $driverName = 'Informix'; public function __construct(Doctrine_Manager $manager, $adapter) { parent::__construct($manager, $adapter); } } class Doctrine_Connection_Mock extends Doctrine_Connection_Common { protected $driverName = 'Mock'; public function __construct(Doctrine_Manager $manager, $adapter) { } } class Doctrine_Connection_Module { protected $conn; protected $moduleName; public function __construct($conn = null) { if ( ! ($conn instanceof Doctrine_Connection)) { $conn = Doctrine_Manager::getInstance()->getCurrentConnection(); } $this->conn = $conn; $e = explode('_', get_class($this)); $this->moduleName = $e[1]; } public function getConnection() { return $this->conn; } public function getModuleName() { return $this->moduleName; } } class Doctrine_Connection_Mssql_Exception extends Doctrine_Connection_Exception { protected static $errorCodeMap = array( 110 => Doctrine::ERR_VALUE_COUNT_ON_ROW, 155 => Doctrine::ERR_NOSUCHFIELD, 170 => Doctrine::ERR_SYNTAX, 207 => Doctrine::ERR_NOSUCHFIELD, 208 => Doctrine::ERR_NOSUCHTABLE, 245 => Doctrine::ERR_INVALID_NUMBER, 515 => Doctrine::ERR_CONSTRAINT_NOT_NULL, 547 => Doctrine::ERR_CONSTRAINT, 1913 => Doctrine::ERR_ALREADY_EXISTS, 2627 => Doctrine::ERR_CONSTRAINT, 2714 => Doctrine::ERR_ALREADY_EXISTS, 3701 => Doctrine::ERR_NOSUCHTABLE, 8134 => Doctrine::ERR_DIVZERO, ); public function processErrorInfo(array $errorInfo) { $code = $errorInfo[1]; if (isset(self::$errorCodeMap[$code])) { $this->portableCode = self::$errorCodeMap[$code]; return true; } return false; } } class Doctrine_Connection_Mssql extends Doctrine_Connection { protected $driverName = 'Mssql'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => 'emulated', 'indexes' => true, 'affected_rows' => true, 'transactions' => true, 'summary_functions' => true, 'order_by_text' => true, 'current_id' => 'emulated', 'limit_queries' => 'emulated', 'LOBs' => true, 'replace' => 'emulated', 'sub_selects' => true, 'auto_increment' => true, 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => 'emulated', ); parent::__construct($manager, $adapter); } public function quoteIdentifier($identifier, $checkOption = false) { if ($checkOption && ! $this->getAttribute(Doctrine::ATTR_QUOTE_IDENTIFIER)) { return $identifier; } return '[' . str_replace(']', ']]', $identifier) . ']'; } public function modifyLimitQuery($query, $limit, $offset, $isManip = false) { if ($limit > 0) { $select = 'SELECT '; if (preg_match('/^[[:space:]*SELECT[[:space:]]*DISTINCT/i', $query, $matches) == 1) { $select .= 'DISTINCT '; } $length = strlen($select); if (! $offset) { return $select . ' TOP ' . $limit . substr($query, $length); } $total = $limit + $offset; $order = implode(',', $parts['order']); $reverse = $order; $reverse = str_ireplace(" ASC", " \xFF", $reverse); $reverse = str_ireplace(" DESC", " ASC", $reverse); $reverse = str_ireplace(" \xFF", " DESC", $reverse); $main = $select . ' TOP ' . $total . substr($query, $length); $query = 'SELECT * FROM (' . 'SELECT TOP ' . $count . ' * FROM (' . $main . ') AS select_limit_rev ORDER BY '. $reverse . ') AS select_limit ORDER BY ' . $order; } return $query; } public function getServerVersion($native = false) { if ($this->serverInfo) { $serverInfo = $this->serverInfo; } else { $query = 'SELECT @@VERSION'; $serverInfo = $this->fetchOne($query); } $this->serverInfo = $serverInfo; if ( ! $native) { if (preg_match('/([0-9]+)\.([0-9]+)\.([0-9]+)/', $serverInfo, $tmp)) { $serverInfo = array( 'major' => $tmp[1], 'minor' => $tmp[2], 'patch' => $tmp[3], 'extra' => null, 'native' => $serverInfo, ); } else { $serverInfo = array( 'major' => null, 'minor' => null, 'patch' => null, 'extra' => null, 'native' => $serverInfo, ); } } return $serverInfo; } public function checkSequence($seqName) { $query = 'SELECT * FROM ' . $seqName; try { $this->exec($query); } catch(Doctrine_Connection_Exception $e) { if ($e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { return false; } throw $e; } return true; } } class Doctrine_Connection_Mysql_Exception extends Doctrine_Connection_Exception { protected static $errorCodeMap = array( 1004 => Doctrine::ERR_CANNOT_CREATE, 1005 => Doctrine::ERR_CANNOT_CREATE, 1006 => Doctrine::ERR_CANNOT_CREATE, 1007 => Doctrine::ERR_ALREADY_EXISTS, 1008 => Doctrine::ERR_CANNOT_DROP, 1022 => Doctrine::ERR_ALREADY_EXISTS, 1044 => Doctrine::ERR_ACCESS_VIOLATION, 1046 => Doctrine::ERR_NODBSELECTED, 1048 => Doctrine::ERR_CONSTRAINT, 1049 => Doctrine::ERR_NOSUCHDB, 1050 => Doctrine::ERR_ALREADY_EXISTS, 1051 => Doctrine::ERR_NOSUCHTABLE, 1054 => Doctrine::ERR_NOSUCHFIELD, 1061 => Doctrine::ERR_ALREADY_EXISTS, 1062 => Doctrine::ERR_ALREADY_EXISTS, 1064 => Doctrine::ERR_SYNTAX, 1091 => Doctrine::ERR_NOT_FOUND, 1100 => Doctrine::ERR_NOT_LOCKED, 1136 => Doctrine::ERR_VALUE_COUNT_ON_ROW, 1142 => Doctrine::ERR_ACCESS_VIOLATION, 1146 => Doctrine::ERR_NOSUCHTABLE, 1216 => Doctrine::ERR_CONSTRAINT, 1217 => Doctrine::ERR_CONSTRAINT, ); public function processErrorInfo(array $errorInfo) { $code = $errorInfo[1]; if (isset(self::$errorCodeMap[$code])) { $this->portableCode = self::$errorCodeMap[$code]; return true; } return false; } } class Doctrine_Connection_Mysql extends Doctrine_Connection_Common { protected $driverName = 'Mysql'; public function __construct(Doctrine_Manager $manager, $adapter) { $adapter->setAttribute(PDO::ATTR_EMULATE_PREPARES, true); $this->setAttribute(Doctrine::ATTR_DEFAULT_TABLE_TYPE, 'INNODB'); $this->supported = array( 'sequences' => 'emulated', 'indexes' => true, 'affected_rows' => true, 'transactions' => true, 'savepoints' => false, 'summary_functions' => true, 'order_by_text' => true, 'current_id' => 'emulated', 'limit_queries' => true, 'LOBs' => true, 'replace' => true, 'sub_selects' => true, 'auto_increment' => true, 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => 'emulated', 'identifier_quoting' => true, 'pattern_escaping' => true ); $this->properties['string_quoting'] = array('start' => "'", 'end' => "'", 'escape' => '\\', 'escape_pattern' => '\\'); $this->properties['identifier_quoting'] = array('start' => '`', 'end' => '`', 'escape' => '`'); $this->properties['sql_comments'] = array( array('start' => '-- ', 'end' => "\n", 'escape' => false), array('start' => '#', 'end' => "\n", 'escape' => false), array('start' => '/*', 'end' => '*/', 'escape' => false), ); $this->properties['varchar_max_length'] = 255; parent::__construct($manager, $adapter); } public function setCharset($charset) { $query = 'SET NAMES '.$this->dbh->quote($charset); $this->exec($query); } public function replace($table, array $fields, array $keys) { $count = count($fields); $query = $values = ''; $keys = $colnum = 0; for (reset($fields); $colnum < $count; next($fields), $colnum++) { $name = key($fields); if ($colnum > 0) { $query .= ','; $values.= ','; } $query .= $name; if (isset($fields[$name]['null']) && $fields[$name]['null']) { $value = 'NULL'; } else { $type = isset($fields[$name]['type']) ? $fields[$name]['type'] : null; $value = $this->quote($fields[$name]['value'], $type); } $values .= $value; if (isset($fields[$name]['key']) && $fields[$name]['key']) { if ($value === 'NULL') { throw new Doctrine_Connection_Mysql_Exception('key value '.$name.' may not be NULL'); } $keys++; } } if ($keys == 0) { throw new Doctrine_Connection_Mysql_Exception('not specified which fields are keys'); } $query = 'REPLACE INTO ' . $table . ' (' . $query . ') VALUES (' . $values . ')'; return $this->exec($query); } } class Doctrine_Connection_Oracle_Exception extends Doctrine_Connection_Exception { protected static $errorCodeMap = array( 1 => Doctrine::ERR_CONSTRAINT, 900 => Doctrine::ERR_SYNTAX, 904 => Doctrine::ERR_NOSUCHFIELD, 913 => Doctrine::ERR_VALUE_COUNT_ON_ROW, 921 => Doctrine::ERR_SYNTAX, 923 => Doctrine::ERR_SYNTAX, 942 => Doctrine::ERR_NOSUCHTABLE, 955 => Doctrine::ERR_ALREADY_EXISTS, 1400 => Doctrine::ERR_CONSTRAINT_NOT_NULL, 1401 => Doctrine::ERR_INVALID, 1407 => Doctrine::ERR_CONSTRAINT_NOT_NULL, 1418 => Doctrine::ERR_NOT_FOUND, 1476 => Doctrine::ERR_DIVZERO, 1722 => Doctrine::ERR_INVALID_NUMBER, 2289 => Doctrine::ERR_NOSUCHTABLE, 2291 => Doctrine::ERR_CONSTRAINT, 2292 => Doctrine::ERR_CONSTRAINT, 2449 => Doctrine::ERR_CONSTRAINT, ); public function processErrorInfo(array $errorInfo) { $code = $errorInfo[1]; if (isset(self::$errorCodeMap[$code])) { $this->portableCode = self::$errorCodeMap[$code]; return true; } return false; } } class Doctrine_Connection_Oracle extends Doctrine_Connection { protected $driverName = 'Oracle'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => true, 'indexes' => true, 'summary_functions' => true, 'order_by_text' => true, 'current_id' => true, 'affected_rows' => true, 'transactions' => true, 'savepoints' => true, 'limit_queries' => true, 'LOBs' => true, 'replace' => 'emulated', 'sub_selects' => true, 'auto_increment' => false, 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => true, 'identifier_quoting' => true, 'pattern_escaping' => true, ); parent::__construct($manager, $adapter); } public function setDateFormat($format = 'YYYY-MM-DD HH24:MI:SS') { $this->exec('ALTER SESSION SET NLS_DATE_FORMAT "'.$format.'";'); } public function modifyLimitQuery($query, $limit, $offset) { if (preg_match('/^\s*SELECT/i', $query)) { if ( ! preg_match('/\sFROM\s/i', $query)) { $query .= " FROM dual"; } if ($limit > 0) { $max = $offset + $limit; if ($offset > 0) { $min = $offset + 1; $query = 'SELECT * FROM (SELECT a.*, ROWNUM dctrn_rownum FROM (' . $query . ') a WHERE ROWNUM <= ' . $max . ') WHERE dctrn_rownum >= ' . $min; } else { $query = 'SELECT a.* FROM (' . $query .') a WHERE ROWNUM <= ' . $max; } } } return $query; } } class Doctrine_Connection_Pgsql_Exception extends Doctrine_Connection_Exception { protected static $errorRegexps = array( '/parser: parse error at or near/i' => Doctrine::ERR_SYNTAX, '/syntax error at/' => Doctrine::ERR_SYNTAX, '/column reference .* is ambiguous/i' => Doctrine::ERR_SYNTAX, '/column .* (of relation .*)?does not exist/i' => Doctrine::ERR_NOSUCHFIELD, '/attribute .* not found|relation .* does not have attribute/i' => Doctrine::ERR_NOSUCHFIELD, '/column .* specified in USING clause does not exist in (left|right) table/i' => Doctrine::ERR_NOSUCHFIELD, '/(relation|sequence|table).*does not exist|class .* not found/i' => Doctrine::ERR_NOSUCHTABLE, '/index .* does not exist/' => Doctrine::ERR_NOT_FOUND, '/relation .* already exists/i' => Doctrine::ERR_ALREADY_EXISTS, '/(divide|division) by zero$/i' => Doctrine::ERR_DIVZERO, '/pg_atoi: error in .*: can\'t parse /i' => Doctrine::ERR_INVALID_NUMBER, '/invalid input syntax for( type)? (integer|numeric)/i' => Doctrine::ERR_INVALID_NUMBER, '/value .* is out of range for type \w*int/i' => Doctrine::ERR_INVALID_NUMBER, '/integer out of range/i' => Doctrine::ERR_INVALID_NUMBER, '/value too long for type character/i' => Doctrine::ERR_INVALID, '/permission denied/' => Doctrine::ERR_ACCESS_VIOLATION, '/violates [\w ]+ constraint/' => Doctrine::ERR_CONSTRAINT, '/referential integrity violation/' => Doctrine::ERR_CONSTRAINT, '/violates not-null constraint/' => Doctrine::ERR_CONSTRAINT_NOT_NULL, '/more expressions than target columns/i' => Doctrine::ERR_VALUE_COUNT_ON_ROW, ); public function processErrorInfo(array $errorInfo) { foreach (self::$errorRegexps as $regexp => $code) { if (preg_match($regexp, $errorInfo[2])) { $this->portableCode = $code; return true; } } return false; } } class Doctrine_Connection_Pgsql extends Doctrine_Connection_Common { protected $driverName = 'Pgsql'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => true, 'indexes' => true, 'affected_rows' => true, 'summary_functions' => true, 'order_by_text' => true, 'transactions' => true, 'savepoints' => true, 'current_id' => true, 'limit_queries' => true, 'LOBs' => true, 'replace' => 'emulated', 'sub_selects' => true, 'auto_increment' => 'emulated', 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => true, 'identifier_quoting' => true, 'pattern_escaping' => true, ); $this->properties['string_quoting'] = array('start' => "'", 'end' => "'", 'escape' => "'", 'escape_pattern' => '\\'); $this->properties['identifier_quoting'] = array('start' => '"', 'end' => '"', 'escape' => '"'); parent::__construct($manager, $adapter); } public function setCharset($charset) { $query = 'SET NAMES '.$this->dbh->quote($charset); $this->exec($query); } public function convertBooleans(array $items) { return $items; } public function modifyLimitQuery($query, $limit = false, $offset = false, $isManip = false) { if ($limit > 0) { $query = rtrim($query); if (substr($query, -1) == ';') { $query = substr($query, 0, -1); } if ($isManip) { $manip = preg_replace('/^(DELETE FROM|UPDATE).*$/', '\\1', $query); $from = $match[2]; $where = $match[3]; $query = $manip . ' ' . $from . ' WHERE ctid=(SELECT ctid FROM ' . $from . ' ' . $where . ' LIMIT ' . $limit . ')'; } else { if ($limit !== false) { $query .= ' LIMIT ' . $limit; } if ($offset !== false) { $query .= ' OFFSET ' . $offset; } } } return $query; } public function getServerVersion($native = false) { $query = 'SHOW SERVER_VERSION'; $serverInfo = $this->fetchOne($query); if ( ! $native) { $tmp = explode('.', $serverInfo, 3); if (empty($tmp[2]) && isset($tmp[1]) && preg_match('/(\d+)(.*)/', $tmp[1], $tmp2) ) { $serverInfo = array( 'major' => $tmp[0], 'minor' => $tmp2[1], 'patch' => null, 'extra' => $tmp2[2], 'native' => $serverInfo, ); } else { $serverInfo = array( 'major' => isset($tmp[0]) ? $tmp[0] : null, 'minor' => isset($tmp[1]) ? $tmp[1] : null, 'patch' => isset($tmp[2]) ? $tmp[2] : null, 'extra' => null, 'native' => $serverInfo, ); } } return $serverInfo; } } class Doctrine_Connection_Sqlite_Exception extends Doctrine_Connection_Exception { protected static $errorRegexps = array( '/^no such table:/' => Doctrine::ERR_NOSUCHTABLE, '/^no such index:/' => Doctrine::ERR_NOT_FOUND, '/^(table|index) .* already exists$/' => Doctrine::ERR_ALREADY_EXISTS, '/PRIMARY KEY must be unique/i' => Doctrine::ERR_CONSTRAINT, '/is not unique/' => Doctrine::ERR_CONSTRAINT, '/columns .* are not unique/i' => Doctrine::ERR_CONSTRAINT, '/uniqueness constraint failed/' => Doctrine::ERR_CONSTRAINT, '/may not be NULL/' => Doctrine::ERR_CONSTRAINT_NOT_NULL, '/^no such column:/' => Doctrine::ERR_NOSUCHFIELD, '/column not present in both tables/i' => Doctrine::ERR_NOSUCHFIELD, '/^near ".*": syntax error$/' => Doctrine::ERR_SYNTAX, '/[0-9]+ values for [0-9]+ columns/i' => Doctrine::ERR_VALUE_COUNT_ON_ROW, ); public function processErrorInfo(array $errorInfo) { foreach (self::$errorRegexps as $regexp => $code) { if (preg_match($regexp, $errorInfo[2])) { $this->portableCode = $code; return true; } } return false; } } class Doctrine_Connection_Sqlite extends Doctrine_Connection_Common { protected $driverName = 'Sqlite'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => 'emulated', 'indexes' => true, 'affected_rows' => true, 'summary_functions' => true, 'order_by_text' => true, 'current_id' => 'emulated', 'limit_queries' => true, 'LOBs' => true, 'replace' => true, 'transactions' => true, 'savepoints' => false, 'sub_selects' => true, 'auto_increment' => true, 'primary_key' => true, 'result_introspection' => false, 'prepared_statements' => 'emulated', 'identifier_quoting' => true, 'pattern_escaping' => false, ); parent::__construct($manager, $adapter); } public function initFunctions() { $this->dbh->sqliteCreateFunction('md5', array('Doctrine_Expression_Sqlite', 'md5Impl'), 1); $this->dbh->sqliteCreateFunction('mod', array('Doctrine_Expression_Sqlite', 'modImpl'), 2); $this->dbh->sqliteCreateFunction('concat', array('Doctrine_Expression_Sqlite', 'concatImpl')); $this->dbh->sqliteCreateFunction('now', 'time', 0); } } class Doctrine_Connection_UnitOfWork extends Doctrine_Connection_Module implements IteratorAggregate, Countable { public function buildFlushTree(array $tables) { $tree = array(); foreach ($tables as $k => $table) { if ( ! ($table instanceof Doctrine_Table)) { $table = $this->conn->getTable($table); } $nm = $table->getComponentName(); $index = array_search($nm, $tree); if ($index === false) { $tree[] = $nm; $index = max(array_keys($tree)); } $rels = $table->getRelations(); foreach ($rels as $key => $rel) { if ($rel instanceof Doctrine_Relation_ForeignKey) { unset($rels[$key]); array_unshift($rels, $rel); } } foreach ($rels as $rel) { $name = $rel->getTable()->getComponentName(); $index2 = array_search($name,$tree); $type = $rel->getType(); if ($name === $nm) continue; if ($rel instanceof Doctrine_Relation_ForeignKey) { if ($index2 !== false) { if ($index2 >= $index) continue; unset($tree[$index]); array_splice($tree,$index2,0,$nm); $index = $index2; } else { $tree[] = $name; } } elseif ($rel instanceof Doctrine_Relation_LocalKey) { if ($index2 !== false) { if ($index2 <= $index) continue; unset($tree[$index2]); array_splice($tree,$index,0,$name); } else { array_unshift($tree,$name); $index++; } } elseif ($rel instanceof Doctrine_Relation_Association) { $t = $rel->getAssociationFactory(); $n = $t->getComponentName(); if ($index2 !== false) unset($tree[$index2]); array_splice($tree, $index, 0, $name); $index++; $index3 = array_search($n, $tree); if ($index3 !== false) { if ($index3 >= $index) continue; unset($tree[$index]); array_splice($tree, $index3, 0, $n); $index = $index2; } else { $tree[] = $n; } } } } return array_values($tree); } public function saveRelated(Doctrine_Record $record) { $saveLater = array(); foreach ($record->getReferences() as $k=>$v) { $fk = $record->getTable()->getRelation($k); if ($fk instanceof Doctrine_Relation_ForeignKey || $fk instanceof Doctrine_Relation_LocalKey) { $local = $fk->getLocal(); $foreign = $fk->getForeign(); if ($record->getTable()->hasPrimaryKey($fk->getLocal())) { if ( ! $record->exists()) { $saveLater[$k] = $fk; } else { $v->save(); } } else { $obj = $record->get($fk->getAlias()); if ($obj->state() != Doctrine_Record::STATE_TCLEAN) { $obj->save(); } } } elseif ($fk instanceof Doctrine_Relation_Association) { $v->save(); } } return $saveLater; } public function saveAssociations(Doctrine_Record $record) { foreach ($record->getTable()->getRelations() as $rel) { $table = $rel->getTable(); $alias = $rel->getAlias(); $rel->processDiff($record); } } public function deleteComposites(Doctrine_Record $record) { foreach ($record->getTable()->getRelations() as $fk) { switch ($fk->getType()) { case Doctrine_Relation::ONE_COMPOSITE: case Doctrine_Relation::MANY_COMPOSITE: $obj = $record->get($fk->getAlias()); $obj->delete(); break; }; } } public function saveAll() { $tree = $this->buildFlushTree($this->conn->getTables()); foreach ($tree as $name) { $table = $this->conn->getTable($name); foreach ($table->getRepository() as $record) { $this->conn->save($record); } } foreach ($tree as $name) { $table = $this->conn->getTable($name); foreach ($table->getRepository() as $record) { $this->saveAssociations($record); } } } public function update(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreUpdate($record); $array = $record->getPrepared(); if (empty($array)) { return false; } $set = array(); foreach ($array as $name => $value) { $set[] = $name." = ?"; if ($value instanceof Doctrine_Record) { switch ($value->state()) { case Doctrine_Record::STATE_TCLEAN: case Doctrine_Record::STATE_TDIRTY: $record->save(); default: $array[$name] = $value->getIncremented(); $record->set($name, $value->getIncremented()); }; } }; $params = array_values($array); $id = $record->obtainIdentifier(); if ( ! is_array($id)) { $id = array($id); } $id = array_values($id); $params = array_merge($params, $id); $sql = 'UPDATE ' . $record->getTable()->getTableName() . ' SET ' . implode(', ', $set) . ' WHERE ' . implode(' = ? AND ', $record->getTable()->getPrimaryKeys()) . ' = ?'; $stmt = $this->conn->getDBH()->prepare($sql); $stmt->execute($params); $record->assignIdentifier(true); $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onUpdate($record); return true; } public function insert(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreInsert($record); $array = $record->getPrepared(); if (empty($array)) { return false; } $table = $record->getTable(); $keys = $table->getPrimaryKeys(); $seq = $record->getTable()->sequenceName; if ( ! empty($seq)) { $id = $this->conn->sequence->nextId($seq); $name = $record->getTable()->getIdentifier(); $array[$name] = $id; $record->assignIdentifier($id); } $this->conn->insert($table->getTableName(), $array); if (empty($seq) && count($keys) == 1 && $keys[0] == $table->getIdentifier() && $table->getIdentifierType() != Doctrine_Identifier::NORMAL) { if (strtolower($this->conn->getName()) == 'pgsql') { $seq = $table->getTableName() . '_' . $keys[0]; } $id = $this->conn->sequence->lastInsertId($seq); if ( ! $id) { $id = $table->getMaxIdentifier(); } $record->assignIdentifier($id); } else { $record->assignIdentifier(true); } $table->getAttribute(Doctrine::ATTR_LISTENER)->onInsert($record); return true; } public function getIterator() { } public function count() { } } class Doctrine_DataDict_Exception extends Doctrine_Exception { } class Doctrine_DataDict_Firebird extends Doctrine_DataDict { public function getNativeDeclaration($field) { switch ($field['type']) { case 'varchar': case 'string': case 'array': case 'object': case 'char': case 'text': $length = !empty($field['length']) ? $field['length'] : 16777215; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? 'CHAR('.$length.')' : 'VARCHAR('.$length.')'; case 'clob': return 'BLOB SUB_TYPE 1'; case 'blob': return 'BLOB SUB_TYPE 0'; case 'integer': case 'enum': case 'int': return 'INT'; case 'boolean': return 'SMALLINT'; case 'date': return 'DATE'; case 'time': return 'TIME'; case 'timestamp': return 'TIMESTAMP'; case 'float': return 'DOUBLE PRECISION'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; return 'DECIMAL('.$length.','.$this->conn->options['decimal_places'].')'; default: throw new Doctrine_DataDict_Exception('Unknown field type '. $field['type']); } } public function getPortableDeclaration($field) { $length = (isset($field['length']) && $field['length'] > 0) ? $field['length'] : null; $type = array(); $unsigned = $fixed = null; $dbType = strtolower($field['type']); $field['field_sub_type'] = !empty($field['field_sub_type']) ? strtolower($field['field_sub_type']) : null; if ( ! isset($field['name'])) { $field['name'] = ''; } switch ($dbType) { case 'smallint': case 'integer': case 'int64': if (isset($field['field_sub_type'])) { $field['type'] = $field['field_sub_type']; return $this->getPortableDeclaration($field); } case 'bigint': case 'quad': $type[] = 'integer'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } break; case 'varchar': $fixed = false; case 'char': case 'cstring': $type[] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } if ($fixed !== false) { $fixed = true; } break; case 'date': $type[] = 'date'; $length = null; break; case 'timestamp': $type[] = 'timestamp'; $length = null; break; case 'time': $type[] = 'time'; $length = null; break; case 'float': case 'double': case 'double precision': case 'd_float': $type[] = 'float'; break; case 'decimal': case 'numeric': $type[] = 'decimal'; break; case 'blob': $type[] = ($field['field_sub_type'] == 'text') ? 'clob' : 'blob'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$dbType); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } public function getCharsetFieldDeclaration($charset) { return 'CHARACTER SET '.$charset; } public function getCollationFieldDeclaration($collation) { return 'COLLATE '.$collation; } } class Doctrine_DataDict_Informix extends Doctrine_DataDict { public function getNativeDeclaration($field) { switch ($field['type']) { case 'char': case 'varchar': case 'array': case 'object': case 'string': if (empty($field['length']) && array_key_exists('default', $field)) { $field['length'] = $this->conn->varchar_max_length; } $length = (! empty($field['length'])) ? $field['length'] : false; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? ($length ? 'CHAR('.$length.')' : 'CHAR(255)') : ($length ? 'VARCHAR('.$length.')' : 'NVARCHAR'); case 'clob': return 'TEXT'; case 'blob': return 'BLOB'; case 'integer': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 1) { return 'SMALLINT'; } elseif ($length == 2) { return 'SMALLINT'; } elseif ($length == 3 || $length == 4) { return 'INTEGER'; } elseif ($length > 4) { return 'DECIMAL(20)'; } } return 'INT'; case 'boolean': return 'SMALLINT'; case 'date': return 'DATE'; case 'time': return 'DATETIME YEAR TO SECOND'; case 'timestamp': return 'DATETIME'; case 'float': return 'FLOAT'; case 'decimal': return 'DECIMAL'; } return ''; } } class Doctrine_DataDict_Mssql extends Doctrine_DataDict { public function getNativeDeclaration($field) { switch ($field['type']) { case 'array': case 'object': case 'text': case 'char': case 'varchar': case 'string': $length = !empty($field['length']) ? $field['length'] : false; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? ($length ? 'CHAR('.$length.')' : 'CHAR('.$this->conn->options['default_text_field_length'].')') : ($length ? 'VARCHAR('.$length.')' : 'TEXT'); case 'clob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 8000) { return 'VARCHAR('.$length.')'; } } return 'TEXT'; case 'blob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 8000) { return "VARBINARY($length)"; } } return 'IMAGE'; case 'integer': case 'enum': case 'int': return 'INT'; case 'boolean': return 'BIT'; case 'date': return 'CHAR(' . strlen('YYYY-MM-DD') . ')'; case 'time': return 'CHAR(' . strlen('HH:MM:SS') . ')'; case 'timestamp': return 'CHAR(' . strlen('YYYY-MM-DD HH:MM:SS') . ')'; case 'float': return 'FLOAT'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; return 'DECIMAL('.$length.','.$this->conn->options['decimal_places'].')'; } throw new Doctrine_DataDict_Exception('Unknown column type.'); } public function getPortableDeclaration($field) { $db_type = preg_replace('/\d/','', strtolower($field['type']) ); $length = (isset($field['length']) && $field['length'] > 0) ? $field['length'] : null; $type = array(); $unsigned = $fixed = null; if ( ! isset($field['name'])) $field['name'] = ''; switch ($db_type) { case 'bit': $type[0] = 'boolean'; break; case 'int': $type[0] = 'integer'; if ($length == 1) { $type[] = 'boolean'; } break; case 'datetime': $type[0] = 'timestamp'; break; case 'float': case 'real': case 'numeric': $type[0] = 'float'; break; case 'decimal': case 'money': $type[0] = 'decimal'; break; case 'text': case 'varchar': $fixed = false; case 'char': $type[0] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^[is|has]/', $field['name'])) { $type = array_reverse($type); } } elseif (strstr($db_type, 'text')) { $type[] = 'clob'; } if ($fixed !== false) { $fixed = true; } break; case 'image': case 'varbinary': $type[] = 'blob'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$db_type); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } } class Doctrine_DataDict_Mysql extends Doctrine_DataDict { protected $keywords = array( 'ADD', 'ALL', 'ALTER', 'ANALYZE', 'AND', 'AS', 'ASC', 'ASENSITIVE', 'BEFORE', 'BETWEEN', 'BIGINT', 'BINARY', 'BLOB', 'BOTH', 'BY', 'CALL', 'CASCADE', 'CASE', 'CHANGE', 'CHAR', 'CHARACTER', 'CHECK', 'COLLATE', 'COLUMN', 'CONDITION', 'CONNECTION', 'CONSTRAINT', 'CONTINUE', 'CONVERT', 'CREATE', 'CROSS', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP', 'CURRENT_USER', 'CURSOR', 'DATABASE', 'DATABASES', 'DAY_HOUR', 'DAY_MICROSECOND', 'DAY_MINUTE', 'DAY_SECOND', 'DEC', 'DECIMAL', 'DECLARE', 'DEFAULT', 'DELAYED', 'DELETE', 'DESC', 'DESCRIBE', 'DETERMINISTIC', 'DISTINCT', 'DISTINCTROW', 'DIV', 'DOUBLE', 'DROP', 'DUAL', 'EACH', 'ELSE', 'ELSEIF', 'ENCLOSED', 'ESCAPED', 'EXISTS', 'EXIT', 'EXPLAIN', 'FALSE', 'FETCH', 'FLOAT', 'FLOAT4', 'FLOAT8', 'FOR', 'FORCE', 'FOREIGN', 'FROM', 'FULLTEXT', 'GRANT', 'GROUP', 'HAVING', 'HIGH_PRIORITY', 'HOUR_MICROSECOND', 'HOUR_MINUTE', 'HOUR_SECOND', 'IF', 'IGNORE', 'IN', 'INDEX', 'INFILE', 'INNER', 'INOUT', 'INSENSITIVE', 'INSERT', 'INT', 'INT1', 'INT2', 'INT3', 'INT4', 'INT8', 'INTEGER', 'INTERVAL', 'INTO', 'IS', 'ITERATE', 'JOIN', 'KEY', 'KEYS', 'KILL', 'LEADING', 'LEAVE', 'LEFT', 'LIKE', 'LIMIT', 'LINES', 'LOAD', 'LOCALTIME', 'LOCALTIMESTAMP', 'LOCK', 'LONG', 'LONGBLOB', 'LONGTEXT', 'LOOP', 'LOW_PRIORITY', 'MATCH', 'MEDIUMBLOB', 'MEDIUMINT', 'MEDIUMTEXT', 'MIDDLEINT', 'MINUTE_MICROSECOND', 'MINUTE_SECOND', 'MOD', 'MODIFIES', 'NATURAL', 'NOT', 'NO_WRITE_TO_BINLOG', 'NULL', 'NUMERIC', 'ON', 'OPTIMIZE', 'OPTION', 'OPTIONALLY', 'OR', 'ORDER', 'OUT', 'OUTER', 'OUTFILE', 'PRECISION', 'PRIMARY', 'PROCEDURE', 'PURGE', 'RAID0', 'READ', 'READS', 'REAL', 'REFERENCES', 'REGEXP', 'RELEASE', 'RENAME', 'REPEAT', 'REPLACE', 'REQUIRE', 'RESTRICT', 'RETURN', 'REVOKE', 'RIGHT', 'RLIKE', 'SCHEMA', 'SCHEMAS', 'SECOND_MICROSECOND', 'SELECT', 'SENSITIVE', 'SEPARATOR', 'SET', 'SHOW', 'SMALLINT', 'SONAME', 'SPATIAL', 'SPECIFIC', 'SQL', 'SQLEXCEPTION', 'SQLSTATE', 'SQLWARNING', 'SQL_BIG_RESULT', 'SQL_CALC_FOUND_ROWS', 'SQL_SMALL_RESULT', 'SSL', 'STARTING', 'STRAIGHT_JOIN', 'TABLE', 'TERMINATED', 'THEN', 'TINYBLOB', 'TINYINT', 'TINYTEXT', 'TO', 'TRAILING', 'TRIGGER', 'TRUE', 'UNDO', 'UNION', 'UNIQUE', 'UNLOCK', 'UNSIGNED', 'UPDATE', 'USAGE', 'USE', 'USING', 'UTC_DATE', 'UTC_TIME', 'UTC_TIMESTAMP', 'VALUES', 'VARBINARY', 'VARCHAR', 'VARCHARACTER', 'VARYING', 'WHEN', 'WHERE', 'WHILE', 'WITH', 'WRITE', 'X509', 'XOR', 'YEAR_MONTH', 'ZEROFILL' ); public function getNativeDeclaration($field) { switch ($field['type']) { case 'char': $length = (! empty($field['length'])) ? $field['length'] : false; return $length ? 'CHAR('.$length.')' : 'CHAR(255)'; case 'varchar': case 'array': case 'object': case 'string': if ( ! isset($field['length'])) { if (array_key_exists('default', $field)) { $field['length'] = $this->conn->varchar_max_length; } else { $field['length'] = false; } } $length = ($field['length'] <= $this->conn->varchar_max_length) ? $field['length'] : false; $fixed = (isset($field['fixed'])) ? $field['fixed'] : false; return $fixed ? ($length ? 'CHAR(' . $length . ')' : 'CHAR(255)') : ($length ? 'VARCHAR(' . $length . ')' : 'TEXT'); case 'clob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 255) { return 'TINYTEXT'; } elseif ($length <= 65532) { return 'TEXT'; } elseif ($length <= 16777215) { return 'MEDIUMTEXT'; } } return 'LONGTEXT'; case 'blob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 255) { return 'TINYBLOB'; } elseif ($length <= 65532) { return 'BLOB'; } elseif ($length <= 16777215) { return 'MEDIUMBLOB'; } } return 'LONGBLOB'; case 'integer': case 'int': case 'enum': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 1) { return 'TINYINT'; } elseif ($length == 2) { return 'SMALLINT'; } elseif ($length == 3) { return 'MEDIUMINT'; } elseif ($length == 4) { return 'INT'; } elseif ($length > 4) { return 'BIGINT'; } } return 'INT'; case 'boolean': return 'TINYINT(1)'; case 'date': return 'DATE'; case 'time': return 'TIME'; case 'timestamp': return 'DATETIME'; case 'float': case 'double': return 'DOUBLE'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; return 'DECIMAL(' . $length . ',' . 0 . ')'; } throw new Doctrine_DataDict_Exception('Unknown column type.'); } public function getPortableDeclaration(array $field) { $dbType = strtolower($field['type']); $dbType = strtok($dbType, '(), '); if ($dbType == 'national') { $dbType = strtok('(), '); } if (isset($field['length'])) { $length = $field['length']; $decimal = ''; } else { $length = strtok('(), '); $decimal = strtok('(), '); } $type = array(); $unsigned = $fixed = null; if ( ! isset($field['name'])) { $field['name'] = ''; } switch ($dbType) { case 'tinyint': $type[] = 'integer'; $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 1; break; case 'smallint': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 2; break; case 'mediumint': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 3; break; case 'int': case 'integer': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 4; break; case 'bigint': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 8; break; case 'tinytext': case 'mediumtext': case 'longtext': case 'text': case 'text': case 'varchar': $fixed = false; case 'string': case 'char': $type[] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } elseif (strstr($dbType, 'text')) { $type[] = 'clob'; if ($decimal == 'binary') { $type[] = 'blob'; } } if ($fixed !== false) { $fixed = true; } break; case 'enum': $type[] = 'text'; preg_match_all('/\'.+\'/U', $field['type'], $matches); $length = 0; $fixed = false; if (is_array($matches)) { foreach ($matches[0] as $value) { $length = max($length, strlen($value)-2); } if ($length == '1' && count($matches[0]) == 2) { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } } $type[] = 'integer'; case 'set': $fixed = false; $type[] = 'text'; $type[] = 'integer'; break; case 'date': $type[] = 'date'; $length = null; break; case 'datetime': case 'timestamp': $type[] = 'timestamp'; $length = null; break; case 'time': $type[] = 'time'; $length = null; break; case 'float': case 'double': case 'real': $type[] = 'float'; $unsigned = preg_match('/ unsigned/i', $field['type']); break; case 'unknown': case 'decimal': case 'numeric': $type[] = 'decimal'; $unsigned = preg_match('/ unsigned/i', $field['type']); break; case 'tinyblob': case 'mediumblob': case 'longblob': case 'blob': $type[] = 'blob'; $length = null; break; case 'year': $type[] = 'integer'; $type[] = 'date'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$dbType); } $length = ((int) $length == 0) ? null : (int) $length; return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } public function getCharsetFieldDeclaration($charset) { return 'CHARACTER SET '.$charset; } public function getCollationFieldDeclaration($collation) { return 'COLLATE '.$collation; } public function getIntegerDeclaration($name, $field) { $default = $autoinc = ''; if (!empty($field['autoincrement'])) { $autoinc = ' AUTO_INCREMENT'; } elseif (array_key_exists('default', $field)) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : 0; } $default = ' DEFAULT '.$this->conn->quote($field['default']); } $notnull = (isset($field['notnull']) && $field['notnull']) ? ' NOT NULL' : ''; $unsigned = (isset($field['unsigned']) && $field['unsigned']) ? ' UNSIGNED' : ''; $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $this->getNativeDeclaration($field) . $unsigned . $default . $notnull . $autoinc; } } class Doctrine_DataDict_Oracle extends Doctrine_DataDict { public function getNativeDeclaration(array $field) { switch ($field['type']) { case 'string': case 'array': case 'object': case 'gzip': case 'char': case 'varchar': $length = !empty($field['length']) ? $field['length'] : 16777215; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? 'CHAR('.$length.')' : 'VARCHAR2('.$length.')'; case 'clob': return 'CLOB'; case 'blob': return 'BLOB'; case 'integer': case 'enum': case 'int': if (!empty($field['length'])) { return 'NUMBER('.$field['length'].')'; } return 'INT'; case 'boolean': return 'NUMBER(1)'; case 'date': case 'time': case 'timestamp': return 'DATE'; case 'float': case 'double': return 'NUMBER'; case 'decimal': return 'NUMBER(*,'.$this->conn->options['decimal_places'].')'; default: throw new Doctrine_DataDict_Exception('Unknown field type '. $field['type']); } } public function getPortableDeclaration(array $field) { $dbType = strtolower($field['type']); $type = array(); $length = $unsigned = $fixed = null; if (!empty($field['length'])) { $length = $field['length']; } if ( ! isset($field['name'])) { $field['name'] = ''; } switch ($dbType) { case 'integer': case 'pls_integer': case 'binary_integer': $type[] = 'integer'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } break; case 'varchar': case 'varchar2': case 'nvarchar2': $fixed = false; case 'char': case 'nchar': $type[] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } if ($fixed !== false) { $fixed = true; } break; case 'date': case 'timestamp': $type[] = 'timestamp'; $length = null; break; case 'float': $type[] = 'float'; break; case 'number': if (!empty($field['scale'])) { $type[] = 'decimal'; } else { $type[] = 'integer'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } } break; case 'long': $type[] = 'string'; case 'clob': case 'nclob': $type[] = 'clob'; break; case 'blob': case 'raw': case 'long raw': case 'bfile': $type[] = 'blob'; $length = null; break; case 'rowid': case 'urowid': default: throw new Doctrine_DataDict_Exception('unknown database attribute type: ' . $dbType); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } } class Doctrine_DataDict_Pgsql extends Doctrine_DataDict { protected static $reservedKeyWords = array( 'abort', 'absolute', 'access', 'action', 'add', 'after', 'aggregate', 'all', 'alter', 'analyse', 'analyze', 'and', 'any', 'as', 'asc', 'assertion', 'assignment', 'at', 'authorization', 'backward', 'before', 'begin', 'between', 'bigint', 'binary', 'bit', 'boolean', 'both', 'by', 'cache', 'called', 'cascade', 'case', 'cast', 'chain', 'char', 'character', 'characteristics', 'check', 'checkpoint', 'class', 'close', 'cluster', 'coalesce', 'collate', 'column', 'comment', 'commit', 'committed', 'constraint', 'constraints', 'conversion', 'convert', 'copy', 'create', 'createdb', 'createuser', 'cross', 'current_date', 'current_time', 'current_timestamp', 'current_user', 'cursor', 'cycle', 'database', 'day', 'deallocate', 'dec', 'decimal', 'declare', 'default', 'deferrable', 'deferred', 'definer', 'delete', 'delimiter', 'delimiters', 'desc', 'distinct', 'do', 'domain', 'double', 'drop', 'each', 'else', 'encoding', 'encrypted', 'end', 'escape', 'except', 'exclusive', 'execute', 'exists', 'explain', 'external', 'extract', 'false', 'fetch', 'float', 'for', 'force', 'foreign', 'forward', 'freeze', 'from', 'full', 'function', 'get', 'global', 'grant', 'group', 'handler', 'having', 'hour', 'ilike', 'immediate', 'immutable', 'implicit', 'in', 'increment', 'index', 'inherits', 'initially', 'inner', 'inout', 'input', 'insensitive', 'insert', 'instead', 'int', 'integer', 'intersect', 'interval', 'into', 'invoker', 'is', 'isnull', 'isolation', 'join', 'key', 'lancompiler', 'language', 'leading', 'left', 'level', 'like', 'limit', 'listen', 'load', 'local', 'localtime', 'localtimestamp', 'location', 'lock', 'match', 'maxvalue', 'minute', 'minvalue', 'mode', 'month', 'move', 'names', 'national', 'natural', 'nchar', 'new', 'next', 'no', 'nocreatedb', 'nocreateuser', 'none', 'not', 'nothing', 'notify', 'notnull', 'null', 'nullif', 'numeric', 'of', 'off', 'offset', 'oids', 'old', 'on', 'only', 'operator', 'option', 'or', 'order', 'out', 'outer', 'overlaps', 'overlay', 'owner', 'partial', 'password', 'path', 'pendant', 'placing', 'position', 'precision', 'prepare', 'primary', 'prior', 'privileges', 'procedural', 'procedure', 'read', 'real', 'recheck', 'references', 'reindex', 'relative', 'rename', 'replace', 'reset', 'restrict', 'returns', 'revoke', 'right', 'rollback', 'row', 'rule', 'schema', 'scroll', 'second', 'security', 'select', 'sequence', 'serializable', 'session', 'session_user', 'set', 'setof', 'share', 'show', 'similar', 'simple', 'smallint', 'some', 'stable', 'start', 'statement', 'statistics', 'stdin', 'stdout', 'storage', 'strict', 'substring', 'sysid', 'table', 'temp', 'template', 'temporary', 'then', 'time', 'timestamp', 'to', 'toast', 'trailing', 'transaction', 'treat', 'trigger', 'trim', 'true', 'truncate', 'trusted', 'type', 'unencrypted', 'union', 'unique', 'unknown', 'unlisten', 'until', 'update', 'usage', 'user', 'using', 'vacuum', 'valid', 'validator', 'values', 'varchar', 'varying', 'verbose', 'version', 'view', 'volatile', 'when', 'where', 'with', 'without', 'work', 'write', 'year', 'zone' ); public function getNativeDeclaration(array $field) { switch ($field['type']) { case 'char': case 'string': case 'array': case 'object': case 'varchar': $length = (isset($field['length']) && $field['length']) ? $field['length'] : null; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? ($length ? 'CHAR('.$length.')' : 'CHAR('.$this->conn->options['default_text_field_length'].')') : ($length ? 'VARCHAR('.$length.')' : 'TEXT'); case 'clob': return 'TEXT'; case 'blob': return 'BYTEA'; case 'enum': case 'integer': case 'int': if (!empty($field['autoincrement'])) { if (!empty($field['length'])) { $length = $field['length']; if ($length > 4) { return 'BIGSERIAL'; } } return 'SERIAL'; } if (!empty($field['length'])) { $length = $field['length']; if ($length <= 2) { return 'SMALLINT'; } elseif ($length == 3 || $length == 4) { return 'INT'; } elseif ($length > 4) { return 'BIGINT'; } } return 'INT'; case 'boolean': return 'BOOLEAN'; case 'date': return 'DATE'; case 'time': return 'TIME without time zone'; case 'timestamp': return 'TIMESTAMP without time zone'; case 'float': case 'double': return 'FLOAT8'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; return 'NUMERIC(' . $length . ',' . $this->conn->getAttribute(Doctrine::ATTR_DECIMAL_PLACES) . ')'; default: throw new Doctrine_DataDict_Exception('Unknown field type '. $field['type']); } } public function getPortableDeclaration(array $field) { $length = (isset($field['length'])) ? $field['length'] : null; if ($length == '-1' && isset($field['atttypmod'])) { $length = $field['atttypmod'] - 4; } if ((int)$length <= 0) { $length = null; } $type = array(); $unsigned = $fixed = null; if ( ! isset($field['name'])) { $field['name'] = ''; } $db_type = strtolower($field['type']); switch ($db_type) { case 'smallint': case 'int2': $type[] = 'integer'; $unsigned = false; $length = 2; if ($length == '2') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } break; case 'int': case 'int4': case 'integer': case 'serial': case 'serial4': $type[] = 'integer'; $unsigned = false; $length = 4; break; case 'bigint': case 'int8': case 'bigserial': case 'serial8': $type[] = 'integer'; $unsigned = false; $length = 8; break; case 'bool': case 'boolean': $type[] = 'boolean'; $length = 1; break; case 'text': case 'varchar': $fixed = false; case 'unknown': case 'char': case 'bpchar': $type[] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } elseif (strstr($db_type, 'text')) { $type[] = 'clob'; } if ($fixed !== false) { $fixed = true; } break; case 'date': $type[] = 'date'; $length = null; break; case 'datetime': case 'timestamp': $type[] = 'timestamp'; $length = null; break; case 'time': $type[] = 'time'; $length = null; break; case 'float': case 'double': case 'real': $type[] = 'float'; break; case 'decimal': case 'money': case 'numeric': $type[] = 'decimal'; break; case 'tinyblob': case 'mediumblob': case 'longblob': case 'blob': case 'bytea': $type[] = 'blob'; $length = null; break; case 'oid': $type[] = 'blob'; $type[] = 'clob'; $length = null; break; case 'year': $type[] = 'integer'; $type[] = 'date'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$db_type); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } public function getIntegerDeclaration($name, $field) { if ( ! empty($field['autoincrement'])) { $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $this->getNativeDeclaration($field); } $default = ''; if (array_key_exists('default', $field)) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : 0; } $default = ' DEFAULT '.$this->conn->quote($field['default'], $field['type']); } $notnull = empty($field['notnull']) ? '' : ' NOT NULL'; $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $this->getNativeDeclaration($field) . $default . $notnull; } public function parseBoolean($value) { return $value; } } class Doctrine_DataDict_Sqlite extends Doctrine_DataDict { public function getNativeDeclaration(array $field) { switch ($field['type']) { case 'text': case 'object': case 'array': case 'string': case 'char': case 'gzip': case 'varchar': $length = (isset($field['length']) && $field['length']) ? $field['length'] : null; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? ($length ? 'CHAR('.$length.')' : 'CHAR('.$this->conn->getAttribute(Doctrine::ATTR_DEFAULT_TEXTFLD_LENGTH).')') : ($length ? 'VARCHAR('.$length.')' : 'TEXT'); case 'clob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 255) { return 'TINYTEXT'; } elseif ($length <= 65535) { return 'TEXT'; } elseif ($length <= 16777215) { return 'MEDIUMTEXT'; } } return 'LONGTEXT'; case 'blob': if (!empty($field['length'])) { $length = $field['length']; if ($length <= 255) { return 'TINYBLOB'; } elseif ($length <= 65535) { return 'BLOB'; } elseif ($length <= 16777215) { return 'MEDIUMBLOB'; } } return 'LONGBLOB'; case 'enum': case 'integer': case 'boolean': case 'int': return 'INTEGER'; case 'date': return 'DATE'; case 'time': return 'TIME'; case 'timestamp': return 'DATETIME'; case 'float': case 'double': return 'DOUBLE'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; return 'DECIMAL('.$length.','.$this->conn->getAttribute(Doctrine::ATTR_DECIMAL_PLACES).')'; } throw new Doctrine_DataDict_Exception('Unknown datatype ' . $field['type']); } public function getPortableDeclaration(array $field) { $dbType = strtolower($field['type']); $length = (isset($field['length'])) ? $field['length'] : null; $unsigned = (isset($field['unsigned'])) ? $field['unsigned'] : null; $fixed = null; $type = array(); if ( ! isset($field['name'])) { $field['name'] = ''; } switch ($dbType) { case 'boolean': $type[] = 'boolean'; break; case 'tinyint': $type[] = 'integer'; $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 1; break; case 'smallint': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 2; break; case 'mediumint': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 3; break; case 'int': case 'integer': case 'serial': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 4; break; case 'bigint': case 'bigserial': $type[] = 'integer'; $unsigned = preg_match('/ unsigned/i', $field['type']); $length = 8; break; case 'clob': case 'tinytext': case 'mediumtext': case 'longtext': case 'text': case 'varchar': case 'varchar2': $fixed = false; case 'char': $type[] = 'text'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } elseif (strstr($dbType, 'text')) { $type[] = 'clob'; } if ($fixed !== false) { $fixed = true; } break; case 'date': $type[] = 'date'; $length = null; break; case 'datetime': case 'timestamp': $type[] = 'timestamp'; $length = null; break; case 'time': $type[] = 'time'; $length = null; break; case 'float': case 'double': case 'real': $type[] = 'float'; $length = null; break; case 'decimal': case 'numeric': $type[] = 'decimal'; $length = null; break; case 'tinyblob': case 'mediumblob': case 'longblob': case 'blob': $type[] = 'blob'; $length = null; break; case 'year': $type[] = 'integer'; $type[] = 'date'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$dbType); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } public function getIntegerDeclaration($name, array $field) { $default = $autoinc = ''; $type = $this->getNativeDeclaration($field); if (isset($field['autoincrement']) && $field['autoincrement']) { $autoinc = ' PRIMARY KEY AUTOINCREMENT'; $type = 'INTEGER'; } elseif (array_key_exists('default', $field)) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : 0; } $default = ' DEFAULT ' . $this->conn->quote($field['default'], $field['type']); } $notnull = (isset($field['notnull']) && $field['notnull']) ? ' NOT NULL' : ''; $unsigned = (isset($field['unsigned']) && $field['unsigned']) ? ' UNSIGNED' : ''; $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $type . $unsigned . $default . $notnull . $autoinc; } } class Doctrine_DataDict extends Doctrine_Connection_Module { public function compareDefinition($current, $previous) { $type = !empty($current['type']) ? $current['type'] : null; if (!method_exists($this, "_compare{$type}Definition")) { throw new Doctrine_DataDict_Exception('type "'.$current['type'].'" is not yet supported'); } if (empty($previous['type']) || $previous['type'] != $type) { return $current; } $change = $this->{"_compare{$type}Definition"}($current, $previous); if ($previous['type'] != $type) { $change['type'] = true; } $previous_notnull = !empty($previous['notnull']) ? $previous['notnull'] : false; $notnull = !empty($current['notnull']) ? $current['notnull'] : false; if ($previous_notnull != $notnull) { $change['notnull'] = true; } $previous_default = array_key_exists('default', $previous) ? $previous['default'] : ($previous_notnull ? '' : null); $default = array_key_exists('default', $current) ? $current['default'] : ($notnull ? '' : null); if ($previous_default !== $default) { $change['default'] = true; } return $change; } public function parseBoolean($value) { if ($value == 'true') { $value = 1; } elseif ($value == 'false') { $value = 0; } return $value; } } class Doctrine_Db implements Countable, IteratorAggregate, Doctrine_Adapter_Interface { protected static $instances = array(); protected $isConnected = false; protected $dbh; protected $options = array('dsn' => null, 'username' => null, 'password' => null, ); protected $pendingAttributes = array(); protected $listener; protected $name; protected $count = 0; private static $driverMap = array('oracle' => 'oci8', 'postgres' => 'pgsql', 'oci' => 'oci8', 'sqlite2' => 'sqlite', 'sqlite3' => 'sqlite'); public function __construct($dsn, $user = null, $pass = null) { if ( ! isset($user) || strpos($dsn, '://')) { $a = self::parseDSN($dsn); extract($a); } else { $e = explode(':', $dsn); if($e[0] == 'uri') { $e[0] = 'odbc'; } $this->pendingAttributes[Doctrine::ATTR_DRIVER_NAME] = $e[0]; } $this->options['dsn'] = $dsn; $this->options['username'] = $user; $this->options['password'] = $pass; $this->listener = new Doctrine_Db_EventListener(); } public function incrementQueryCount() { $this->count++; } public function getDbh() { return $this->dbh; } public function getAdapter() { return $this->dbh; } public function setAdapter($adapter) { $this->dbh = $adapter; } public function setName($name) { $this->name = $name; } public function getName() { return $this->name; } public function getOption($name) { if ( ! array_key_exists($name, $this->options)) { throw new Doctrine_Db_Exception('Unknown option ' . $name); } return $this->options[$name]; } public function addListener($listener, $name = null) { if ( ! ($this->listener instanceof Doctrine_Db_EventListener_Chain)) { $this->listener = new Doctrine_Db_EventListener_Chain(); } $this->listener->add($listener, $name); return $this; } public function getListener() { return $this->listener; } public function setListener($listener) { if ( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_Db_Exception("Couldn't set eventlistener for database handler. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); } $this->listener = $listener; return $this; } public function connect() { if ($this->isConnected) return false; $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::CONNECT); $this->listener->onPreConnect($event); $e = explode(':', $this->options['dsn']); $found = false; if (extension_loaded('pdo')) { if (in_array($e[0], PDO::getAvailableDrivers())) { $this->dbh = new PDO($this->options['dsn'], $this->options['username'], $this->options['password']); $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $found = true; } } if ( ! $found) { $class = 'Doctrine_Adapter_' . ucwords($e[0]); if (class_exists($class)) { $this->dbh = new $class($this->options['dsn'], $this->options['username'], $this->options['password']); } else { throw new Doctrine_Db_Exception("Couldn't locate driver named " . $e[0]); } } foreach($this->pendingAttributes as $attr => $value) { if($attr == Doctrine::ATTR_DRIVER_NAME) { continue; } $this->dbh->setAttribute($attr, $value); } $this->isConnected = true; $this->listener->onConnect($event); return true; } public static function getConnection($dsn = null, $username = null, $password = null) { return new self($dsn, $username, $password); } public static function driverName($name) { if (isset(self::$driverMap[$name])) { return self::$driverMap[$name]; } return $name; } public function parseDSN($dsn) { $parts = @parse_url($dsn); $names = array('scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment'); foreach ($names as $name) { if ( ! isset($parts[$name])) { $parts[$name] = null; } } if (count($parts) == 0 || ! isset($parts['scheme'])) { throw new Doctrine_Db_Exception('Empty data source name'); } $drivers = self::getAvailableDrivers(); $parts['scheme'] = self::driverName($parts['scheme']); switch ($parts['scheme']) { case 'sqlite': if (isset($parts['host']) && $parts['host'] == ':memory') { $parts['database'] = ':memory:'; $parts['dsn'] = 'sqlite::memory:'; } break; case 'mysql': case 'informix': case 'oci8': case 'mssql': case 'firebird': case 'pgsql': case 'odbc': case 'mock': if ( ! isset($parts['path']) || $parts['path'] == '/') { throw new Doctrine_Db_Exception('No database availible in data source name'); } if (isset($parts['path'])) { $parts['database'] = substr($parts['path'], 1); } if ( ! isset($parts['host'])) { throw new Doctrine_Db_Exception('No hostname set in data source name'); } $parts['dsn'] = $parts["scheme"].":host=".$parts["host"].";dbname=".$parts["database"]; break; default: throw new Doctrine_Db_Exception('Unknown driver '.$parts['scheme']); } $this->pendingAttributes[PDO::ATTR_DRIVER_NAME] = $parts['scheme']; return $parts; } public static function clear() { self::$instances = array(); } public function errorCode() { return $this->dbh->errorCode(); } public function errorInfo() { return $this->dbh->errorInfo(); } public function prepare($statement) { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::PREPARE, $statement); $this->listener->onPrePrepare($event); $stmt = $this->dbh->prepare($statement); $this->listener->onPrepare($event); return new Doctrine_Db_Statement($this, $stmt); } public function query($statement, array $params = array()) { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::QUERY, $statement); $skip = $this->listener->onPreQuery($event); if ( ! empty($params)) { $stmt = $this->dbh->prepare($statement); return $stmt->execute($params); } else { if ( ! $skip) { $stmt = $this->dbh->query($statement); $this->count++; } else { $stmt = new stdClass; $stmt->queryString = $statement; } $stmt = new Doctrine_Db_Statement($this, $stmt); } $this->listener->onQuery($event); return $stmt; } public function quote($input) { $this->connect(); return $this->dbh->quote($input); } public function exec($statement) { $this->connect(); $args = func_get_args(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::EXEC, $statement); $this->listener->onPreExec($event); $rows = $this->dbh->exec($statement); $this->count++; $this->listener->onExec($event); return $rows; } public function lastInsertId() { $this->connect(); return $this->dbh->lastInsertId(); } public function beginTransaction() { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::BEGIN); $this->listener->onPreBeginTransaction($event); $return = $this->dbh->beginTransaction(); $this->listener->onBeginTransaction($event); return $return; } public function commit() { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::COMMIT); $this->listener->onPreCommit($event); $return = $this->dbh->commit(); $this->listener->onCommit($event); return $return; } public function rollBack() { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::ROLLBACK); $this->listener->onPreRollback($event); $this->dbh->rollBack(); $this->listener->onRollback($event); } public function getAttribute($attribute) { if ($this->isConnected) { return $this->dbh->getAttribute($attribute); } else { if ( ! isset($this->pendingAttributes[$attribute])) { throw new Doctrine_Db_Exception('Attribute ' . $attribute . ' not found.'); } return $this->pendingAttributes[$attribute]; } } public static function getAvailableDrivers() { return PDO::getAvailableDrivers(); } public function setAttribute($attribute, $value) { if ($this->isConnected) { $this->dbh->setAttribute($attribute, $value); } else { $this->pendingAttributes[$attribute] = $value; } } public function getIterator() { if ($this->listener instanceof Doctrine_Db_Profiler) { return $this->listener; } } public function count() { return $this->count; } } class Doctrine_Db_Event { const QUERY = 1; const EXEC = 2; const EXECUTE = 3; const PREPARE = 4; const BEGIN = 5; const COMMIT = 6; const ROLLBACK = 7; const CONNECT = 8; const FETCH = 9; const FETCHALL = 10; protected $invoker; protected $query; protected $params; protected $code; protected $startedMicrotime; protected $endedMicrotime; public function __construct($invoker, $code, $query = null, $params = array()) { $this->invoker = $invoker; $this->code = $code; $this->query = $query; $this->params = $params; } public function getQuery() { return $this->query; } public function getName() { switch ($this->code) { case self::QUERY: return 'query'; case self::EXEC: return 'exec'; case self::EXECUTE: return 'execute'; case self::PREPARE: return 'prepare'; case self::BEGIN: return 'begin'; case self::COMMIT: return 'commit'; case self::ROLLBACK: return 'rollback'; case self::CONNECT: return 'connect'; } } public function getCode() { return $this->code; } public function start() { $this->startedMicrotime = microtime(true); } public function hasEnded() { return ($this->endedMicrotime != null); } public function end() { $this->endedMicrotime = microtime(true); } public function getInvoker() { return $this->invoker; } public function getParams() { return $this->params; } public function getElapsedSecs() { if (is_null($this->endedMicrotime)) { return false; } return ($this->endedMicrotime - $this->startedMicrotime); } } class Doctrine_Db_EventListener_Chain extends Doctrine_Access implements Doctrine_Overloadable { private $listeners = array(); public function add($listener, $name = null) { if ( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_Db_Exception("Couldn't add eventlistener. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); } if ($name === null) { $this->listeners[] = $listener; } else { $this->listeners[$name] = $listener; } } public function get($name) { if ( ! isset($this->listeners[$name])) { throw new Doctrine_Db_Exception("Unknown listener $name"); } return $this->listeners[$name]; } public function set($name, $listener) { if ( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_Db_Exception("Couldn't set eventlistener. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); } $this->listeners[$name] = $listener; } public function __call($m, $a) { $return = null; foreach ($this->listeners as $listener) { $tmp = $listener->$m($a[0]); if ($tmp !== null) { $return = $tmp; } } return $return; } } interface Doctrine_Db_EventListener_Interface { public function onPreConnect(Doctrine_Db_Event $event); public function onConnect(Doctrine_Db_Event $event); public function onPreQuery(Doctrine_Db_Event $event); public function onQuery(Doctrine_Db_Event $event); public function onPrePrepare(Doctrine_Db_Event $event); public function onPrepare(Doctrine_Db_Event $event); public function onPreExec(Doctrine_Db_Event $event); public function onExec(Doctrine_Db_Event $event); public function onPreFetch(Doctrine_Db_Event $event); public function onFetch(Doctrine_Db_Event $event); public function onPreFetchAll(Doctrine_Db_Event $event); public function onFetchAll(Doctrine_Db_Event $event); public function onPreCommit(Doctrine_Db_Event $event); public function onCommit(Doctrine_Db_Event $event); public function onPreRollBack(Doctrine_Db_Event $event); public function onRollBack(Doctrine_Db_Event $event); public function onPreBeginTransaction(Doctrine_Db_Event $event); public function onBeginTransaction(Doctrine_Db_Event $event); public function onPreExecute(Doctrine_Db_Event $event); public function onExecute(Doctrine_Db_Event $event); } class Doctrine_Db_EventListener implements Doctrine_Db_EventListener_Interface { public function onPreConnect(Doctrine_Db_Event $event) { } public function onConnect(Doctrine_Db_Event $event) { } public function onPreQuery(Doctrine_Db_Event $event) { } public function onQuery(Doctrine_Db_Event $event) { } public function onPrePrepare(Doctrine_Db_Event $event) { } public function onPrepare(Doctrine_Db_Event $event) { } public function onPreCommit(Doctrine_Db_Event $event) { } public function onCommit(Doctrine_Db_Event $event) { } public function onPreExec(Doctrine_Db_Event $event) { } public function onExec(Doctrine_Db_Event $event) { } public function onPreFetch(Doctrine_Db_Event $event) { } public function onFetch(Doctrine_Db_Event $event) { } public function onPreFetchAll(Doctrine_Db_Event $event) { } public function onFetchAll(Doctrine_Db_Event $event) { } public function onPreRollBack(Doctrine_Db_Event $event) { } public function onRollBack(Doctrine_Db_Event $event) { } public function onPreBeginTransaction(Doctrine_Db_Event $event) { } public function onBeginTransaction(Doctrine_Db_Event $event) { } public function onPreExecute(Doctrine_Db_Event $event) { } public function onExecute(Doctrine_Db_Event $event) { } } class Doctrine_Db_Exception extends Doctrine_Exception { } class Doctrine_Db_Mock extends Doctrine_Db { protected static $errorCodeMap = array( 1004 => Doctrine::ERR_CANNOT_CREATE, 1005 => Doctrine::ERR_CANNOT_CREATE, 1006 => Doctrine::ERR_CANNOT_CREATE, 1007 => Doctrine::ERR_ALREADY_EXISTS, 1008 => Doctrine::ERR_CANNOT_DROP, 1022 => Doctrine::ERR_ALREADY_EXISTS, 1044 => Doctrine::ERR_ACCESS_VIOLATION, 1046 => Doctrine::ERR_NODBSELECTED, 1048 => Doctrine::ERR_CONSTRAINT, 1049 => Doctrine::ERR_NOSUCHDB, 1050 => Doctrine::ERR_ALREADY_EXISTS, 1051 => Doctrine::ERR_NOSUCHTABLE, 1054 => Doctrine::ERR_NOSUCHFIELD, 1061 => Doctrine::ERR_ALREADY_EXISTS, 1062 => Doctrine::ERR_ALREADY_EXISTS, 1064 => Doctrine::ERR_SYNTAX, 1091 => Doctrine::ERR_NOT_FOUND, 1100 => Doctrine::ERR_NOT_LOCKED, 1136 => Doctrine::ERR_VALUE_COUNT_ON_ROW, 1142 => Doctrine::ERR_ACCESS_VIOLATION, 1146 => Doctrine::ERR_NOSUCHTABLE, 1216 => Doctrine::ERR_CONSTRAINT, 1217 => Doctrine::ERR_CONSTRAINT, ); public function connect() { return true; } public function getAttribute($attribute) { if ($attribute == PDO::ATTR_DRIVER_NAME) { return 'mock'; } } } class Doctrine_Db_Profiler_Exception extends Doctrine_Db_Exception { } class Doctrine_Db_Profiler_Query { protected $query =''; protected $queryType = 0; protected $prepareTime; protected $startedMicrotime; protected $endedMicrotime; public function __construct($query, $prepareTime = null) { $this->query = $query; if ($prepareTime !== null) { $this->prepareTime = $prepareTime; } else { $this->startedMicrotime = microtime(true); } } public function start() { $this->startedMicrotime = microtime(true); } public function end() { $this->endedMicrotime = microtime(true); return true; } public function getPrepareTime() { return $this->prepareTime; } public function hasEnded() { return ($this->endedMicrotime != null); } public function getQuery() { return $this->query; } public function getQueryType() { return $this->queryType; } public function getElapsedSecs() { if (is_null($this->endedMicrotime) && ! $this->prepareTime) { return false; } return ($this->prepareTime + ($this->endedMicrotime - $this->startedMicrotime)); } } class Doctrine_Db_Profiler extends Doctrine_Access implements Doctrine_Overloadable, IteratorAggregate, Countable { private $listeners = array('query', 'prepare', 'commit', 'rollback', 'connect', 'begintransaction', 'exec', 'execute', ); private $events = array(); public function __construct() { } public function setFilterQueryType() { } public function __call($m, $a) { if ( ! ($a[0] instanceof Doctrine_Db_Event)) { throw new Doctrine_Db_Profiler_Exception("Couldn't listen event. Event should be an instance of Doctrine_Db_Event."); } if (substr($m, 0, 2) !== 'on') { throw new Doctrine_Db_Profiler_Exception("Couldn't invoke listener :" . $m); } if (substr($m, 2, 3) === 'Pre' && substr($m, 2, 7) !== 'Prepare') { if ( ! in_array(strtolower(substr($m, 5)), $this->listeners)) { throw new Doctrine_Db_Profiler_Exception("Couldn't invoke listener :" . $m); } $a[0]->start(); if( ! in_array($a[0], $this->events, true)) { $this->events[] = $a[0]; } } else { if ( ! in_array(strtolower(substr($m, 2)), $this->listeners)) { throw new Doctrine_Db_Profiler_Exception("Couldn't invoke listener :" . $m); } $a[0]->end(); } if ( ! is_null($this->filterTypes)) { if ( ! ($a[0]->getQueryType() & $this->_filterTypes)) { } } } public function get($key) { if (isset($this->events[$key])) { return $this->events[$key]; } return null; } public function getAll() { return $this->events; } public function getIterator() { return new ArrayIterator($this->events); } public function count() { return count($this->events); } public function pop() { return array_pop($this->events); } public function lastEvent() { if (empty($this->events)) { return false; } end($this->events); return current($this->events); } } class Doctrine_Db_Statement implements Doctrine_Adapter_Statement_Interface { protected $adapter; protected $stmt; protected $executed = false; public function __construct($adapter, $stmt) { $this->adapter = $adapter; $this->stmt = $stmt; } public function getDbh() { return $this->adapter; } public function getStatement() { return $this->stmt; } public function getQuery() { return $this->stmt->queryString; } public function bindColumn($column, $param, $type = null) { if($type === null) { return $this->stmt->bindColumn($column, $param); } else { return $this->stmt->bindColumn($column, $param, $type); } } public function bindValue($param, $value, $type = null) { if($type === null) { return $this->stmt->bindValue($param, $value); } else { return $this->stmt->bindValue($param, $value, $type); } } public function bindParam($column, $variable, $type = null, $length = null, $driverOptions = array()) { if($type === null) { return $this->stmt->bindParam($column, $variable); } else { return $this->stmt->bindParam($column, $variable, $type, $length, $driverOptions); } } public function closeCursor() { return $this->stmt->closeCursor(); } public function columnCount() { return $this->stmt->columnCount(); } public function errorCode() { return $this->stmt->errorCode(); } public function errorInfo() { return $this->stmt->errorInfo(); } public function execute($params = null) { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::EXECUTE, $this->stmt->queryString, $params); $skip = $this->adapter->getListener()->onPreExecute($event); if ( ! $skip) { $this->stmt->execute($params); $this->adapter->incrementQueryCount(); } $this->adapter->getListener()->onExecute($event); return $this; } public function fetch($fetchStyle = Doctrine::FETCH_BOTH, $cursorOrientation = Doctrine::FETCH_ORI_NEXT, $cursorOffset = null) { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::FETCHALL, $this->stmt->queryString, array($fetchStyle, $cursorOrientation, $cursorOffset)); $data = $this->adapter->getListener()->onPreFetch($event); if ($data === null) { $data = $this->stmt->fetch($fetchStyle, $cursorOrientation, $cursorOffset); } $this->adapter->getListener()->onFetch($event); return $data; } public function fetchAll($fetchStyle = Doctrine::FETCH_BOTH, $columnIndex = null) { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::FETCHALL, $this->stmt->queryString, array($fetchStyle, $columnIndex)); $data = $this->adapter->getListener()->onPreFetchAll($event); if ($data === null) { if ($columnIndex !== null) { $data = $this->stmt->fetchAll($fetchStyle, $columnIndex); } else { $data = $this->stmt->fetchAll($fetchStyle); } } $this->adapter->getListener()->onFetchAll($event); return $data; } public function fetchColumn($columnIndex = 0) { return $this->stmt->fetchColumn($columnIndex); } public function fetchObject($className = 'stdClass', $args = array()) { return $this->stmt->fetchObject($className, $args); } public function getAttribute($attribute) { return $this->stmt->getAttribute($attribute); } public function getColumnMeta($column) { return $this->stmt->getColumnMeta($column); } public function nextRowset() { return $this->stmt->nextRowset(); } public function rowCount() { return $this->stmt->rowCount(); } public function setAttribute($attribute, $value) { return $this->stmt->setAttribute($attribute, $value); } public function setFetchMode($mode, $arg1 = null, $arg2 = null) { return $this->stmt->setFetchMode($mode, $arg1, $arg2); } } interface Doctrine_EventListener_Interface { public function onLoad(Doctrine_Record $record); public function onPreLoad(Doctrine_Record $record); public function onUpdate(Doctrine_Record $record); public function onPreUpdate(Doctrine_Record $record); public function onCreate(Doctrine_Record $record); public function onPreCreate(Doctrine_Record $record); public function onSave(Doctrine_Record $record); public function onPreSave(Doctrine_Record $record); public function onGetProperty(Doctrine_Record $record, $property, $value); public function onSetProperty(Doctrine_Record $record, $property, $value); public function onInsert(Doctrine_Record $record); public function onPreInsert(Doctrine_Record $record); public function onDelete(Doctrine_Record $record); public function onPreDelete(Doctrine_Record $record); public function onEvict(Doctrine_Record $record); public function onPreEvict(Doctrine_Record $record); public function onSleep(Doctrine_Record $record); public function onWakeUp(Doctrine_Record $record); public function onClose(Doctrine_Connection $connection); public function onPreClose(Doctrine_Connection $connection); public function onOpen(Doctrine_Connection $connection); public function onTransactionCommit(Doctrine_Connection $connection); public function onPreTransactionCommit(Doctrine_Connection $connection); public function onTransactionRollback(Doctrine_Connection $connection); public function onPreTransactionRollback(Doctrine_Connection $connection); public function onTransactionBegin(Doctrine_Connection $connection); public function onPreTransactionBegin(Doctrine_Connection $connection); public function onCollectionDelete(Doctrine_Collection $collection); public function onPreCollectionDelete(Doctrine_Collection $collection); } class Doctrine_EventListener implements Doctrine_EventListener_Interface { public function onLoad(Doctrine_Record $record) { } public function onPreLoad(Doctrine_Record $record) { } public function onSleep(Doctrine_Record $record) { } public function onWakeUp(Doctrine_Record $record) { } public function onUpdate(Doctrine_Record $record) { } public function onPreUpdate(Doctrine_Record $record) { } public function onCreate(Doctrine_Record $record) { } public function onPreCreate(Doctrine_Record $record) { } public function onSave(Doctrine_Record $record) { } public function onPreSave(Doctrine_Record $record) { } public function onGetProperty(Doctrine_Record $record, $property, $value) { return $value; } public function onSetProperty(Doctrine_Record $record, $property, $value) { return $value; } public function onInsert(Doctrine_Record $record) { } public function onPreInsert(Doctrine_Record $record) { } public function onDelete(Doctrine_Record $record) { } public function onPreDelete(Doctrine_Record $record) { } public function onEvict(Doctrine_Record $record) { } public function onPreEvict(Doctrine_Record $record) { } public function onClose(Doctrine_Connection $connection) { } public function onPreClose(Doctrine_Connection $connection) { } public function onOpen(Doctrine_Connection $connection) { } public function onTransactionCommit(Doctrine_Connection $connection) { } public function onPreTransactionCommit(Doctrine_Connection $connection) { } public function onTransactionRollback(Doctrine_Connection $connection) { } public function onPreTransactionRollback(Doctrine_Connection $connection) { } public function onTransactionBegin(Doctrine_Connection $connection) { } public function onPreTransactionBegin(Doctrine_Connection $connection) { } public function onCollectionDelete(Doctrine_Collection $collection) { } public function onPreCollectionDelete(Doctrine_Collection $collection) { } } class Doctrine_EventListener_AccessorInvoker extends Doctrine_EventListener { private $lockGetCall = false; private $lockSetCall = false; public function onGetProperty(Doctrine_Record $record, $property, $value) { $method = 'get' . ucwords($property); if (method_exists($record, $method) && ! $this->lockGetCall) { $this->lockGetCall = true; $value = $record->$method($value); $this->lockGetCall = false; return $value; } return $value; } public function onSetProperty(Doctrine_Record $record, $property, $value) { $method = 'set' . ucwords($property); if (method_exists($record, $method) && ! $this->lockSetCall) { $this->lockSetCall = true; $value = $record->$method($value); $this->lockSetCall = false; return $value; } return $value; } } class Doctrine_EventListener_Chain extends Doctrine_Access implements Doctrine_EventListener_Interface { private $listeners = array(); public function add(Doctrine_EventListener $listener) { $this->listeners[] = $listener; } public function get($key) { if ( ! isset($this->listeners[$key])) { return null; } return $this->listeners[$key]; } public function set($key, Doctrine_EventListener $listener) { $this->listeners[$key] = $listener; } public function onLoad(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onLoad($record); } } public function onPreLoad(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreLoad($record); } } public function onSleep(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onSleep($record); } } public function onWakeUp(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onWakeUp($record); } } public function onUpdate(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onUpdate($record); } } public function onPreUpdate(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreUpdate($record); } } public function onCreate(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onCreate($record); } } public function onPreCreate(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreCreate($record); } } public function onSave(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onSave($record); } } public function onPreSave(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreSave($record); } } public function onGetProperty(Doctrine_Record $record, $property, $value) { foreach ($this->listeners as $listener) { $value = $listener->onGetProperty($record, $property, $value); } return $value; } public function onSetProperty(Doctrine_Record $record, $property, $value) { foreach ($this->listeners as $listener) { $value = $listener->onSetProperty($record, $property, $value); } return $value; } public function onInsert(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onInsert($record); } } public function onPreInsert(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreInsert($record); } } public function onDelete(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onDelete($record); } } public function onPreDelete(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreDelete($record); } } public function onEvict(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onEvict($record); } } public function onPreEvict(Doctrine_Record $record) { foreach ($this->listeners as $listener) { $listener->onPreEvict($record); } } public function onClose(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onClose($connection); } } public function onPreClose(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onPreClose($connection); } } public function onOpen(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onOpen($connection); } } public function onTransactionCommit(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onTransactionCommit($connection); } } public function onPreTransactionCommit(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onPreTransactionCommit($connection); } } public function onTransactionRollback(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onTransactionRollback($connection); } } public function onPreTransactionRollback(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onPreTransactionRollback($connection); } } public function onTransactionBegin(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onTransactionBegin($connection); } } public function onPreTransactionBegin(Doctrine_Connection $connection) { foreach ($this->listeners as $listener) { $listener->onPreTransactionBegin($connection); } } public function onCollectionDelete(Doctrine_Collection $collection) { foreach ($this->listeners as $listener) { $listener->onCollectionDelete($collection); } } public function onPreCollectionDelete(Doctrine_Collection $collection) { foreach ($this->listeners as $listener) { $listener->onPreCollectionDelete($collection); } } } class Doctrine_EventListener_Debugger extends Doctrine_EventListener { const EVENT_LOAD = 1; const EVENT_PRELOAD = 2; const EVENT_SLEEP = 3; const EVENT_WAKEUP = 4; const EVENT_UPDATE = 5; const EVENT_PREUPDATE = 6; const EVENT_CREATE = 7; const EVENT_PRECREATE = 8; const EVENT_SAVE = 9; const EVENT_PRESAVE = 10; const EVENT_INSERT = 11; const EVENT_PREINSERT = 12; const EVENT_DELETE = 13; const EVENT_PREDELETE = 14; const EVENT_EVICT = 15; const EVENT_PREEVICT = 16; const EVENT_CLOSE = 17; const EVENT_PRECLOSE = 18; const EVENT_OPEN = 19; const EVENT_COMMIT = 20; const EVENT_PRECOMMIT = 21; const EVENT_ROLLBACK = 22; const EVENT_PREROLLBACK = 23; const EVENT_BEGIN = 24; const EVENT_PREBEGIN = 25; const EVENT_COLLDELETE = 26; const EVENT_PRECOLLDELETE = 27; private $debug; public function getMessages() { return $this->debug; } public function onLoad(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_LOAD); } public function onPreLoad(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PRELOAD); } public function onSleep(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_SLEEP); } public function onWakeUp(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_WAKEUP); } public function onUpdate(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_UPDATE); } public function onPreUpdate(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PREUPDATE); } public function onCreate(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_CREATE); } public function onPreCreate(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PRECREATE); } public function onSave(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_SAVE); } public function onPreSave(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PRESAVE); } public function onInsert(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_INSERT); } public function onPreInsert(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PREINSERT); } public function onDelete(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_DELETE); } public function onPreDelete(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PREDELETE); } public function onEvict(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_EVICT); } public function onPreEvict(Doctrine_Record $record) { $this->debug[] = new Doctrine_DebugMessage($record,self::EVENT_PREEVICT); } public function onClose(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_CLOSE); } public function onPreClose(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_PRECLOSE); } public function onOpen(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_OPEN); } public function onTransactionCommit(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_COMMIT); } public function onPreTransactionCommit(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_PRECOMMIT); } public function onTransactionRollback(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_ROLLBACK); } public function onPreTransactionRollback(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_PREROLLBACK); } public function onTransactionBegin(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_BEGIN); } public function onPreTransactionBegin(Doctrine_Connection $connection) { $this->debug[] = new Doctrine_DebugMessage($connection,self::EVENT_PREBEGIN); } public function onCollectionDelete(Doctrine_Collection $collection) { $this->debug[] = new Doctrine_DebugMessage($collection,self::EVENT_COLLDELETE); } public function onPreCollectionDelete(Doctrine_Collection $collection) { $this->debug[] = new Doctrine_DebugMessage($collection,self::EVENT_PRECOLLDELETE); } } class Doctrine_EventListener_Empty extends Doctrine_EventListener { } class Doctrine_Exception extends Exception { } class Doctrine_Export extends Doctrine_Connection_Module { public function dropDatabase($database) { throw new Doctrine_Export_Exception('Drop database not supported by this driver.'); } public function dropTable($table) { $this->conn->execute('DROP TABLE ' . $table); } public function dropIndex($table, $name) { $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); return $this->conn->exec('DROP INDEX ' . $name); } public function dropConstraint($table, $name, $primary = false) { $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); return $this->conn->exec('ALTER TABLE ' . $table . ' DROP CONSTRAINT ' . $name); } public function dropSequence($name) { throw new Doctrine_Export_Exception('Drop sequence not supported by this driver.'); } public function createDatabase($database) { throw new Doctrine_Export_Exception('Create database not supported by this driver.'); } public function createTableSql($name, array $fields, array $options = array()) { if ( ! $name) { throw new Doctrine_Export_Exception('no valid table name specified'); } if (empty($fields)) { throw new Doctrine_Export_Exception('no fields specified for table '.$name); } $queryFields = $this->getFieldDeclarationList($fields); if (isset($options['primary']) && ! empty($options['primary'])) { $queryFields .= ', PRIMARY KEY(' . implode(', ', array_values($options['primary'])) . ')'; } if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach($options['indexes'] as $index => $definition) { $queryFields .= ', ' . $this->getIndexDeclaration($index, $definition); } } $name = $this->conn->quoteIdentifier($name, true); $query = 'CREATE TABLE ' . $name . ' (' . $queryFields . ')'; return $query; } public function createTable($name, array $fields, array $options = array()) { return $this->conn->execute($this->createTableSql($name, $fields, $options)); } public function createSequence($seqName, $start = 1) { return $this->conn->execute($this->createSequenceSql($seqName, $start = 1)); } public function createSequenceSql($seqName, $start = 1) { throw new Doctrine_Export_Exception('Create sequence not supported by this driver.'); } public function createConstraint($table, $name, $definition) { $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); $query = 'ALTER TABLE ' . $table . ' ADD CONSTRAINT ' . $name; if (!empty($definition['primary'])) { $query .= ' PRIMARY KEY'; } elseif (!empty($definition['unique'])) { $query .= ' UNIQUE'; } $fields = array(); foreach (array_keys($definition['fields']) as $field) { $fields[] = $this->conn->quoteIdentifier($field, true); } $query .= ' ('. implode(', ', $fields) . ')'; return $this->conn->exec($query); } public function createIndex($table, $name, array $definition) { return $this->conn->execute($this->createIndexSql($table, $name, $definition)); } public function createIndexSql($table, $name, array $definition) { $table = $this->conn->quoteIdentifier($table); $name = $this->conn->quoteIdentifier($name); $type = ''; if(isset($definition['type'])) { switch (strtolower($definition['type'])) { case 'unique': $type = strtoupper($definition['type']) . ' '; break; default: throw new Doctrine_Export_Exception('Unknown index type ' . $definition['type']); } } $query = 'CREATE ' . $type . 'INDEX ' . $name . ' ON ' . $table; $fields = array(); foreach (array_keys($definition['fields']) as $field) { $fields[] = $this->conn->quoteIdentifier($field); } $query .= ' (' . implode(', ', $fields) . ')'; return $query; } public function createForeignKey($table, $name, array $definition) { } public function alterTable($name, array $changes, $check) { $this->conn->execute($this->alterTableSql($name, $changes, $check)); } public function alterTableSql($name, array $changes, $check) { throw new Doctrine_Export_Exception('Alter table not supported by this driver.'); } public function getFieldDeclarationList(array $fields) { foreach ($fields as $fieldName => $field) { $query = $this->getDeclaration($fieldName, $field); $queryFields[] = $query; } return implode(', ', $queryFields); } public function getDeclaration($name, array $field) { $default = $this->getDefaultFieldDeclaration($field); $charset = (isset($field['charset']) && $field['charset']) ? ' ' . $this->getCharsetFieldDeclaration($field['charset']) : ''; $collation = (isset($field['collation']) && $field['collation']) ? ' ' . $this->getCollationFieldDeclaration($field['collation']) : ''; $notnull = (isset($field['notnull']) && $field['notnull']) ? ' NOT NULL' : ''; $unique = (isset($field['unique']) && $field['unique']) ? ' ' . $this->getUniqueFieldDeclaration() : ''; $method = 'get' . $field['type'] . 'Declaration'; if (method_exists($this->conn->dataDict, $method)) { return $this->conn->dataDict->$method($name, $field); } else { $dec = $this->conn->dataDict->getNativeDeclaration($field); } return $this->conn->quoteIdentifier($name, true) . ' ' . $dec . $charset . $default . $notnull . $unique . $collation; } public function getDefaultFieldDeclaration($field) { $default = ''; if (isset($field['default'])) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : $this->valid_default_values[$field['type']]; if ($field['default'] === '' && ($conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_EMPTY_TO_NULL) ) { $field['default'] = ' '; } } $default = ' DEFAULT ' . $this->conn->quote($field['default'], $field['type']); } return $default; } public function getIndexDeclaration($name, array $definition) { $name = $this->conn->quoteIdentifier($name); $type = ''; if (isset($definition['type'])) { if (strtolower($definition['type']) == 'unique') { $type = strtoupper($definition['type']) . ' '; } else { throw new Doctrine_Export_Exception('Unknown index type ' . $definition['type']); } } if ( ! isset($definition['fields']) || ! is_array($definition['fields'])) { throw new Doctrine_Export_Exception('No index columns given.'); } $query = $type . 'INDEX ' . $name; $query .= ' (' . $this->getIndexFieldDeclarationList($definition['fields']) . ')'; return $query; } public function getIndexFieldDeclarationList(array $fields) { $ret = array(); foreach ($fields as $field => $definition) { if(is_array($definition)) { $ret[] = $this->conn->quoteIdentifier($field); } else { $ret[] = $this->conn->quoteIdentifier($definition); } } return implode(', ', $ret); } public function getForeignKeyDeclaration(array $definition) { $sql = $this->getForeignKeyBaseDeclaration($definition); if (isset($definition['deferred'])) { $sql .= ' ' . $this->getForeignKeyDeferredDeclaration(); } $a = array('onUpdate', 'onDelete'); foreach($a as $v) { $keyword = ($v == 'onUpdate') ? ' ON UPDATE ' : ' ON DELETE '; if (isset($definition[$v])) { switch ($definition[$v]) { case 'CASCADE': case 'SET NULL': case 'NO ACTION': case 'RESTRICT': case 'SET DEFAULT': $sql .= $keyword . $definition[$v]; break; default: throw new Doctrine_Export_Exception('Unknown foreign key referential action option given.'); } } } return $sql; } public function getForeignKeyDeferredDeclaration($deferred) { return ''; } public function getForeignKeyBaseDeclaration(array $definition) { $sql = ''; if (isset($definition['name'])) { $sql .= 'CONSTRAINT ' . $definition['name'] . ' '; } $sql .= 'FOREIGN KEY '; if ( ! isset($definition['local'])) { throw new Doctrine_Export_Exception('Local reference field missing from definition.'); } if ( ! isset($definition['foreign'])) { throw new Doctrine_Export_Exception('Foreign reference field missing from definition.'); } if ( ! isset($definition['foreignTable'])) { throw new Doctrine_Export_Exception('Foreign reference table missing from definition.'); } if ( ! is_array($definition['local'])) { $definition['local'] = array($definition['local']); } if ( ! is_array($definition['foreign'])) { $definition['foreign'] = array($definition['foreign']); } $sql .= implode(', ', array_map(array($this->conn, 'quoteIdentifier'), $definition['local'])) . ' REFERENCES ' . $definition['foreignTable'] . '(' . implode(', ', array_map(array($this->conn, 'quoteIdentifier'), $definition['foreign'])) . ')'; return $sql; } public function getUniqueFieldDeclaration() { return 'UNIQUE'; } public function getCharsetFieldDeclaration($charset) { return ''; } public function getCollationFieldDeclaration($collation) { return ''; } public static function exportAll() { $parent = new ReflectionClass('Doctrine_Record'); $conn = Doctrine_Manager::getInstance()->getCurrentConnection(); $old = $conn->getAttribute(Doctrine::ATTR_CREATE_TABLES); $conn->setAttribute(Doctrine::ATTR_CREATE_TABLES, true); foreach (get_declared_classes() as $name) { $class = new ReflectionClass($name); if ($class->isSubclassOf($parent) && ! $class->isAbstract()) { $obj = new $class(); } } $conn->setAttribute(Doctrine::ATTR_CREATE_TABLES, $old); } public function export($record) { if ( ! $record instanceof Doctrine_Record) $record = new $record(); $table = $record->getTable(); $reporter = new Doctrine_Reporter(); if ( ! Doctrine::isValidClassname($table->getComponentName())) { $reporter->add(E_WARNING, 'Badly named class.'); } try { $columns = array(); foreach ($table->getColumns() as $name => $column) { $definition = $column[2]; $definition['type'] = $column[0]; $definition['length'] = $column[1]; if ($definition['type'] == 'enum' && isset($definition['default'])) { $definition['default'] = $table->enumIndex($name, $definition['default']); } if ($definition['type'] == 'boolean' && isset($definition['default'])) { $definition['default'] = (int) $definition['default']; } $columns[$name] = $definition; } $this->createTable($table->getTableName(), $columns); } catch(Doctrine_Connection_Exception $e) { $reporter->add(E_ERROR, $e->getMessage()); } return $reporter; } } class Doctrine_Export_Exception extends Doctrine_Exception { } class Doctrine_Export_Firebird extends Doctrine_Export { public function createDatabase($name) { throw new Doctrine_Export_Exception( 'PHP Interbase API does not support direct queries. You have to ' . 'create the db manually by using isql command or a similar program'); } public function dropDatabase($name) { throw new Doctrine_Export_Exception( 'PHP Interbase API does not support direct queries. You have ' . 'to drop the db manually by using isql command or a similar program'); } public function _makeAutoincrement($name, $table, $start = null) { if (is_null($start)) { $this->conn->beginTransaction(); $query = 'SELECT MAX(' . $this->conn->quoteIdentifier($name, true) . ') FROM ' . $this->conn->quoteIdentifier($table, true); $start = $this->conn->fetchOne($query, 'integer'); ++$start; $result = $this->createSequence($table, $start); $this->conn->commit(); } else { $result = $this->createSequence($table, $start); } $sequence_name = $this->conn->getSequenceName($table); $trigger_name = $this->conn->quoteIdentifier($table . '_AUTOINCREMENT_PK', true); $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($name, true); $triggerSql = 'CREATE TRIGGER ' . $trigger_name . ' FOR ' . $table . '
                        ACTIVE BEFORE INSERT POSITION 0
                        AS
                        BEGIN
                        IF (NEW.' . $name . ' IS NULL OR NEW.' . $name . ' = 0) THEN
                            NEW.' . $name . ' = GEN_ID('.$sequence_name.', 1);
                        END'; $result = $this->conn->exec($triggerSql); return $result; } public function _dropAutoincrement($table) { $result = $this->dropSequence($table); $table = $this->conn->quote(strtoupper($table)); $triggerName = $this->conn->quote(strtoupper($table) . '_AUTOINCREMENT_PK'); return $this->conn->exec("DELETE FROM RDB\$TRIGGERS WHERE UPPER(RDB\$RELATION_NAME)=" . $table . " AND UPPER(RDB\$TRIGGER_NAME)=" . $triggerName); } public function createTable($name, $fields, $options = array()) { parent::createTable($name, $fields, $options); foreach ($fields as $field_name => $field) { if ( ! empty($field['autoincrement'])) { $pk_definition = array( 'fields' => array($field_name => array()), 'primary' => true, ); $pk_name = null; $result = $this->createConstraint($name, $pk_name, $pk_definition); return $this->_makeAutoincrement($field_name, $name, 1); } } } public function checkSupportedChanges(&$changes) { foreach ($changes as $change_name => $change) { switch ($change_name) { case 'notnull': throw new Doctrine_DataDict_Exception('it is not supported changes to field not null constraint'); case 'default': throw new Doctrine_DataDict_Exception('it is not supported changes to field default value'); case 'length': case 'unsigned': case 'type': case 'declaration': case 'definition': break; default: throw new Doctrine_DataDict_Exception('it is not supported change of type' . $change_name); } } return true; } public function dropTable($name) { $result = $this->_dropAutoincrement($name); $result = parent::dropTable($name); return $result; } public function alterTable($name, $changes, $check) { foreach ($changes as $change_name => $change) { switch ($change_name) { case 'add': case 'remove': case 'rename': break; case 'change': foreach ($changes['change'] as $field) { $this->checkSupportedChanges($field); } break; default: throw new Doctrine_DataDict_Exception('change type ' . $change_name . ' not yet supported'); } } if ($check) { return true; } $query = ''; if (!empty($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $field_name => $field) { if ($query) { $query.= ', '; } $query.= 'ADD ' . $this->getDeclaration($field['type'], $field_name, $field, $name); } } if (!empty($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $field_name => $field) { if ($query) { $query.= ', '; } $field_name = $this->conn->quoteIdentifier($field_name, true); $query.= 'DROP ' . $field_name; } } if (!empty($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $field_name => $field) { if ($query) { $query.= ', '; } $field_name = $this->conn->quoteIdentifier($field_name, true); $query.= 'ALTER ' . $field_name . ' TO ' . $this->conn->quoteIdentifier($field['name'], true); } } if (!empty($changes['change']) && is_array($changes['change'])) { foreach ($changes['change'] as $field_name => $field) { $this->checkSupportedChanges($field); if ($query) { $query.= ', '; } $this->conn->loadModule('Datatype', null, true); $field_name = $this->conn->quoteIdentifier($field_name, true); $query.= 'ALTER ' . $field_name.' TYPE ' . $this->getTypeDeclaration($field['definition']); } } if (!strlen($query)) { return false; } $name = $this->conn->quoteIdentifier($name, true); $result = $this->conn->exec("ALTER TABLE $name $query"); $this->_silentCommit(); return $result; } public function createIndex($table, $name, array $definition) { $query = 'CREATE'; $query_sort = ''; foreach ($definition['fields'] as $field) { if (!strcmp($query_sort, '') && isset($field['sorting'])) { switch ($field['sorting']) { case 'ascending': $query_sort = ' ASC'; break; case 'descending': $query_sort = ' DESC'; break; } } } $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); $query .= $query_sort. ' INDEX ' . $name . ' ON ' . $table; $fields = array(); foreach (array_keys($definition['fields']) as $field) { $fields[] = $this->conn->quoteIdentifier($field, true); } $query .= ' ('.implode(', ', $fields) . ')'; $result = $this->conn->exec($query); return $result; } public function createConstraint($table, $name, $definition) { $table = $this->conn->quoteIdentifier($table, true); if (!empty($name)) { $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); } $query = "ALTER TABLE $table ADD"; if (!empty($definition['primary'])) { if (!empty($name)) { $query.= ' CONSTRAINT '.$name; } $query.= ' PRIMARY KEY'; } else { $query.= ' CONSTRAINT '. $name; if (!empty($definition['unique'])) { $query.= ' UNIQUE'; } } $fields = array(); foreach (array_keys($definition['fields']) as $field) { $fields[] = $this->conn->quoteIdentifier($field, true); } $query .= ' ('. implode(', ', $fields) . ')'; $result = $this->conn->exec($query); return $result; } public function createSequence($seqName, $start = 1) { $sequenceName = $this->conn->getSequenceName($seqName); $this->conn->exec('CREATE GENERATOR ' . $sequenceName); $this->conn->exec('SET GENERATOR ' . $sequenceName . ' TO ' . ($start-1)); $this->dropSequence($seqName); } public function dropSequence($seqName) { $sequenceName = $this->conn->getSequenceName($seqName); $sequenceName = $this->conn->quote($sequenceName); $query = "DELETE FROM RDB\$GENERATORS WHERE UPPER(RDB\$GENERATOR_NAME)=" . $sequenceName; return $this->conn->exec($query); } } class Doctrine_Export_Mssql extends Doctrine_Export { public function createDatabase($name) { $name = $this->conn->quoteIdentifier($name, true); $query = "CREATE DATABASE $name"; if ($this->conn->options['database_device']) { $query.= ' ON '.$this->conn->options['database_device']; $query.= $this->conn->options['database_size'] ? '=' . $this->conn->options['database_size'] : ''; } return $this->conn->standaloneQuery($query, null, true); } public function dropDatabase($name) { $name = $this->conn->quoteIdentifier($name, true); return $this->conn->standaloneQuery("DROP DATABASE $name", null, true); } public function alterTable($name, $changes, $check) { foreach ($changes as $change_name => $change) { switch ($change_name) { case 'add': break; case 'remove': break; case 'name': case 'rename': case 'change': default: throw new Doctrine_Export_Exception('alterTable: change type "' . $change_name . '" not yet supported'); } } $query = ''; if (!empty($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $field_name => $field) { if ($query) { $query.= ', '; } $query.= 'ADD ' . $this->conn->getDeclaration($field['type'], $field_name, $field); } } if (!empty($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $field_name => $field) { if ($query) { $query.= ', '; } $field_name = $this->conn->quoteIdentifier($field_name, true); $query.= 'DROP COLUMN ' . $field_name; } } if (!$query) { return false; } $name = $this->conn->quoteIdentifier($name, true); return $this->conn->exec("ALTER TABLE $name $query"); } public function createSequence($seq_name, $start = 1) { $sequence_name = $this->conn->quoteIdentifier($this->conn->getSequenceName($seq_name), true); $seqcol_name = $this->conn->quoteIdentifier($this->conn->options['seqcol_name'], true); $query = "CREATE TABLE $sequence_name ($seqcol_name " . "INT PRIMARY KEY CLUSTERED IDENTITY($start,1) NOT NULL)"; $res = $this->conn->exec($query); if ($start == 1) { return true; } try { $query = 'SET IDENTITY_INSERT $sequence_name ON ' . 'INSERT INTO $sequence_name (' . $seqcol_name . ') VALUES ( ' . $start . ')'; $res = $this->conn->exec($query); } catch (Exception $e) { $result = $this->conn->exec("DROP TABLE $sequence_name"); } return true; } public function dropSequence($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return $this->conn->exec('DROP TABLE ' . $sequenceName); } } class Doctrine_Export_Mysql extends Doctrine_Export { public function createDatabase($name) { $query = 'CREATE DATABASE ' . $this->conn->quoteIdentifier($name, true); $result = $this->conn->exec($query); } public function dropDatabase($name) { $query = 'DROP DATABASE ' . $this->conn->quoteIdentifier($name); $this->conn->exec($query); } public function createTableSql($name, array $fields, array $options = array()) { if ( ! $name) throw new Doctrine_Export_Exception('no valid table name specified'); if (empty($fields)) { throw new Doctrine_Export_Exception('no fields specified for table "'.$name.'"'); } $queryFields = $this->getFieldDeclarationList($fields); if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach($options['indexes'] as $index => $definition) { $queryFields .= ', ' . $this->getIndexDeclaration($index, $definition); } } if (isset($options['foreignKeys']) && ! empty($options['foreignKeys'])) { foreach($options['foreignKeys'] as $definition) { $queryFields .= ', ' . $this->getForeignKeyDeclaration($definition); } } if (isset($options['primary']) && ! empty($options['primary'])) { $queryFields .= ', PRIMARY KEY(' . implode(', ', array_values($options['primary'])) . ')'; } $name = $this->conn->quoteIdentifier($name, true); $query = 'CREATE TABLE ' . $name . ' (' . $queryFields . ')'; $optionStrings = array(); if (isset($options['comment'])) { $optionStrings['comment'] = 'COMMENT = ' . $this->dbh->quote($options['comment'], 'text'); } if (isset($options['charset'])) { $optionStrings['charset'] = 'DEFAULT CHARACTER SET ' . $options['charset']; if (isset($options['collate'])) { $optionStrings['charset'].= ' COLLATE ' . $options['collate']; } } $type = false; if (!empty($options['type'])) { $type = $options['type']; } else { $type = $this->conn->getAttribute(Doctrine::ATTR_DEFAULT_TABLE_TYPE); } if ($type) { $optionStrings[] = 'ENGINE = ' . $type; } if (!empty($optionStrings)) { $query.= ' '.implode(' ', $optionStrings); } return $query; } public function alterTableSql($name, array $changes, $check) { if ( ! $name) throw new Doctrine_Export_Exception('no valid table name specified'); foreach ($changes as $changeName => $change) { switch ($changeName) { case 'add': case 'remove': case 'change': case 'rename': case 'name': break; default: throw new Doctrine_Export_Exception('change type "'.$changeName.'" not yet supported'); } } if ($check) { return true; } $query = ''; if ( ! empty($changes['name'])) { $change_name = $this->conn->quoteIdentifier($changes['name'], true); $query .= 'RENAME TO ' . $change_name; } if ( ! empty($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $field_name => $field) { if ($query) { $query.= ', '; } $query.= 'ADD ' . $this->getDeclaration($field['type'], $field_name, $field); } } if ( ! empty($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $field_name => $field) { if ($query) { $query.= ', '; } $field_name = $this->conn->quoteIdentifier($field_name, true); $query.= 'DROP ' . $field_name; } } $rename = array(); if ( ! empty($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $field_name => $field) { $rename[$field['name']] = $field_name; } } if ( ! empty($changes['change']) && is_array($changes['change'])) { foreach ($changes['change'] as $fieldName => $field) { if ($query) { $query.= ', '; } if (isset($rename[$fieldName])) { $oldFieldName = $rename[$fieldName]; unset($rename[$fieldName]); } else { $oldFieldName = $fieldName; } $oldFieldName = $this->conn->quoteIdentifier($old_field_name, true); $query .= "CHANGE $oldFieldName " . $this->getDeclaration($field['definition']['type'], $fieldName, $field['definition']); } } if ( ! empty($rename) && is_array($rename)) { foreach ($rename as $rename_name => $renamed_field) { if ($query) { $query.= ', '; } $field = $changes['rename'][$renamed_field]; $renamed_field = $this->conn->quoteIdentifier($renamed_field, true); $query.= 'CHANGE ' . $renamed_field . ' ' . $this->getDeclaration($field['definition']['type'], $field['name'], $field['definition']); } } if ( ! $query) { return false; } $name = $this->conn->quoteIdentifier($name, true); return $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } public function createSequence($sequenceName, $start = 1) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($sequenceName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); try { $query = 'CREATE TABLE ' . $sequenceName . ' (' . $seqcolName . ' INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (' . $seqcolName . '))' . strlen($this->conn->default_table_type) ? ' TYPE = ' . $this->conn->default_table_type : ''; $res = $this->conn->exec($query); } catch(Doctrine_Connection_Exception $e) { throw new Doctrine_Export_Exception('could not create sequence table'); } if ($start == 1) return true; $query = 'INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (' . ($start - 1) . ')'; $res = $this->conn->exec($query); try { $result = $this->conn->exec('DROP TABLE ' . $sequenceName); } catch(Doctrine_Connection_Exception $e) { throw new Doctrine_Export_Exception('could not drop inconsistent sequence table'); } } public function createIndexSql($table, $name, array $definition) { $table = $table; $name = $this->conn->getIndexName($name); $type = ''; if(isset($definition['type'])) { switch (strtolower($definition['type'])) { case 'fulltext': case 'unique': $type = strtoupper($definition['type']) . ' '; break; default: throw new Doctrine_Export_Exception('Unknown index type ' . $definition['type']); } } $query = 'CREATE ' . $type . 'INDEX ' . $name . ' ON ' . $table; $query .= ' ('. $this->getIndexFieldDeclarationList() . ')'; return $query; } public function getDefaultFieldDeclaration($field) { $default = ''; if (isset($field['default']) && $field['length'] <= 255) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : $this->valid_default_values[$field['type']]; if ($field['default'] === '' && ($conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_EMPTY_TO_NULL) ) { $field['default'] = ' '; } } $default = ' DEFAULT ' . $this->conn->quote($field['default'], $field['type']); } return $default; } public function getIndexDeclaration($name, array $definition) { $name = $this->conn->quoteIdentifier($name); $type = ''; if(isset($definition['type'])) { switch (strtolower($definition['type'])) { case 'fulltext': case 'unique': $type = strtoupper($definition['type']) . ' '; break; default: throw new Doctrine_Export_Exception('Unknown index type ' . $definition['type']); } } if ( ! isset($definition['fields'])) { throw new Doctrine_Export_Exception('No index columns given.'); } if ( ! is_array($definition['fields'])) { $definition['fields'] = array($definition['fields']); } $query = $type . 'INDEX ' . $name; $query .= ' (' . $this->getIndexFieldDeclarationList($definition['fields']) . ')'; return $query; } public function getIndexFieldDeclarationList(array $fields) { $declFields = array(); foreach ($fields as $fieldName => $field) { $fieldString = $fieldName; if (is_array($field)) { if (isset($field['length'])) { $fieldString .= '(' . $field['length'] . ')'; } if (isset($field['sorting'])) { $sort = strtoupper($field['sorting']); switch ($sort) { case 'ASC': case 'DESC': $fieldString .= ' ' . $sort; break; default: throw new Doctrine_Export_Exception('Unknown index sorting option given.'); } } } else { $fieldString = $field; } $declFields[] = $fieldString; } return implode(', ', $declFields); } public function dropIndex($table, $name) { $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); return $this->conn->exec('DROP INDEX ' . $name . ' ON ' . $table); } public function dropTable($table) { $table = $this->conn->quoteIdentifier($table, true); $this->conn->exec('DROP TABLE ' . $table); } } class Doctrine_Export_Oracle extends Doctrine_Export { public function createDatabase($name) { if ( ! $this->conn->getAttribute(Doctrine::ATTR_EMULATE_DATABASE)) throw new Doctrine_Export_Exception('database creation is only supported if the "emulate_database" attribute is enabled'); $username = sprintf($this->conn->getAttribute(Doctrine::ATTR_DB_NAME_FORMAT), $name); $password = $this->conn->dsn['password'] ? $this->conn->dsn['password'] : $name; $tablespace = $this->conn->getAttribute(Doctrine::ATTR_DB_NAME_FORMAT) ? ' DEFAULT TABLESPACE '.$this->conn->options['default_tablespace'] : ''; $query = 'CREATE USER ' . $username . ' IDENTIFIED BY ' . $password . $tablespace; $result = $this->conn->exec($query); try { $query = 'GRANT CREATE SESSION, CREATE TABLE, UNLIMITED TABLESPACE, CREATE SEQUENCE, CREATE TRIGGER TO ' . $username; $result = $this->conn->exec($query); } catch (Exception $e) { $query = 'DROP USER '.$username.' CASCADE'; $result2 = $this->conn->exec($query); } return true; } public function dropDatabase($name) { if ( ! $this->conn->getAttribute(Doctrine::ATTR_EMULATE_DATABASE)) throw new Doctrine_Export_Exception('database dropping is only supported if the
                                                       "emulate_database" option is enabled'); $username = sprintf($this->conn->getAttribute(Doctrine::ATTR_DB_NAME_FORMAT), $name); return $this->conn->exec('DROP USER ' . $username . ' CASCADE'); } public function _makeAutoincrement($name, $table, $start = 1) { $table = strtoupper($table); $index_name = $table . '_AI_PK'; $definition = array( 'primary' => true, 'fields' => array($name => true), ); $result = $this->createConstraint($table, $index_name, $definition); if (is_null($start)) { $this->conn->beginTransaction(); $query = 'SELECT MAX(' . $this->conn->quoteIdentifier($name, true) . ') FROM ' . $this->conn->quoteIdentifier($table, true); $start = $this->conn->fetchOne($query); ++$start; $result = $this->createSequence($table, $start); $this->conn->commit(); } else { $result = $this->createSequence($table, $start); } $sequence_name = $this->conn->getSequenceName($table); $trigger_name = $this->conn->quoteIdentifier($table . '_AI_PK', true); $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($name, true); $trigger_sql = 'CREATE TRIGGER '.$trigger_name.'
   BEFORE INSERT
   ON '.$table.'
   FOR EACH ROW
DECLARE
   last_Sequence NUMBER;
   last_InsertID NUMBER;
BEGIN
   SELECT '.$sequence_name.'.NEXTVAL INTO :NEW.'.$name.' FROM DUAL;
   IF (:NEW.'.$name.' IS NULL OR :NEW.'.$name.' = 0) THEN
      SELECT '.$sequence_name.'.NEXTVAL INTO :NEW.'.$name.' FROM DUAL;
   ELSE
      SELECT NVL(Last_Number, 0) INTO last_Sequence
        FROM User_Sequences
       WHERE UPPER(Sequence_Name) = UPPER(\''.$sequence_name.'\');
      SELECT :NEW.id INTO last_InsertID FROM DUAL;
      WHILE (last_InsertID > last_Sequence) LOOP
         SELECT '.$sequence_name.'.NEXTVAL INTO last_Sequence FROM DUAL;
      END LOOP;
   END IF;
END;
'; return $this->conn->exec($trigger_sql); } public function dropAutoincrement($table) { $table = strtoupper($table); $triggerName = $table . '_AI_PK'; $trigger_name_quoted = $this->conn->quote($triggerName); $query = 'SELECT trigger_name FROM user_triggers'; $query.= ' WHERE trigger_name='.$trigger_name_quoted.' OR trigger_name='.strtoupper($trigger_name_quoted); $trigger = $this->conn->fetchOne($query); if ($trigger) { $trigger_name = $this->conn->quoteIdentifier($table . '_AI_PK', true); $trigger_sql = 'DROP TRIGGER ' . $trigger_name; $this->conn->exec($trigger_sql); $this->dropSequence($table); $indexName = $table . '_AI_PK'; $this->dropConstraint($table, $indexName); } } public function createTable($name, $fields, $options = array()) { $this->conn->beginTransaction(); $result = parent::createTable($name, $fields, $options); foreach ($fields as $field_name => $field) { if (isset($field['autoincrement']) && $field['autoincrement']) { $result = $this->_makeAutoincrement($field_name, $name); } } $this->conn->commit(); return $result; } public function dropTable($name) { $result = $this->dropAutoincrement($name); $result = parent::dropTable($name); return $result; } public function alterTable($name, array $changes, $check) { foreach ($changes as $changeName => $change) { switch ($changeName) { case 'add': case 'remove': case 'change': case 'name': case 'rename': break; default: throw new Doctrine_Export_Exception('change type "'.$changeName.'" not yet supported'); } } if ($check) { return false; } $name = $this->conn->quoteIdentifier($name, true); if (!empty($changes['add']) && is_array($changes['add'])) { $fields = array(); foreach ($changes['add'] as $field_name => $field) { $fields[] = $this->conn->getDeclaration($field['type'], $field_name, $field); } $result = $this->conn->exec("ALTER TABLE $name ADD (". implode(', ', $fields).')'); } if (!empty($changes['change']) && is_array($changes['change'])) { $fields = array(); foreach ($changes['change'] as $field_name => $field) { $fields[] = $field_name. ' ' . $this->conn->getDeclaration($field['definition']['type'], '', $field['definition']); } $result = $this->conn->exec("ALTER TABLE $name MODIFY (". implode(', ', $fields).')'); } if (!empty($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $field_name => $field) { $field_name = $this->conn->quoteIdentifier($field_name, true); $query = "ALTER TABLE $name RENAME COLUMN $field_name TO ".$this->conn->quoteIdentifier($field['name']); $result = $this->conn->exec($query); } } if (!empty($changes['remove']) && is_array($changes['remove'])) { $fields = array(); foreach ($changes['remove'] as $field_name => $field) { $fields[] = $this->conn->quoteIdentifier($field_name, true); } $result = $this->conn->exec("ALTER TABLE $name DROP COLUMN ". implode(', ', $fields)); } if (!empty($changes['name'])) { $change_name = $this->conn->quoteIdentifier($changes['name'], true); $result = $this->conn->exec("ALTER TABLE $name RENAME TO ".$change_name); } } public function getForeignKeyDeferredDeclaration($deferred) { return ($deferred) ? 'INITIALLY DEFERRED DEFERRABLE' : ''; } public function createSequence($seqName, $start = 1) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = 'CREATE SEQUENCE ' . $sequenceName . ' START WITH ' . $start . ' INCREMENT BY 1 NOCACHE'; $query.= ($start < 1 ? ' MINVALUE ' . $start : ''); return $this->conn->exec($query); } public function dropSequence($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return $this->conn->exec('DROP SEQUENCE ' . $sequenceName); } } class Doctrine_Export_Pgsql extends Doctrine_Export { public function createDatabase($name) { $query = 'CREATE DATABASE ' . $this->conn->quoteIdentifier($name); $this->conn->exec($query); } public function dropDatabase($name) { $query = 'DROP DATABASE ' . $this->conn->quoteIdentifier($name); $this->conn->exec($query); } public function alterTable($name, array $changes, $check) { foreach ($changes as $changeName => $change) { switch ($changeName) { case 'add': case 'remove': case 'change': case 'name': case 'rename': break; default: throw new Doctrine_Export_Exception('change type "' . $changeName . '\" not yet supported'); } } if ($check) { return true; } if (isset($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $field_name => $field) { $query = 'ADD ' . $this->conn->getDeclaration($field['type'], $field_name, $field); $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } } if (isset($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $field_name => $field) { $field_name = $this->conn->quoteIdentifier($field_name, true); $query = 'DROP ' . $field_name; $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } } if (isset($changes['change']) && is_array($changes['change'])) { foreach ($changes['change'] as $field_name => $field) { $fieldName = $this->conn->quoteIdentifier($field_name, true); if (isset($field['type'])) { $server_info = $this->conn->getServerVersion(); if (is_array($server_info) && $server_info['major'] < 8) { throw new Doctrine_Export_Exception('changing column type for "'.$field['type'].'\" requires PostgreSQL 8.0 or above'); } $query = "ALTER $field_name TYPE ".$this->conn->datatype->getTypeDeclaration($field['definition']); $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query);; } if (array_key_exists('default', $field)) { $query = "ALTER $field_name SET DEFAULT ".$this->conn->quote($field['definition']['default'], $field['definition']['type']); $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } if (!empty($field['notnull'])) { $query = "ALTER $field_name ".($field['definition']['notnull'] ? "SET" : "DROP").' NOT NULL'; $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } } } if (isset($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $fieldName => $field) { $field_name = $this->conn->quoteIdentifier($fieldName, true); $this->conn->exec('ALTER TABLE ' . $name . ' RENAME COLUMN ' . $fieldName . ' TO ' . $this->conn->quoteIdentifier($field['name'], true)); } } $name = $this->conn->quoteIdentifier($name, true); if (isset($changes['name'])) { $changeName = $this->conn->quoteIdentifier($changes['name'], true); $this->conn->exec('ALTER TABLE ' . $name . ' RENAME TO ' . $changeName); } } } class Doctrine_Export_Reporter implements IteratorAggregate { protected $messages = array(); public function add($code, $message) { $this->messages[] = array($code, $message); } public function pop() { return array_pop($this->messages); } public function getIterator() { return new ArrayIterator($this->messages); } } class Doctrine_Export_Sqlite extends Doctrine_Export { public function createIndexSql($table, $name, array $definition) { $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->getIndexName($name); $query = 'CREATE INDEX ' . $name . ' ON ' . $table; $query .= ' (' . $this->getIndexFieldDeclarationList($definition['fields']) . ')'; return $query; } public function getIndexFieldDeclarationList(array $fields) { $declFields = array(); foreach ($fields as $fieldName => $field) { $fieldString = $fieldName; if (is_array($field)) { if (isset($field['sorting'])) { $sort = strtoupper($field['sorting']); switch ($sort) { case 'ASC': case 'DESC': $fieldString .= ' ' . $sort; break; default: throw new Doctrine_Export_Exception('Unknown index sorting option given.'); } } } else { $fieldString = $field; } $declFields[] = $fieldString; } return implode(', ', $declFields); } public function createTable($name, array $fields, array $options = array()) { if ( ! $name) { throw new Doctrine_Export_Exception('no valid table name specified'); } if (empty($fields)) { throw new Doctrine_Export_Exception('no fields specified for table '.$name); } $queryFields = $this->getFieldDeclarationList($fields); $autoinc = false; foreach($fields as $field) { if(isset($field['autoincrement']) && $field['autoincrement']) { $autoinc = true; break; } } if ( ! $autoinc && isset($options['primary']) && ! empty($options['primary'])) { $queryFields.= ', PRIMARY KEY('.implode(', ', array_values($options['primary'])).')'; } if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach($options['indexes'] as $index => $definition) { $queryFields .= ', ' . $this->getIndexDeclaration($index, $definition); } } $name = $this->conn->quoteIdentifier($name, true); $query = 'CREATE TABLE ' . $name . ' (' . $queryFields . ')'; return $this->conn->exec($query); } public function createSequence($seqName, $start = 1) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'CREATE TABLE ' . $sequenceName . ' (' . $seqcolName . ' INTEGER PRIMARY KEY DEFAULT 0 NOT NULL)'; $this->conn->exec($query); if ($start == 1) { return true; } try { $this->conn->exec('INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (' . ($start-1) . ')'); return true; } catch(Doctrine_Connection_Exception $e) { try { $result = $db->exec('DROP TABLE ' . $sequenceName); } catch(Doctrine_Connection_Exception $e) { throw new Doctrine_Export_Exception('could not drop inconsistent sequence table'); } } throw new Doctrine_Export_Exception('could not create sequence table'); } public function dropSequence($seq_name) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seq_name), true); return $this->conn->exec('DROP TABLE ' . $sequenceName); } } class Doctrine_Expression extends Doctrine_Connection_Module { public function getIdentifier($column) { return $column; } public function getIdentifiers($columns) { return $columns; } public function regexp() { throw new Doctrine_Expression_Exception('Regular expression operator is not supported by this database driver.'); } public function avg($column) { $column = $this->getIdentifier($column); return 'AVG(' . $column . ')'; } public function count($column) { $column = $this->getIdentifier($column); return 'COUNT(' . $column . ')'; } public function max($column) { $column = $this->getIdentifier($column); return 'MAX(' . $column . ')'; } public function min($column) { $column = $this->getIdentifier($column); return 'MIN(' . $column . ')'; } public function sum($column) { $column = $this->getIdentifier($column); return 'SUM(' . $column . ')'; } public function md5($column) { $column = $this->getIdentifier($column); return 'MD5(' . $column . ')'; } public function length($column) { $column = $this->getIdentifier($column); return 'LENGTH(' . $column . ')'; } public function round($column, $decimals = 0) { $column = $this->getIdentifier($column); return 'ROUND(' . $column . ', ' . $decimals . ')'; } public function mod($expression1, $expression2) { $expression1 = $this->getIdentifier($expression1); $expression2 = $this->getIdentifier($expression2); return 'MOD(' . $expression1 . ', ' . $expression2 . ')'; } public function ltrim($str) { return 'LTRIM(' . $str . ')'; } public function upper($str) { return 'UPPER(' . $str . ')'; } public function lower($str) { return 'LOWER(' . $str . ')'; } public function locate($str, $substr) { return 'LOCATE(' . $str . ', ' . $substr . ')'; } public function now() { return 'NOW()'; } public function soundex($value) { throw new Doctrine_Expression_Exception('SQL soundex function not supported by this driver.'); } public function substring($value, $from, $len = null) { $value = $this->getIdentifier($value); if ($len === null) return 'SUBSTRING(' . $value . ' FROM ' . $from . ')'; else { $len = $this->getIdentifier($len); return 'SUBSTRING(' . $value . ' FROM ' . $from . ' FOR ' . $len . ')'; } } public function concat($args) { $cols = $this->getIdentifiers($args); return 'CONCAT(' . join(', ', (array) $cols) . ')'; } public function not($expression) { $expression = $this->getIdentifier($expression); return 'NOT(' . $expression . ')'; } private function basicMath($type, array $args) { $elements = $this->getIdentifiers($args); if (count($elements) < 1) { return ''; } if (count($elements) == 1) { return $elements[0]; } else { return '(' . implode(' ' . $type . ' ', $elements) . ')'; } } public function add(array $args) { return $this->basicMath('+', $args); } public function sub(array $args) { return $this->basicMath('-', $args ); } public function mul(array $args) { return $this->basicMath('*', $args); } public function div(array $args) { return $this->basicMath('/', $args); } public function eq($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' = ' . $value2; } public function neq($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' <> ' . $value2; } public function gt($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' > ' . $value2; } public function gte($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' >= ' . $value2; } public function lt($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' < ' . $value2; } public function lte($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' <= ' . $value2; } public function in($column, $values) { if ( ! is_array($values)) { $values = array($values); } $values = $this->getIdentifiers($values); $column = $this->getIdentifier($column); if (count($values) == 0) { throw new Doctrine_Expression_Exception('Values array for IN operator should not be empty.'); } return $column . ' IN (' . implode(', ', $values) . ')'; } public function isNull($expression) { $expression = $this->getIdentifier($expression); return $expression . ' IS NULL'; } public function isNotNull($expression) { $expression = $this->getIdentifier($expression); return $expression . ' IS NOT NULL'; } public function between($expression, $value1, $value2) { $expression = $this->getIdentifier($expression); $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $expression . ' BETWEEN ' .$value1 . ' AND ' . $value2; } } class Doctrine_Expression_Exception extends Doctrine_Exception { } class Doctrine_Expression_Firebird extends Doctrine_Expression { public function functionTable() { return ' FROM RDB$DATABASE'; } function patternEscapeString() { return " ESCAPE '". $this->conn->string_quoting['escape_pattern'] ."'"; } } class Doctrine_Expression_Informix extends Doctrine_Expression { } class Doctrine_Expression_Mssql extends Doctrine_Expression { public function now($type = 'timestamp') { switch ($type) { case 'time': case 'date': case 'timestamp': default: return 'GETDATE()'; } } public function substring($value, $position, $length = null) { if (!is_null($length)) { return "SUBSTRING($value, $position, $length)"; } return "SUBSTRING($value, $position, LEN($value) - $position + 1)"; } function concat($arg1, $arg2) { $args = func_get_args(); return '(' . implode(' + ', $args) . ')'; } } class Doctrine_Expression_Mysql extends Doctrine_Expression { public function regexp() { return 'RLIKE'; } public function random() { return 'RAND()'; } public function matchPattern($pattern, $operator = null, $field = null) { $match = ''; if (!is_null($operator)) { $field = is_null($field) ? '' : $field.' '; $operator = strtoupper($operator); switch ($operator) { case 'ILIKE': $match = $field.'LIKE '; break; case 'LIKE': $match = $field.'LIKE BINARY '; break; default: throw new Doctrine_Expression_Mysql_Exception('not a supported operator type:'. $operator); } } $match.= "'"; foreach ($pattern as $key => $value) { if ($key % 2) { $match .= $value; } else { $match .= $this->conn->escapePattern($this->conn->escape($value)); } } $match.= "'"; $match.= $this->patternEscapeString(); return $match; } } class Doctrine_Expression_Oracle extends Doctrine_Expression { public function concat($arg1, $arg2) { $args = func_get_args(); $cols = $this->getIdentifiers( $args ); return join( ' || ' , $cols ); } public function substring($value, $position, $length = null) { if ($length !== null) return "SUBSTR($value, $position, $length)"; return "SUBSTR($value, $position)"; } public function now($type = 'timestamp') { switch ($type) { case 'date': case 'time': case 'timestamp': default: return 'TO_CHAR(CURRENT_TIMESTAMP, \'YYYY-MM-DD HH24:MI:SS\')'; } } function random() { return 'dbms_random.value'; } } class Doctrine_Expression_Pgsql extends Doctrine_Expression { public function md5($column) { $column = $this->getIdentifier($column); if ($this->version > 7) { return 'MD5(' . $column . ')'; } else { return 'encode(digest(' . $column .', md5), hex)'; } } public function substring($value, $from, $len = null) { $value = $this->getIdentifier($value); if ($len === null) { $len = $this->getIdentifier($len); return 'SUBSTR(' . $value . ', ' . $from . ')'; } else { return 'SUBSTR(' . $value . ', ' . $from . ', ' . $len . ')'; } } public function concat($arg1, $arg2) { $args = func_get_args(); $cols = $this->getIdentifiers($cols); return join(' || ' , $cols); } public function now() { return 'LOCALTIMESTAMP(0)'; } public function regexp() { return 'SIMILAR TO'; } public function random() { return 'RANDOM()'; } public function matchPattern($pattern, $operator = null, $field = null) { $match = ''; if (!is_null($operator)) { $field = is_null($field) ? '' : $field.' '; $operator = strtoupper($operator); switch ($operator) { case 'ILIKE': $match = $field.'ILIKE '; break; case 'LIKE': $match = $field.'LIKE '; break; default: throw new Doctrine_Expression_Pgsql_Exception('not a supported operator type:'. $operator); } } $match.= "'"; foreach ($pattern as $key => $value) { if ($key % 2) { $match.= $value; } else { $match.= $this->conn->escapePattern($this->conn->escape($value)); } } $match.= "'"; $match.= $this->patternEscapeString(); return $match; } } class Doctrine_Expression_Sqlite extends Doctrine_Expression { public static function md5Impl($data) { return md5($data); } public static function modImpl($dividend, $divisor) { return $dividend % $divisor; } public static function concatImpl() { $args = func_get_args(); return join( '', $args ); } public static function locateImpl($substr, $str) { return strpos($str, $substr); } public static function sha1Impl($str) { return sha1($str); } public static function ltrimImpl($str) { return ltrim($str); } public static function rtrimImpl($str) { return rtrim($str); } public static function trimImpl($str) { return trim($str); } public function regexp() { return 'RLIKE'; } public function soundex($value) { return 'SOUNDEX(' . $value . ')'; } public function now($type = 'timestamp') { switch ($type) { case 'time': return 'time(\'now\')'; case 'date': return 'date(\'now\')'; case 'timestamp': default: return 'datetime(\'now\')'; } } public function random() { return '((RANDOM() + 2147483648) / 4294967296)'; } public function substring($value, $position, $length = null) { if ($length !== null) { return 'SUBSTR(' . $value . ', ' . $position . ', ' . $length . ')'; } return 'SUBSTR(' . $value . ', ' . $position . ', LENGTH(' . $value . '))'; } } class Doctrine_Hook { protected $query; protected $joins; protected $hooks = array( 'where', 'orderby', 'limit', 'offset' ); protected $params = array(); protected $fieldParsers = array(); protected $typeParsers = array( 'char' => 'Doctrine_Hook_WordLike', 'string' => 'Doctrine_Hook_WordLike', 'integer' => 'Doctrine_Hook_Integer', 'time' => 'Doctrine_Hook_Time', 'date' => 'Doctrine_Hook_Date', ); public function __construct($query) { if (is_string($query)) { $this->query = new Doctrine_Query(); $this->query->parseQuery($query); } elseif ($query instanceof Doctrine_Query) { $this->query = $query; } } public function getQuery() { return $this->query; } public function setTypeParser($type, $parser) { $this->typeParsers[$type] = $parser; } public function setFieldParser($field, $parser) { $this->fieldParsers[$field] = $parser; } public function hookWhere($params) { if ( ! is_array($params)) { return false; } foreach ($params as $name => $value) { $e = explode('.', $name); if (count($e) == 2) { list($alias, $column) = $e; $tableAlias = $this->query->getTableAlias($alias); $table = $this->query->getTable($tableAlias); if ($def = $table->getDefinitionOf($column)) { if (isset($this->typeParsers[$def[0]])) { $name = $this->typeParsers[$def[0]]; $parser = new $name; } $parser->parse($alias, $column, $value); $this->query->addWhere($parser->getCondition()); $this->params += $parser->getParams(); } } } $this->params += $params; return true; } public function hookOrderby($params) { if ( ! is_array($params)) { return false; } foreach ($params as $name) { $e = explode(' ', $name); $order = 'ASC'; if (count($e) > 1) { $order = ($e[1] == 'DESC') ? 'DESC' : 'ASC'; } $e = explode('.', $e[0]); if (count($e) == 2) { list($alias, $column) = $e; $tableAlias = $this->query->getTableAlias($alias); $table = $this->query->getTable($tableAlias); if ($def = $table->getDefinitionOf($column)) { $this->query->addOrderBy($alias . '.' . $column . ' ' . $order); } } } return true; } public function hookLimit($limit) { $this->query->limit((int) $limit); } public function hookOffset($offset) { $this->query->offset((int) $offset); } } abstract class Doctrine_Hook_Parser { protected $condition; protected $params = array(); public function getCondition() { return $this->condition; } public function getParams() { return $this->params; } abstract public function parse($alias, $field, $value); } abstract class Doctrine_Hook_Parser_Complex extends Doctrine_Hook_Parser { public function parse($alias, $field, $value) { $this->condition = $this->parseClause($alias, $field, $value); } public function parseClause($alias, $field, $value) { $parts = Doctrine_Query::quoteExplode($value, ' AND '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseSingle($alias, $field, $part); } $r = implode(' AND ', $ret); } else { $parts = Doctrine_Query::quoteExplode($value, ' OR '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseClause($alias, $field, $part); } $r = implode(' OR ', $ret); } else { $ret = $this->parseSingle($alias, $field, $parts[0]); return $ret; } } return '(' . $r . ')'; } abstract public function parseSingle($alias, $field, $value); } class Doctrine_Hook_Equal extends Doctrine_Hook_Parser { public function parse($alias, $field, $value) { $this->params = (array) $value; $this->condition = $alias . '.' . $field . ' = ?'; } } class Doctrine_Hook_Integer extends Doctrine_Hook_Parser_Complex { public function parseSingle($alias, $field, $value) { $e = explode(' ', $value); foreach ($e as $v) { $v = trim($v); $e2 = explode('-', $v); $name = $alias. '.' . $field; if (count($e2) == 1) { $a[] = $name . ' = ?'; $this->params[] = $v; } else { $a[] = '(' . $name . ' > ? AND ' . $name . ' < ?)'; $this->params += array($e2[0], $e2[1]); } } return implode(' OR ', $a); } } class Doctrine_Hook_WordLike extends Doctrine_Hook_Parser_Complex { public function parseSingle($alias, $field, $value) { if (strpos($value, "'") !== false) { $value = Doctrine_Query::bracketTrim($value, "'", "'"); $a[] = $alias . '.' . $field . ' LIKE ?'; $this->params[] = $value . '%'; } else { $e2 = explode(' ',$value); foreach ($e2 as $v) { $v = trim($v); $a[] = $alias . '.' . $field . ' LIKE ?'; $this->params[] = $v . '%'; } } return implode(' OR ', $a); } } class Doctrine_Hydrate_Alias { protected $shortAliases = array(); protected $shortAliasIndexes = array(); public function clear() { $this->shortAliases = array(); $this->shortAliasIndexes = array(); } public function generateNewAlias($alias) { if (isset($this->shortAliases[$alias])) { $name = substr($alias, 0, 1); $i = ((int) substr($alias, 1)); if ($i == 0) $i = 1; $newIndex = ($this->shortAliasIndexes[$name] + $i); return $name . $newIndex; } return $alias; } public function hasAliasFor($tableName) { return (isset($this->shortAliases[$tableName])); } public function getShortAliasIndex($alias) { if ( ! isset($this->shortAliasIndexes[$alias])) { return 0; } return $this->shortAliasIndexes[$alias]; } public function generateShortAlias($tableName) { $char = strtolower(substr($tableName, 0, 1)); $alias = $char; if ( ! isset($this->shortAliasIndexes[$alias])) { $this->shortAliasIndexes[$alias] = 1; } while (isset($this->shortAliases[$alias])) { $alias = $char . ++$this->shortAliasIndexes[$alias]; } $this->shortAliases[$alias] = $tableName; return $alias; } public function getShortAlias($tableName) { $alias = array_search($tableName, $this->shortAliases); if ($alias !== false) { return $alias; } return $this->generateShortAlias($tableName); } } abstract class Doctrine_Hydrate extends Doctrine_Access { protected $fetchModes = array(); protected $tables = array(); protected $collections = array(); protected $joins = array(); protected $params = array(); protected $conn; protected $view; protected $inheritanceApplied = false; protected $aggregate = false; protected $compAliases = array(); protected $tableAliases = array(); protected $tableIndexes = array(); protected $pendingAggregates = array(); protected $aggregateMap = array(); protected $aliasHandler; protected $parts = array( 'select' => array(), 'from' => array(), 'set' => array(), 'join' => array(), 'where' => array(), 'groupby' => array(), 'having' => array(), 'orderby' => array(), 'limit' => false, 'offset' => false, ); public function __construct($connection = null) { if ( ! ($connection instanceof Doctrine_Connection)) { $connection = Doctrine_Manager::getInstance()->getCurrentConnection(); } $this->conn = $connection; $this->aliasHandler = new Doctrine_Hydrate_Alias(); } public function getComponentAliases() { return $this->compAliases; } public function getTableAliases() { return $this->tableAliases; } public function getTableIndexes() { return $this->tableIndexes; } public function getTables() { return $this->tables; } public function copyAliases(Doctrine_Hydrate $query) { $this->compAliases = $query->getComponentAliases(); $this->tableAliases = $query->getTableAliases(); $this->tableIndexes = $query->getTableIndexes(); return $this; } public function getPathAlias($path) { $s = array_search($path, $this->compAliases); if ($s === false) return $path; return $s; } public function createSubquery() { $class = get_class($this); $obj = new $class(); $obj->copyAliases($this); return $obj; } abstract public function getQuery(); public function isLimitSubqueryUsed() { return false; } public function remove($name) { if (isset($this->parts[$name])) { if ($name == "limit" || $name == "offset") { $this->parts[$name] = false; } else { $this->parts[$name] = array(); } } return $this; } protected function clear() { $this->fetchModes = array(); $this->tables = array(); $this->parts = array( "select" => array(), "from" => array(), "join" => array(), "where" => array(), "groupby" => array(), "having" => array(), "orderby" => array(), "limit" => false, "offset" => false, ); $this->inheritanceApplied = false; $this->aggregate = false; $this->collections = array(); $this->joins = array(); $this->tableIndexes = array(); $this->tableAliases = array(); $this->aliasHandler->clear(); } public function getConnection() { return $this->conn; } public function setView(Doctrine_View $view) { $this->view = $view; } public function getView() { return $this->view; } public function getParams() { return $this->params; } final public function getTableAlias($path) { if (isset($this->compAliases[$path])) { $path = $this->compAliases[$path]; } if ( ! isset($this->tableAliases[$path])) { return false; } return $this->tableAliases[$path]; } private function getCollection($name) { $table = $this->tables[$name]; if ( ! isset($this->fetchModes[$name])) { return new Doctrine_Collection($table); } switch ($this->fetchModes[$name]) { case Doctrine::FETCH_BATCH: $coll = new Doctrine_Collection_Batch($table); break; case Doctrine::FETCH_LAZY: $coll = new Doctrine_Collection_Lazy($table); break; case Doctrine::FETCH_OFFSET: $coll = new Doctrine_Collection_Offset($table); break; case Doctrine::FETCH_IMMEDIATE: $coll = new Doctrine_Collection_Immediate($table); break; case Doctrine::FETCH_LAZY_OFFSET: $coll = new Doctrine_Collection_LazyOffset($table); break; default: throw new Doctrine_Exception("Unknown fetchmode"); }; return $coll; } public function setParams(array $params = array()) { $this->params = $params; } public function execute($params = array(), $return = Doctrine::FETCH_RECORD) { $this->collections = array(); $params = $this->conn->convertBooleans(array_merge($this->params, $params)); if ( ! $this->view) { $query = $this->getQuery($params); } else { $query = $this->view->getSelectSql(); } if ($this->isLimitSubqueryUsed() && $this->conn->getDBH()->getAttribute(PDO::ATTR_DRIVER_NAME) !== 'mysql' ) { $params = array_merge($params, $params); } $stmt = $this->conn->execute($query, $params); if ($this->aggregate) { return $stmt->fetchAll(Doctrine::FETCH_ASSOC); } if (count($this->tables) == 0) { throw new Doctrine_Query_Exception("No components selected"); } $keys = array_keys($this->tables); $root = $keys[0]; $previd = array(); $coll = $this->getCollection($root); $prev[$root] = $coll; if ($this->aggregate) $return = Doctrine::FETCH_ARRAY; $array = $this->parseData($stmt); if ($return == Doctrine::FETCH_ARRAY) return $array; foreach ($array as $data) { foreach ($data as $key => $row) { if (empty($row)) { continue; } foreach ($this->tables as $k => $t) { if ( ! strcasecmp($key, $k)) { $key = $k; } } if ( !isset($this->tables[$key]) ) { throw new Doctrine_Exception('No table named ' . $key . ' found.'); } $ids = $this->tables[$key]->getIdentifier(); $name = $key; if ($this->isIdentifiable($row, $ids)) { if ($name !== $root) { $prev = $this->initRelated($prev, $name); } if (isset($row[0])) { $component = $this->tables[$name]->getComponentName(); if ($prev[$name]->count() > 0) { $record = $prev[$name]->getLast(); } else { $record = new $component(); $prev[$name]->add($record); } $path = array_search($name, $this->tableAliases); $alias = $this->getPathAlias($path); foreach ($row as $index => $value) { $agg = false; if (isset($this->pendingAggregates[$alias][$index])) { $agg = $this->pendingAggregates[$alias][$index][3]; } $record->mapValue($agg, $value); } } continue; } if ( ! isset($previd[$name])) { $previd[$name] = array(); } if ($previd[$name] !== $row) { $this->tables[$name]->setData($row); $record = $this->tables[$name]->getRecord(); if (isset($row[0])) { $path = array_search($name, $this->tableAliases); $alias = $this->getPathAlias($path); foreach ($row as $index => $value) { $agg = false; if (isset($this->pendingAggregates[$alias][$index])) { $agg = $this->pendingAggregates[$alias][$index][3]; } $record->mapValue($agg, $value); } } if ($name == $root) { $coll->add($record); unset($previd); } else { $prev = $this->addRelated($prev, $name, $record); } if ($prev[$name] !== $record) $prev[$name] = $record; } $previd[$name] = $row; } } return $coll; } public function initRelated(array $prev, $name) { $pointer = $this->joins[$name]; $path = array_search($name, $this->tableAliases); $tmp = explode('.', $path); $alias = end($tmp); if ( ! isset($prev[$pointer]) ) { return $prev; } $fk = $this->tables[$pointer]->getRelation($alias); if ( ! $fk->isOneToOne()) { if ($prev[$pointer]->getLast() instanceof Doctrine_Record) { if ( ! $prev[$pointer]->getLast()->hasReference($alias)) { $prev[$name] = $this->getCollection($name); $prev[$pointer]->getLast()->initReference($prev[$name],$fk); } else { $prev[$name] = $prev[$pointer]->getLast()->get($alias); } } } return $prev; } public function addRelated(array $prev, $name, Doctrine_Record $record) { $pointer = $this->joins[$name]; $path = array_search($name, $this->tableAliases); $tmp = explode('.', $path); $alias = end($tmp); $fk = $this->tables[$pointer]->getRelation($alias); if ($fk->isOneToOne()) { $prev[$pointer]->getLast()->set($fk->getAlias(), $record); $prev[$name] = $record; } else { if ( ! $prev[$pointer]->getLast()->hasReference($alias)) { $prev[$name] = $this->getCollection($name); $prev[$pointer]->getLast()->initReference($prev[$name], $fk); } else { $prev[$name] = $prev[$pointer]->getLast()->get($alias); } $prev[$pointer]->getLast()->addReference($record, $fk); } return $prev; } public function isIdentifiable(array $row, $ids) { if (is_array($ids)) { foreach ($ids as $id) { if ($row[$id] == null) return true; } } else { if ( ! isset($row[$ids])) { return true; } } return false; } public function applyInheritance() { $array = array(); foreach ($this->tables as $alias => $table) { $array[$alias][] = $table->inheritanceMap; } $str = ""; $c = array(); $index = 0; foreach ($array as $tableAlias => $maps) { $a = array(); foreach ($maps as $map) { $b = array(); foreach ($map as $field => $value) { if ($index > 0) { $b[] = '(' . $tableAlias . '.' . $field . ' = ' . $value . ' OR ' . $tableAlias . '.' . $field . ' IS NULL)'; } else { $b[] = $tableAlias . '.' . $field . ' = ' . $value; } } if ( ! empty($b)) { $a[] = implode(' AND ', $b); } } if ( ! empty($a)) { $c[] = implode(' AND ', $a); } $index++; } $str .= implode(' AND ', $c); return $str; } public function parseData($stmt) { $array = array(); while ($data = $stmt->fetch(PDO::FETCH_ASSOC)) { foreach ($data as $key => $value) { $e = explode('__', $key); $field = strtolower(array_pop($e)); $component = strtolower(implode('__', $e)); $data[$component][$field] = $value; unset($data[$key]); }; $array[] = $data; }; $stmt->closeCursor(); return $array; } public function getTable($name) { if (isset($this->tables[$name])) { return $this->tables[$name]; } return false; } public function __toString() { return Doctrine_Lib::formatSql($this->getQuery()); } } class Doctrine_Identifier { const AUTO_INCREMENT = 1; const SEQUENCE = 2; const NORMAL = 3; const COMPOSITE = 4; } class Doctrine_Import_Builder { private $path = ''; private $suffix = '.php'; private static $tpl; public function __construct() { if ( ! isset(self::$tpl)) { self::$tpl = file_get_contents(Doctrine::getPath() . DIRECTORY_SEPARATOR . 'Doctrine' . DIRECTORY_SEPARATOR . 'Import' . DIRECTORY_SEPARATOR . 'Builder' . DIRECTORY_SEPARATOR . 'Record.tpl'); } } public function setTargetPath($path) { if ( ! file_exists($path)) { mkdir($path, 0777); } $this->path = $path; } public function getTargetPath() { return $this->path; } public function buildRecord($table, $tableColumns) { if (empty($this->path)) { throw new Doctrine_Import_Builder_Exception('No build target directory set.'); } if (is_writable($this->path) === false) { throw new Doctrine_Import_Builder_Exception('Build target directory ' . $this->path . ' is not writable.'); } $created = date('l dS \of F Y h:i:s A'); $className = Doctrine::classify($table); $fileName = $this->path . DIRECTORY_SEPARATOR . $className . $this->suffix; $columns = array(); $i = 0; foreach ($tableColumns as $name => $column) { $columns[$i] = '        $this->hasColumn(\'' . $name . '\', \'' . $column['ptype'][0] . '\''; if ($column['length']) { $columns[$i] .= ', ' . $column['length']; } else { $columns[$i] .= ', null'; } $a = array(); if ($column['default']) { $a[] = '\'default\' => ' . var_export($column['default'], true); } if ($column['notnull']) { $a[] = '\'notnull\' => true'; } if ($column['primary']) { $a[] = '\'primary\' => true'; } if ($column['autoinc']) { $a[] = '\'autoincrement\' => true'; } if ($column['unique']) { $a[] = '\'unique\' => true'; } if ($column['unsigned']) { $a[] = '\'unsigned\' => true'; } if ( ! empty($a)) { $columns[$i] .= ', ' . 'array('; $length = strlen($columns[$i]); $columns[$i] .= implode(', 
' . str_repeat(' ', $length), $a) . ')'; } $columns[$i] .= ');'; if ($i < (count($table) - 1)) { $columns[$i] .= '
'; } $i++; } $content = sprintf(self::$tpl, $created, $className, implode("\n", $columns)); $bytes = file_put_contents($fileName, $content); if ($bytes === false) { throw new Doctrine_Import_Builder_Exception("Couldn't write file " . $fileName); } } public function build(Doctrine_Schema_Object $schema) { foreach ($schema->getDatabases() as $database){ foreach ($database->getTables() as $table){ $this->buildRecord($table); } } } } class Doctrine_Import_Builder_BaseClass extends Doctrine_Import_Builder { } class Doctrine_Import_Builder_Exception extends Doctrine_Import_Exception { } class Doctrine_Import extends Doctrine_Connection_Module { protected $sql = array(); public function listDatabases() { if ( ! isset($this->sql['listDatabases'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listDatabases']); } public function listFunctions() { if ( ! isset($this->sql['listFunctions'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listFunctions']); } public function listTriggers($database = null) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listSequences($database = null) { if ( ! isset($this->sql['listSequences'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listSequences']); } public function listTableConstraints($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableColumns($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableIndexes($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTables($database = null) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableTriggers($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableViews($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listUsers() { if ( ! isset($this->sql['listUsers'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listUsers']); } public function listViews($database = null) { if ( ! isset($this->sql['listViews'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listViews']); } public function import($directory, array $databases = array()) { $builder = new Doctrine_Import_Builder(); $builder->setTargetPath($directory); foreach ($this->listTables() as $table) { $builder->buildRecord($table, $this->listTableColumns($table)); } } } class Doctrine_Import_Exception extends Doctrine_Exception { } class Doctrine_Import_Firebird extends Doctrine_Import { public function listTables() { $query = 'SELECT RDB$RELATION_NAME FROM RDB$RELATIONS WHERE RDB$SYSTEM_FLAG=0 AND RDB$VIEW_BLR IS NULL'; return $this->conn->fetchColumn($query); } public function listTableFields($table) { $table = $this->conn->quote(strtoupper($table), 'text'); $query = 'SELECT RDB$FIELD_NAME FROM RDB$RELATION_FIELDS WHERE UPPER(RDB$RELATION_NAME) = ' . $table; return $this->conn->fetchColumn($query); } public function listUsers() { return $this->conn->fetchColumn('SELECT DISTINCT RDB$USER FROM RDB$USER_PRIVILEGES'); } public function listViews() { return $this->conn->fetchColumn('SELECT DISTINCT RDB$VIEW_NAME FROM RDB$VIEW_RELATIONS'); } public function listTableViews($table) { $query = 'SELECT DISTINCT RDB$VIEW_NAME FROM RDB$VIEW_RELATIONS'; $table = $this->conn->quote(strtoupper($table), 'text'); $query .= ' WHERE UPPER(RDB$RELATION_NAME) = ' . $table; return $this->conn->fetchColumn($query); } public function listFunctions() { $query = 'SELECT RDB$FUNCTION_NAME FROM RDB$FUNCTIONS WHERE RDB$SYSTEM_FLAG IS NULL'; return $this->conn->fetchColumn($query); } public function listTableTriggers($table = null) { $query = 'SELECT RDB$TRIGGER_NAME FROM RDB$TRIGGERS WHERE RDB$SYSTEM_FLAG IS NULL OR RDB$SYSTEM_FLAG = 0'; if ( ! is_null($table)) { $table = $this->conn->quote(strtoupper($table), 'text'); $query .= ' WHERE UPPER(RDB$RELATION_NAME) = ' . $table; } return $this->conn->fetchColumn($query); } } class Doctrine_Import_Informix extends Doctrine_Import { protected $sql = array( 'listTables' => "SELECT tabname,tabtype FROM systables WHERE tabtype IN ('T','V') AND owner != 'informix'", 'listColumns' => "SELECT c.colname, c.coltype, c.collength, d.default, c.colno
		                                      FROM syscolumns c, systables t,outer sysdefaults d
		                                      WHERE c.tabid = t.tabid AND d.tabid = t.tabid AND d.colno = c.colno
		                                      AND tabname='%s' ORDER BY c.colno", 'listPk' => "SELECT part1, part2, part3, part4, part5, part6, part7, part8 FROM
		                                      systables t, sysconstraints s, sysindexes i WHERE t.tabname='%s'
		                                      AND s.tabid=t.tabid AND s.constrtype='P'
		                                      AND i.idxname=s.idxname", 'listForeignKeys' => "SELECT tr.tabname,updrule,delrule,
                                              i.part1 o1,i2.part1 d1,i.part2 o2,i2.part2 d2,i.part3 o3,i2.part3 d3,i.part4 o4,i2.part4 d4,
                                              i.part5 o5,i2.part5 d5,i.part6 o6,i2.part6 d6,i.part7 o7,i2.part7 d7,i.part8 o8,i2.part8 d8
                                              from systables t,sysconstraints s,sysindexes i,
                                              sysreferences r,systables tr,sysconstraints s2,sysindexes i2
                                              where t.tabname='%s'
                                              and s.tabid=t.tabid and s.constrtype='R' and r.constrid=s.constrid
                                              and i.idxname=s.idxname and tr.tabid=r.ptabid
                                              and s2.constrid=r.primary and i2.idxname=s2.idxname", ); } class Doctrine_Import_Mssql extends Doctrine_Import { public function listSequences($database = null) { $query = "SELECT name FROM sysobjects WHERE xtype = 'U'"; $tableNames = $this->conn->fetchColumn($query); return array_map(array($this->conn, 'fixSequenceName'), $tableNames); } public function listTableColumns($table) { $sql = 'EXEC sp_columns @table_name = ' . $this->conn->quoteIdentifier($table, true); $result = $this->conn->fetchAssoc($sql); $columns = array(); foreach ($result as $key => $val) { if (strstr($val['type_name'], ' ')) { list($type, $identity) = explode(' ', $val['type_name']); } else { $type = $val['type_name']; $identity = ''; } if ($type == 'varchar') { $type .= '(' . $val['length'] . ')'; } $decl = $this->conn->dataDict->getPortableDeclaration($val); $description = array( 'name' => $val['column_name'], 'type' => $type, 'ptype' => $decl['type'], 'length' => $decl['length'], 'fixed' => $decl['fixed'], 'unsigned' => $decl['unsigned'], 'notnull' => (bool) ($val['is_nullable'] === 'NO'), 'default' => $val['column_def'], 'primary' => (strtolower($identity) == 'identity'), ); $columns[$val['column_name']] = $description; } return $columns; } public function listTableIndexes($table) { } public function listTables($database = null) { $sql = "SELECT name FROM sysobjects WHERE type = 'U' ORDER BY name"; return $this->conn->fetchColumn($sql); } public function listTriggers() { $query = "SELECT name FROM sysobjects WHERE xtype = 'TR'"; $result = $this->conn->fetchColumn($query); return $result; } public function listTableTriggers($table) { $table = $this->conn->quote($table, 'text'); $query = "SELECT name FROM sysobjects WHERE xtype = 'TR' AND object_name(parent_obj) = " . $table; $result = $this->conn->fetchColumn($query); return $result; } public function listTableViews($table) { $keyName = 'INDEX_NAME'; $pkName = 'PK_NAME'; if ($this->conn->options['portability'] & Doctrine::PORTABILITY_FIX_CASE) { if ($this->conn->options['field_case'] == CASE_LOWER) { $keyName = strtolower($keyName); $pkName = strtolower($pkName); } else { $keyName = strtoupper($keyName); $pkName = strtoupper($pkName); } } $table = $this->conn->quote($table, 'text'); $query = 'EXEC sp_statistics @table_name = ' . $table; $indexes = $this->conn->fetchColumn($query, $keyName); $query = 'EXEC sp_pkeys @table_name = ' . $table; $pkAll = $this->conn->fetchColumn($query, $pkName); $result = array(); foreach ($indexes as $index) { if (!in_array($index, $pkAll) && $index != null) { $result[] = $this->_fixIndexName($index); } } return $result; } public function listViews($database = null) { $query = "SELECT name FROM sysobjects WHERE xtype = 'V'"; return $this->conn->fetchColumn($query); } } class Doctrine_Import_Mysql extends Doctrine_Import { protected $sql = array( 'showDatabases' => 'SHOW DATABASES', 'listTableFields' => 'DESCRIBE %s', 'listSequences' => 'SHOW TABLES', 'listTables' => 'SHOW TABLES', 'listUsers' => 'SELECT DISTINCT USER FROM USER', 'listViews' => "SHOW FULL TABLES %sWHERE Table_type = 'VIEW'", ); public function listSequences($database = null) { $query = "SHOW TABLES"; if (!is_null($database)) { $query .= " FROM $database"; } $tableNames = $this->conn->fetchColumn($query); return array_map(array($this->conn, 'fixSequenceName'), $tableNames); } public function listTableConstraints($table) { $keyName = 'Key_name'; $nonUnique = 'Non_unique'; if ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_FIX_CASE) { if ($this->conn->options['field_case'] == CASE_LOWER) { $keyName = strtolower($keyName); $nonUnique = strtolower($nonUnique); } else { $keyName = strtoupper($keyName); $nonUnique = strtoupper($nonUnique); } } $table = $this->conn->quoteIdentifier($table, true); $query = 'SHOW INDEX FROM ' . $table; $indexes = $this->conn->fetchAssoc($query); $result = array(); foreach ($indexes as $indexData) { if (!$indexData[$nonUnique]) { if ($indexData[$keyName] !== 'PRIMARY') { $index = $this->conn->fixIndexName($indexData[$keyName]); } else { $index = 'PRIMARY'; } if ( ! empty($index)) { $result[] = $index; } } } return $result; } public function listTableColumns($table) { $sql = 'DESCRIBE ' . $table; $result = $this->conn->fetchAssoc($sql); $description = array(); foreach ($result as $key => $val) { $val = array_change_key_case($val, CASE_LOWER); $decl = $this->conn->dataDict->getPortableDeclaration($val); $description = array( 'name' => $val['field'], 'type' => $val['type'], 'ptype' => $decl['type'], 'length' => $decl['length'], 'fixed' => $decl['fixed'], 'unsigned' => $decl['unsigned'], 'primary' => (strtolower($val['key']) == 'pri'), 'default' => $val['default'], 'notnull' => (bool) ($val['null'] != 'YES'), 'autoinc' => (bool) (strpos($val['extra'], 'auto_increment') !== false), ); $columns[$val['field']] = $description; } return $columns; } public function listTableIndexes($table) { $keyName = 'Key_name'; $nonUnique = 'Non_unique'; if ($this->conn->options['portability'] & Doctrine::PORTABILITY_FIX_CASE) { if ($this->conn->options['field_case'] == CASE_LOWER) { $keyName = strtolower($keyName); $nonUnique = strtolower($nonUnique); } else { $keyName = strtoupper($keyName); $nonUnique = strtoupper($nonUnique); } } $table = $this->conn->quoteIdentifier($table, true); $query = 'SHOW INDEX FROM ' . $table; $indexes = $this->conn->fetchAssoc($query); $result = array(); foreach ($indexes as $indexData) { if ($indexData[$nonUnique] && ($index = $this->conn->fixIndexName($indexData[$keyName]))) { $result[] = $index; } } return $result; } public function listTables($database = null) { return $this->conn->fetchColumn($this->sql['listTables']); } public function listViews($database = null) { if (!is_null($database)) { $query = sprintf($this->sql['listViews'], ' FROM ' . $database); } return $this->conn->fetchColumn($query); } } class Doctrine_Import_Oracle extends Doctrine_Import { public function listDatabases() { if ( ! $this->conn->getAttribute(Doctrine::ATTR_EMULATE_DATABASE)) { throw new Doctrine_Import_Exception('database listing is only supported if the "emulate_database" option is enabled'); } $query = 'SELECT username FROM sys.dba_users'; $result2 = $this->conn->standaloneQuery($query); $result = $result2->fetchColumn(); return $result; } public function listFunctions() { $query = "SELECT name FROM sys.user_source WHERE line = 1 AND type = 'FUNCTION'"; return $this->conn->fetchColumn($query); } public function listTriggers($database = null) { } public function listSequences($database = null) { $query = "SELECT sequence_name FROM sys.user_sequences"; $tableNames = $this->conn->fetchColumn($query); return array_map(array($this->conn, 'fixSequenceName'), $tableNames); } public function listTableConstraints($table) { $table = $this->conn->quote($table, 'text'); $query = 'SELECT index_name name FROM user_constraints' . ' WHERE table_name = ' . $table . ' OR table_name = ' . strtoupper($table); $constraints = $this->conn->fetchColumn($query); return array_map(array($this->conn, 'fixIndexName'), $constraints); } public function listTableColumns($table) { $table = strtoupper($table); $sql = "SELECT column_name, data_type, data_length, nullable, data_default, data_scale, data_precision FROM all_tab_columns" . " WHERE table_name = '" . $table . "' ORDER BY column_name"; $result = $this->conn->fetchAssoc($sql); foreach($result as $val) { $decl = $this->conn->dataDict->getPortableDeclaration($val); $descr[$val['column_name']] = array( 'name' => $val['column_name'], 'notnull' => (bool) ($val['nullable'] === 'N'), 'type' => $val['data_type'], 'ptype' => $decl['type'], 'fixed' => $decl['fixed'], 'unsigned' => $decl['unsigned'], 'default' => $val['data_default'], 'length' => $val['data_length'], 'precision' => $val['data_precision'], 'scale' => $val['scale'], ); } return $result; } public function listTableIndexes($table) { $table = $this->conn->quote($table, 'text'); $query = 'SELECT index_name name FROM user_indexes' . ' WHERE table_name = ' . $table . ' OR table_name = ' . strtoupper($table) . ' AND generated = ' . $this->conn->quote('N', 'text'); $indexes = $this->conn->fetchColumn($query); return array_map(array($this->conn, 'fixIndexName'), $indexes); } public function listTables($database = null) { $query = 'SELECT table_name FROM sys.user_tables'; return $this->conn->fetchColumn($query); } public function listTableTriggers($table) { } public function listTableViews($table) { } public function listUsers() { $query = 'SELECT username FROM sys.dba_users'; return $this->conn->fetchColumn($query); } public function listViews($database = null) { $query = 'SELECT view_name FROM sys.user_views'; return $this->conn->fetchColumn($query); } } class Doctrine_Import_Pgsql extends Doctrine_Import { protected $sql = array( 'listDatabases' => 'SELECT datname FROM pg_database', 'listFunctions' => "SELECT
                                                proname
                                            FROM
                                                pg_proc pr,
                                                pg_type tp
                                            WHERE
                                                tp.oid = pr.prorettype
                                                AND pr.proisagg = FALSE
                                                AND tp.typname <> 'trigger'
                                                AND pr.pronamespace IN
                                                    (SELECT oid FROM pg_namespace
                                                     WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema'", 'listSequences' => "SELECT
                                                relname
                                            FROM
                                                pg_class
                                            WHERE relkind = 'S' AND relnamespace IN
                                                (SELECT oid FROM pg_namespace
                                                 WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema')", 'listTables' => "SELECT
                                                c.relname AS table_name
                                            FROM pg_class c, pg_user u
                                            WHERE c.relowner = u.usesysid
                                                AND c.relkind = 'r'
                                                AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname)
                                                AND c.relname !~ '^(pg_|sql_)'
                                            UNION
                                            SELECT c.relname AS table_name
                                            FROM pg_class c
                                            WHERE c.relkind = 'r'
                                                AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname)
                                                AND NOT EXISTS (SELECT 1 FROM pg_user WHERE usesysid = c.relowner)
                                                AND c.relname !~ '^pg_'", 'listViews' => 'SELECT viewname FROM pg_views', 'listUsers' => 'SELECT usename FROM pg_user', 'listTableConstraints' => "SELECT
                                                        relname
                                                   FROM
                                                        pg_class
                                                   WHERE oid IN (
                                                        SELECT indexrelid
                                                        FROM pg_index, pg_class
                                                        WHERE pg_class.relname = %s
                                                            AND pg_class.oid = pg_index.indrelid
                                                            AND (indisunique = 't' OR indisprimary = 't')
                                                        )", 'listTableIndexes' => "SELECT
                                                        relname
                                                   FROM
                                                        pg_class
                                                   WHERE oid IN (
                                                        SELECT indexrelid
                                                        FROM pg_index, pg_class
                                                        WHERE pg_class.relname = %s
                                                            AND pg_class.oid=pg_index.indrelid
                                                            AND indisunique != 't'
                                                            AND indisprimary != 't'
                                                        )", 'listTableColumns' => "SELECT
                                                        a.attnum,
                                                        a.attname AS field,
                                                        t.typname AS type,
                                                        format_type(a.atttypid, a.atttypmod) AS complete_type,
                                                        a.attnotnull AS isnotnull,
                                                        (SELECT 't'
                                                          FROM pg_index
                                                          WHERE c.oid = pg_index.indrelid
                                                          AND pg_index.indkey[0] = a.attnum
                                                          AND pg_index.indisprimary = 't'
                                                        ) AS pri,
                                                        (SELECT pg_attrdef.adsrc
                                                          FROM pg_attrdef
                                                          WHERE c.oid = pg_attrdef.adrelid
                                                          AND pg_attrdef.adnum=a.attnum
                                                        ) AS default
                                                  FROM pg_attribute a, pg_class c, pg_type t
                                                  WHERE c.relname = %s
                                                        AND a.attnum > 0
                                                        AND a.attrelid = c.oid
                                                        AND a.atttypid = t.oid
                                                  ORDER BY a.attnum", ); public function listTriggers($database = null) { } public function listTableConstraints($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableConstraints'], $table); return $this->conn->fetchColumn($query); } public function listTableColumns($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableColumns'], $table); $result = $this->conn->fetchAssoc($query); $columns = array(); foreach ($result as $key => $val) { if ($val['type'] === 'varchar') { $length = preg_replace('~.*\(([0-9]*)\).*~', '$1', $val['complete_type']); $val['type'] .= '(' . $length . ')'; } $decl = $this->conn->dataDict->getPortableDeclaration($val); $description = array( 'name' => $val['field'], 'type' => $val['type'], 'ptype' => $decl['type'], 'length' => $decl['length'], 'fixed' => $decl['fixed'], 'unsigned' => $decl['unsigned'], 'notnull' => ($val['isnotnull'] == ''), 'default' => $val['default'], 'primary' => ($val['pri'] == 't'), ); $columns[$val['field']] = $description; } return $columns; } public function listTableIndexes($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableIndexes'], $table); return $this->conn->fetchColumn($query); } public function listTables($database = null) { return $this->conn->fetchAssoc($this->sql['listTables']); } public function listTableTriggers($table) { } public function listTableViews($table) { return $this->conn->fetchColumn($query); } } class Doctrine_Import_Reader_Db extends Doctrine_Import_Reader { private $pdo; public function setPdo( $pdo ) { } public function read( ) { $dataDict = Doctrine_Manager::getInstance()->getCurrentConnection()->getDataDict(); $schema = new Doctrine_Schema(); $db = new Doctrine_Schema_Database(); $schema->addDatabase($db); $dbName = 'XXtest'; $this->conn->set("name",$dbName); $tableNames = $dataDict->listTables(); foreach ($tableNames as $tableName){ $table = new Doctrine_Schema_Table(); $table->set("name",$tableName); $tableColumns = $dataDict->listTableColumns($tableName); foreach ($tableColumns as $tableColumn){ $table->addColumn($tableColumn); } $this->conn->addTable($table); if ($fks = $dataDict->listTableConstraints($tableName)){ foreach ($fks as $fk){ $relation = new Doctrine_Schema_Relation(); $relation->setRelationBetween($fk['referencingColumn'],$fk['referencedTable'],$fk['referencedColumn']); $table->setRelation($relation); } } } return $schema; } } abstract class Doctrine_Import_Reader { abstract public function read( ); } class Doctrine_Import_Sqlite extends Doctrine_Import { public function listDatabases() { } public function listFunctions() { } public function listTriggers($database = null) { } public function listSequences($database = null) { $query = "SELECT name FROM sqlite_master WHERE type='table' AND sql NOT NULL ORDER BY name"; $tableNames = $this->conn->fetchColumn($query); $result = array(); foreach ($tableNames as $tableName) { if ($sqn = $this->conn->fixSequenceName($tableName, true)) { $result[] = $sqn; } } if ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_FIX_CASE) { $result = array_map(($this->conn->getAttribute(Doctrine::ATTR_FIELD_CASE) == CASE_LOWER ? 'strtolower' : 'strtoupper'), $result); } return $result; } public function listTableConstraints($table) { $table = $this->conn->quote($table, 'text'); $query = "SELECT sql FROM sqlite_master WHERE type='index' AND "; if ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_FIX_CASE) { $query .= 'LOWER(tbl_name) = ' . strtolower($table); } else { $query .= 'tbl_name = ' . $table; } $query .= ' AND sql NOT NULL ORDER BY name'; $indexes = $this->conn->fetchColumn($query); $result = array(); foreach ($indexes as $sql) { if (preg_match("/^create unique index ([^ ]+) on /i", $sql, $tmp)) { $index = $this->conn->fixIndexName($tmp[1]); if ( ! empty($index)) { $result[$index] = true; } } } if ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_FIX_CASE) { $result = array_change_key_case($result, $this->conn->getAttribute(Doctrine::ATTR_FIELD_CASE)); } return array_keys($result); } public function listTableColumns($table) { $sql = 'PRAGMA table_info(' . $table . ')'; $result = $this->conn->fetchAll($sql); $description = array(); $columns = array(); foreach ($result as $key => $val) { $description = array( 'name' => $val['name'], 'type' => $val['type'], 'notnull' => (bool) $val['notnull'], 'default' => $val['dflt_value'], 'primary' => (bool) $val['pk'], 'length' => null, 'scale' => null, 'precision' => null, 'unsigned' => null, ); $columns[$val['name']] = $description; } return $columns; } public function listTableIndexes($table) { $sql = 'PRAGMA index_list(' . $table . ')'; return $this->conn->fetchColumn($sql); } public function listTables($database = null) { $sql = "SELECT name FROM sqlite_master WHERE type = 'table' " . "UNION ALL SELECT name FROM sqlite_temp_master " . "WHERE type = 'table' ORDER BY name"; return $this->conn->fetchColumn($sql); } public function listTableTriggers($table) { } public function listTableViews($table) { } public function listUsers() { } public function listViews($database = null) { } } class Doctrine_Lib { public static function getRecordStateAsString($state) { switch ($state) { case Doctrine_Record::STATE_PROXY: return "proxy"; break; case Doctrine_Record::STATE_CLEAN: return "persistent clean"; break; case Doctrine_Record::STATE_DIRTY: return "persistent dirty"; break; case Doctrine_Record::STATE_TDIRTY: return "transient dirty"; break; case Doctrine_Record::STATE_TCLEAN: return "transient clean"; break; } } public static function getRecordAsString(Doctrine_Record $record) { $r[] = "<pre>"; $r[] = "Component  : ".$record->getTable()->getComponentName(); $r[] = "ID         : ".$record->obtainIdentifier(); $r[] = "References : ".count($record->getReferences()); $r[] = "State      : ".Doctrine_Lib::getRecordStateAsString($record->getState()); $r[] = "OID        : ".$record->getOID(); $r[] = "</pre>"; return implode("\n",$r)."<br />"; } public static function getConnectionStateAsString($state) { switch ($state) { case Doctrine_Transaction::STATE_SLEEP: return "open"; break; case Doctrine_Transaction::STATE_BUSY: return "busy"; break; case Doctrine_Transaction::STATE_ACTIVE: return "active"; break; } } public static function getConnectionAsString(Doctrine_Connection $connection) { $r[] = '<pre>'; $r[] = 'Doctrine_Connection object'; $r[] = 'State               : ' . Doctrine_Lib::getConnectionStateAsString($connection->transaction->getState()); $r[] = 'Open Transactions   : ' . $connection->transaction->getTransactionLevel(); $r[] = 'Table in memory     : ' . $connection->count(); $r[] = 'Driver name         : ' . $connection->getDbh()->getAttribute(Doctrine::ATTR_DRIVER_NAME); $r[] = "</pre>"; return implode("\n",$r)."<br>"; } public static function getTableAsString(Doctrine_Table $table) { $r[] = "<pre>"; $r[] = "Component   : ".$table->getComponentName(); $r[] = "Table       : ".$table->getTableName(); $r[] = "</pre>"; return implode("\n",$r)."<br>"; } public static function formatSql($sql) { $e = explode("\n",$sql); $color = "367FAC"; $l = $sql; $l = str_replace("SELECT ", "<font color='$color'><b>SELECT </b></font><br \>  ",$l); $l = str_replace("FROM ", "<font color='$color'><b>FROM </b></font><br \>",$l); $l = str_replace(" LEFT JOIN ", "<br \><font color='$color'><b> LEFT JOIN </b></font>",$l); $l = str_replace(" INNER JOIN ", "<br \><font color='$color'><b> INNER JOIN </b></font>",$l); $l = str_replace(" WHERE ", "<br \><font color='$color'><b> WHERE </b></font>",$l); $l = str_replace(" GROUP BY ", "<br \><font color='$color'><b> GROUP BY </b></font>",$l); $l = str_replace(" HAVING ", "<br \><font color='$color'><b> HAVING </b></font>",$l); $l = str_replace(" AS ", "<font color='$color'><b> AS </b></font><br \>  ",$l); $l = str_replace(" ON ", "<font color='$color'><b> ON </b></font>",$l); $l = str_replace(" ORDER BY ", "<font color='$color'><b> ORDER BY </b></font><br \>",$l); $l = str_replace(" LIMIT ", "<font color='$color'><b> LIMIT </b></font><br \>",$l); $l = str_replace(" OFFSET ", "<font color='$color'><b> OFFSET </b></font><br \>",$l); $l = str_replace("  ", "<dd>",$l); return $l; } public static function getCollectionAsString(Doctrine_Collection $collection) { $r[] = "<pre>"; $r[] = get_class($collection); foreach ($collection as $key => $record) { $r[] = "Key : ".$key." ID : ".$record->obtainIdentifier(); } $r[] = "</pre>"; return implode("\n",$r); } } class Doctrine_Locking_Exception extends Doctrine_Exception {} class Doctrine_Locking_Manager_Pessimistic { private $conn; private $_lockTable = 'doctrine_lock_tracking'; public function __construct(Doctrine_Connection $conn) { $this->conn = $conn; if ($this->conn->getAttribute(Doctrine::ATTR_CREATE_TABLES) === true) { $columns = array(); $columns['object_type'] = array('type' => 'string', 'length' => 50, 'notnull' => true, 'primary' => true); $columns['object_key'] = array('type' => 'string', 'length' => 250, 'notnull' => true, 'primary' => true); $columns['user_ident'] = array('type' => 'string', 'length' => 50, 'notnull' => true); $columns['timestamp_obtained'] = array('type' => 'integer', 'length' => 10, 'notnull' => true); $options = array('primary' => array('object_type', 'object_key')); try { $this->conn->export->createTable($this->_lockTable, $columns, $options); } catch(Exception $e) { } } } public function getLock(Doctrine_Record $record, $userIdent) { $objectType = $record->getTable()->getComponentName(); $key = $record->obtainIdentifier(); $gotLock = false; $time = time(); if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $dbh->beginTransaction(); $stmt = $dbh->prepare("INSERT INTO $this->_lockTable
                                          (object_type, object_key, user_ident, timestamp_obtained)
                                   VALUES (:object_type, :object_key, :user_ident, :ts_obtained)"); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $userIdent); $stmt->bindParam(':ts_obtained', $time); try { $stmt->execute(); $gotLock = true; } catch(Exception $pkviolation) { } if (!$gotLock) { $lockingUserIdent = $this->_getLockingUserIdent($objectType, $key); if ($lockingUserIdent !== null && $lockingUserIdent == $userIdent) { $gotLock = true; $stmt = $dbh->prepare("UPDATE $this->_lockTable SET timestamp_obtained = :ts
                                           WHERE object_type = :object_type AND
                                                 object_key  = :object_key  AND
                                                 user_ident  = :user_ident"); $stmt->bindParam(':ts', $time); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $lockingUserIdent); $stmt->execute(); } } $dbh->commit(); } catch (Exception $pdoe) { $dbh->rollback(); throw new Doctrine_Locking_Exception($pdoe->getMessage()); } return $gotLock; } public function releaseLock(Doctrine_Record $record, $userIdent) { $objectType = $record->getTable()->getComponentName(); $key = $record->obtainIdentifier(); if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare("DELETE FROM $this->_lockTable WHERE
                                        object_type = :object_type AND
                                        object_key  = :object_key  AND
                                        user_ident  = :user_ident"); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $userIdent); $stmt->execute(); $count = $stmt->rowCount(); return ($count > 0); } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } } private function _getLockingUserIdent($objectType, $key) { if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare("SELECT user_ident
                                   FROM $this->_lockTable
                                   WHERE object_type = :object_type AND object_key = :object_key"); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $success = $stmt->execute(); if (!$success) { throw new Doctrine_Locking_Exception("Failed to determine locking user"); } $userIdent = $stmt->fetchColumn(); } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } return $userIdent; } public function getLockOwner($lockedRecord) { $objectType = $lockedRecord->getTable()->getComponentName(); $key = $lockedRecord->obtainIdentifier(); return $this->_getLockingUserIdent($objectType, $key); } public function releaseAgedLocks($age = 900, $objectType = null, $userIdent = null) { $age = time() - $age; try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare('DELETE FROM ' . $this->_lockTable . ' WHERE timestamp_obtained < :age'); $stmt->bindParam(':age', $age); $query = 'DELETE FROM ' . $this->_lockTable . ' WHERE timestamp_obtained < :age'; if ($objectType) { $query .= ' AND object_type = :object_type'; } if ($userIdent) { $query .= ' AND user_ident = :user_ident'; } $stmt = $dbh->prepare($query); $stmt->bindParam(':age', $age); if ($objectType) { $stmt->bindParam(':object_type', $objectType); } if ($userIdent) { $stmt->bindParam(':user_ident', $userIdent); } $stmt->execute(); $count = $stmt->rowCount(); return $count; } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } } } class Doctrine_Manager_Exception extends Doctrine_Exception { } class Doctrine_Manager extends Doctrine_Configurable implements Countable, IteratorAggregate { private $connections = array(); private $bound = array(); private $index = 0; private $currIndex = 0; private $root; private $null; private $driverMap = array('oracle' => 'oci8', 'postgres' => 'pgsql', 'oci' => 'oci8', 'sqlite2' => 'sqlite', 'sqlite3' => 'sqlite'); private function __construct() { $this->root = dirname(__FILE__); $this->null = new Doctrine_Null; Doctrine_Record::initNullObject($this->null); Doctrine_Collection::initNullObject($this->null); Doctrine_Record_Iterator::initNullObject($this->null); Doctrine_Validator::initNullObject($this->null); } final public function getNullObject() { return $this->null; } final public function setDefaultAttributes() { static $init = false; if ( ! $init) { $init = true; $attributes = array( Doctrine::ATTR_FETCHMODE => Doctrine::FETCH_IMMEDIATE, Doctrine::ATTR_BATCH_SIZE => 5, Doctrine::ATTR_COLL_LIMIT => 5, Doctrine::ATTR_LISTENER => new Doctrine_EventListener(), Doctrine::ATTR_LOCKMODE => 1, Doctrine::ATTR_VLD => false, Doctrine::ATTR_AUTO_LENGTH_VLD => true, Doctrine::ATTR_AUTO_TYPE_VLD => true, Doctrine::ATTR_CREATE_TABLES => true, Doctrine::ATTR_QUERY_LIMIT => Doctrine::LIMIT_RECORDS, Doctrine::ATTR_IDXNAME_FORMAT => "%s_idx", Doctrine::ATTR_SEQNAME_FORMAT => "%s_seq", Doctrine::ATTR_QUOTE_IDENTIFIER => false, Doctrine::ATTR_SEQCOL_NAME => 'id', Doctrine::ATTR_PORTABILITY => Doctrine::PORTABILITY_ALL, ); foreach ($attributes as $attribute => $value) { $old = $this->getAttribute($attribute); if ($old === null) { $this->setAttribute($attribute,$value); } } return true; } return false; } final public function getRoot() { return $this->root; } public static function getInstance() { static $instance; if ( ! isset($instance)) { $instance = new self(); } return $instance; } public static function connection($adapter = null, $name = null) { if ($adapter == null) { return Doctrine_Manager::getInstance()->getCurrentConnection(); } else { return Doctrine_Manager::getInstance()->openConnection($adapter, $name); } } public function openConnection($adapter, $name = null, $setCurrent = true) { if ( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) { throw new Doctrine_Manager_Exception("First argument should be an instance of PDO or implement Doctrine_Adapter_Interface"); } if ($adapter instanceof Doctrine_Db) { $adapter->setName($name); } $this->setDefaultAttributes(); if ($name !== null) { $name = (string) $name; if (isset($this->connections[$name])) { return $this->connections[$name]; } } else { $name = $this->index; $this->index++; } switch ($adapter->getAttribute(Doctrine::ATTR_DRIVER_NAME)) { case 'mysql': $this->connections[$name] = new Doctrine_Connection_Mysql($this, $adapter); break; case 'sqlite': $this->connections[$name] = new Doctrine_Connection_Sqlite($this, $adapter); break; case 'pgsql': $this->connections[$name] = new Doctrine_Connection_Pgsql($this, $adapter); break; case 'oci': case 'oracle': $this->connections[$name] = new Doctrine_Connection_Oracle($this, $adapter); break; case 'mssql': $this->connections[$name] = new Doctrine_Connection_Mssql($this, $adapter); break; case 'firebird': $this->connections[$name] = new Doctrine_Connection_Firebird($this, $adapter); break; case 'informix': $this->connections[$name] = new Doctrine_Connection_Informix($this, $adapter); break; case 'mock': $this->connections[$name] = new Doctrine_Connection_Mock($this, $adapter); break; default: throw new Doctrine_Manager_Exception('Unknown connection driver '. $adapter->getAttribute(Doctrine::ATTR_DRIVER_NAME)); }; if ($setCurrent) { $this->currIndex = $name; } return $this->connections[$name]; } public function getConnection($name) { if ( ! isset($this->connections[$name])) { throw new Doctrine_Manager_Exception('Unknown connection: ' . $name); } return $this->connections[$name]; } public function bindComponent($componentName, $connectionName) { $this->bound[$componentName] = $connectionName; } public function getConnectionForComponent($componentName = null) { if (isset($this->bound[$componentName])) { return $this->getConnection($this->bound[$componentName]); } return $this->getCurrentConnection(); } public function getTable($componentName) { return $this->getConnectionForComponent($componentName)->getTable($componentName); } public function closeConnection(Doctrine_Connection $connection) { $connection->close(); unset($connection); } public function getConnections() { return $this->connections; } public function setCurrentConnection($key) { $key = (string) $key; if ( ! isset($this->connections[$key])) { throw new InvalidKeyException(); } $this->currIndex = $key; } public function contains($key) { return isset($this->connections[$key]); } public function count() { return count($this->connections); } public function getIterator() { return new ArrayIterator($this->connections); } public function getCurrentConnection() { $i = $this->currIndex; if ( ! isset($this->connections[$i])) { throw new Doctrine_Connection_Exception(); } return $this->connections[$i]; } public function __toString() { $r[] = "<pre>"; $r[] = "Doctrine_Manager"; $r[] = "Connections : ".count($this->connections); $r[] = "</pre>"; return implode("\n",$r); } } final class Doctrine_Null { } interface Doctrine_Overloadable { public function __call($m, $a); } class Doctrine_Query extends Doctrine_Hydrate implements Countable { const SELECT = 0; const DELETE = 1; const UPDATE = 2; private $subqueryAliases = array(); private $needsSubquery = false; private $limitSubqueryUsed = false; private $isSubquery; private $tableStack; private $relationStack = array(); private $isDistinct = false; protected $components = array(); private $neededTables = array(); private $pendingFields = array(); protected $type = self::SELECT; public static function create() { return new Doctrine_Query(); } public function isSubquery($bool = null) { if ($bool === null) { return $this->isSubquery; } $this->isSubquery = (bool) $bool; return $this; } public function getAggregateAlias($dqlAlias) { if(isset($this->aggregateMap[$dqlAlias])) { return $this->aggregateMap[$dqlAlias]; } return null; } public function getTableStack() { return $this->tableStack; } public function getRelationStack() { return $this->relationStack; } public function isDistinct($distinct = null) { if(isset($distinct)) $this->isDistinct = (bool) $distinct; return $this->isDistinct; } public function processPendingFields($componentAlias) { $tableAlias = $this->getTableAlias($componentAlias); if ( ! isset($this->tables[$tableAlias])) throw new Doctrine_Query_Exception('Unknown component path '.$componentPath); $table = $this->tables[$tableAlias]; if (isset($this->pendingFields[$componentAlias])) { $fields = $this->pendingFields[$componentAlias]; if(in_array('*', $fields)) { $fields = $table->getColumnNames(); } else { if ( ! $this->isSubquery) { $fields = array_unique(array_merge($table->getPrimaryKeys(), $fields)); } } } foreach ($fields as $name) { $name = $table->getColumnName($name); $this->parts["select"][] = $tableAlias . '.' .$name . ' AS ' . $tableAlias . '__' . $name; } $this->neededTables[] = $tableAlias; } public function parseSelect($dql) { $refs = Doctrine_Query::bracketExplode($dql, ','); foreach($refs as $reference) { if(strpos($reference, '(') !== false) { $this->parseAggregateFunction2($reference); } else { $e = explode('.', $reference); if(count($e) > 2) $this->pendingFields[] = $reference; else $this->pendingFields[$e[0]][] = $e[1]; } } } public function parseAggregateFunction2($func) { $e = Doctrine_Query::bracketExplode($func, ' '); $func = $e[0]; $pos = strpos($func, '('); $name = substr($func, 0, $pos); if(method_exists($this->conn->expression, $name)) { $argStr = substr($func, ($pos + 1), -1); $args = explode(',', $argStr); $func = call_user_func_array(array($this->conn->expression, $name), $args); if(substr($func, 0, 1) !== '(') { $pos = strpos($func, '('); $name = substr($func, 0, $pos); } else { $name = $func; } $e2 = explode(' ', $args[0]); $distinct = ''; if(count($e2) > 1) { if(strtoupper($e2[0]) == 'DISTINCT') $distinct = 'DISTINCT '; $args[0] = $e2[1]; } $parts = explode('.', $args[0]); $owner = $parts[0]; $alias = (isset($e[1])) ? $e[1] : $name; $e3 = explode('.', $alias); if(count($e3) > 1) { $alias = $e3[1]; $owner = $e3[0]; } if ($owner === '') { $owner = 0; } $this->pendingAggregates[$owner][] = array($name, $args, $distinct, $alias); } else { throw new Doctrine_Query_Exception('Unknown function '.$name); } } public function processPendingAggregates($componentAlias) { $tableAlias = $this->getTableAlias($componentAlias); if ( ! isset($this->tables[$tableAlias])) { throw new Doctrine_Query_Exception('Unknown component path ' . $componentPath); } $root = current($this->tables); $table = $this->tables[$tableAlias]; $aggregates = array(); if(isset($this->pendingAggregates[$componentAlias])) { $aggregates = $this->pendingAggregates[$componentAlias]; } if ($root === $table) { if (isset($this->pendingAggregates[0])) { $aggregates += $this->pendingAggregates[0]; } } foreach($aggregates as $parts) { list($name, $args, $distinct, $alias) = $parts; $arglist = array(); foreach($args as $arg) { $e = explode('.', $arg); if(count($e) > 1) { $table = $this->tables[$tableAlias]; $e[1] = $table->getColumnName($e[1]); if( ! $table->hasColumn($e[1])) { throw new Doctrine_Query_Exception('Unknown column ' . $e[1]); } $arglist[] = $tableAlias . '.' . $e[1]; } else { $arglist[] = $e[0]; } } $sqlAlias = $tableAlias . '__' . count($this->aggregateMap); if(substr($name, 0, 1) !== '(') { $this->parts['select'][] = $name . '(' . $distinct . implode(', ', $arglist) . ') AS ' . $sqlAlias; } else { $this->parts['select'][] = $name . ' AS ' . $sqlAlias; } $this->aggregateMap[$alias] = $sqlAlias; $this->neededTables[] = $tableAlias; } } public function count($params = array()) { $this->remove('select'); $join = $this->join; $where = $this->where; $having = $this->having; $table = reset($this->tables); $q = 'SELECT COUNT(DISTINCT ' . $this->aliasHandler->getShortAlias($table->getTableName()) . '.' . $table->getIdentifier() . ') FROM ' . $table->getTableName() . ' ' . $this->aliasHandler->getShortAlias($table->getTableName()); foreach($join as $j) { $q .= ' '.implode(' ',$j); } $string = $this->applyInheritance(); if( ! empty($where)) { $q .= ' WHERE ' . implode(' AND ', $where); if( ! empty($string)) $q .= ' AND (' . $string . ')'; } else { if( ! empty($string)) $q .= ' WHERE (' . $string . ')'; } if( ! empty($having)) $q .= ' HAVING ' . implode(' AND ',$having); if( ! is_array($params)) $params = array($params); $params = array_merge($this->params, $params); return (int) $this->getConnection()->fetchOne($q, $params); } protected function loadFields(Doctrine_Table $table, $fetchmode, array $names, $cpath) { $name = $table->getComponentName(); switch($fetchmode): case Doctrine::FETCH_OFFSET: $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); case Doctrine::FETCH_IMMEDIATE: if( ! empty($names)) { $names = array_unique(array_merge($table->getPrimaryKeys(), $names)); } else { $names = $table->getColumnNames(); } break; case Doctrine::FETCH_LAZY_OFFSET: $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); case Doctrine::FETCH_LAZY: case Doctrine::FETCH_BATCH: $names = array_unique(array_merge($table->getPrimaryKeys(), $names)); break; default: throw new Doctrine_Exception("Unknown fetchmode."); endswitch; $component = $table->getComponentName(); $tablename = $this->tableAliases[$cpath]; $this->fetchModes[$tablename] = $fetchmode; $count = count($this->tables); foreach($names as $name) { if($count == 0) { $this->parts['select'][] = $tablename . '.' . $name; } else { $this->parts['select'][] = $tablename . '.' . $name . ' AS ' . $tablename . '__' . $name; } } } public function addFrom($from) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse($from); return $this; } public function leftJoin($join) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse('LEFT JOIN ' . $join); return $this; } public function innerJoin($join) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse('INNER JOIN ' . $join); return $this; } public function addOrderBy($orderby) { $class = 'Doctrine_Query_Orderby'; $parser = new $class($this); $this->parts['orderby'][] = $parser->parse($orderby); return $this; } public function addWhere($where, $params = array()) { $class = 'Doctrine_Query_Where'; $parser = new $class($this); $this->parts['where'][] = $parser->parse($where); if(is_array($params)) { $this->params = array_merge($this->params, $params); } else { $this->params[] = $params; } } public function __call($name, $args) { $name = strtolower($name); $method = 'parse' . ucwords($name); switch($name) { case 'select': $this->type = self::SELECT; if( ! isset($args[0])) throw new Doctrine_Query_Exception('Empty select part'); $this->parseSelect($args[0]); break; case 'delete': $this->type = self::DELETE; break; case 'update': $this->type = self::UPDATE; $name = 'from'; case 'from': $this->parts['from'] = array(); $this->parts['select'] = array(); $this->parts['join'] = array(); $this->joins = array(); $this->tables = array(); $this->fetchModes = array(); $this->tableIndexes = array(); $this->tableAliases = array(); $this->aliasHandler->clear(); $class = "Doctrine_Query_".ucwords($name); $parser = new $class($this); $parser->parse($args[0]); break; case 'where': if(isset($args[1])) { if(is_array($args[1])) { $this->params = $args[1]; } else { $this->params = array($args[1]); } } case 'having': case 'orderby': case 'groupby': $class = "Doctrine_Query_".ucwords($name); $parser = new $class($this); $this->parts[$name] = array($parser->parse($args[0])); break; case 'limit': case 'offset': if($args[0] == null) $args[0] = false; $this->parts[$name] = $args[0]; break; default: $this->parts[$name] = array(); $this->$method($args[0]); throw new Doctrine_Query_Exception("Unknown overload method"); } return $this; } public function get($name) { if( ! isset($this->parts[$name])) return false; return $this->parts[$name]; } public function set($name, $value) { $class = new Doctrine_Query_Set($this); $this->parts['set'][] = $class->parse($name . ' = ' . $value); return $this; } public function isLimitSubqueryUsed() { return $this->limitSubqueryUsed; } public function getQueryBase() { switch ($this->type) { case self::DELETE: if ($this->conn->getName() == 'Mysql') { $q = 'DELETE ' .end($this->tableAliases) . ' FROM '; } else { $q = 'DELETE FROM '; } break; case self::UPDATE: $q = 'UPDATE '; break; case self::SELECT: $distinct = ($this->isDistinct()) ? 'DISTINCT ' : ''; $q = 'SELECT '.$distinct.implode(', ', $this->parts['select']).' FROM '; break; } return $q; } public function getQuery($params = array()) { if(empty($this->parts["select"]) || empty($this->parts["from"])) return false; $needsSubQuery = false; $subquery = ''; $k = array_keys($this->tables); $table = $this->tables[$k[0]]; if( ! empty($this->parts['limit']) && $this->needsSubquery && $table->getAttribute(Doctrine::ATTR_QUERY_LIMIT) == Doctrine::LIMIT_RECORDS) { $needsSubQuery = true; $this->limitSubqueryUsed = true; } $str = ''; if($this->isDistinct()) $str = 'DISTINCT '; $q = $this->getQueryBase(); $q .= $this->parts['from']; foreach($this->parts['join'] as $parts) { foreach($parts as $part) { if(substr($part, 0,9) === 'LEFT JOIN') { $e = explode(' ', $part); $aliases = array_merge($this->subqueryAliases, array_keys($this->neededTables)); if( ! in_array($e[3], $aliases) && ! in_array($e[2], $aliases) && ! empty($this->pendingFields)) { continue; } } $e = explode(' ON ', $part); $e2 = explode(' AND ', $e[1]); $part = $e[0] . ' ON ' . array_shift($e2); if( ! empty($e2)) { $parser = new Doctrine_Query_JoinCondition($this); $part .= ' AND ' . $parser->parse(implode(' AND ', $e2)); } $q .= ' ' . $part; } } if( ! empty($this->parts['set'])) { $q .= ' SET ' . implode(', ', $this->parts['set']); } $string = $this->applyInheritance(); if( ! empty($string)) $this->parts['where'][] = '('.$string.')'; $modifyLimit = true; if( ! empty($this->parts["limit"]) || ! empty($this->parts["offset"])) { if($needsSubQuery) { $subquery = $this->getLimitSubquery(); switch(strtolower($this->conn->getName())) { case 'mysql': $params = array_merge($this->params, $params); $list = $this->conn->execute($subquery, $params)->fetchAll(PDO::FETCH_COLUMN); $subquery = implode(', ', $list); break; case 'pgsql': $subquery = 'SELECT doctrine_subquery_alias.' . $table->getIdentifier(). ' FROM (' . $subquery . ') AS doctrine_subquery_alias'; break; } $field = $this->aliasHandler->getShortAlias($table->getTableName()) . '.' . $table->getIdentifier(); if($subquery !== '') array_unshift($this->parts['where'], $field. ' IN (' . $subquery . ')'); $modifyLimit = false; } } $q .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ', $this->parts['where']):''; $q .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ', $this->parts['groupby']):''; $q .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' AND ', $this->parts['having']):''; $q .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(', ', $this->parts['orderby']):''; if($modifyLimit) $q = $this->conn->modifyLimitQuery($q, $this->parts['limit'], $this->parts['offset']); if( ! empty($string)) array_pop($this->parts['where']); if($needsSubQuery) array_shift($this->parts['where']); return $q; } public function getLimitSubquery() { $k = array_keys($this->tables); $table = $this->tables[$k[0]]; $alias = $this->aliasHandler->getShortAlias($table->getTableName()); $primaryKey = $alias . '.' . $table->getIdentifier(); $subquery = 'SELECT DISTINCT ' . $primaryKey; if($this->conn->getDBH()->getAttribute(PDO::ATTR_DRIVER_NAME) == 'pgsql') { foreach($this->parts['orderby'] as $part) { $e = explode(' ', $part); if($e[0] !== $primaryKey) $subquery .= ', ' . $e[0]; } } $subquery .= ' FROM ' . $this->conn->quoteIdentifier($table->getTableName()) . ' ' . $alias; foreach($this->parts['join'] as $parts) { foreach($parts as $part) { if(substr($part,0,9) === 'LEFT JOIN') { $e = explode(' ', $part); if( ! in_array($e[3], $this->subqueryAliases) && ! in_array($e[2], $this->subqueryAliases)) { continue; } } $subquery .= ' '.$part; } } $subquery .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ', $this->parts['where']) : ''; $subquery .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ', $this->parts['groupby']) : ''; $subquery .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' AND ', $this->parts['having']) : ''; $subquery .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(', ', $this->parts['orderby']) : ''; $subquery = $this->conn->modifyLimitQuery($subquery, $this->parts['limit'], $this->parts['offset']); $parts = self::quoteExplode($subquery, ' ', "'", "'"); foreach($parts as $k => $part) { if(strpos($part, "'") !== false) { continue; } if($this->aliasHandler->hasAliasFor($part)) { $parts[$k] = $this->aliasHandler->generateNewAlias($part); } if(strpos($part, '.') !== false) { $e = explode('.', $part); $trimmed = ltrim($e[0], '( '); $pos = strpos($e[0], $trimmed); $e[0] = substr($e[0], 0, $pos) . $this->aliasHandler->generateNewAlias($trimmed); $parts[$k] = implode('.', $e); } } $subquery = implode(' ', $parts); return $subquery; } public function query($query,$params = array()) { $this->parseQuery($query); if($this->aggregate) { $keys = array_keys($this->tables); $query = $this->getQuery(); $stmt = $this->tables[$keys[0]]->getConnection()->select($query, $this->parts["limit"], $this->parts["offset"]); $data = $stmt->fetch(PDO::FETCH_ASSOC); if(count($data) == 1) { return current($data); } else { return $data; } } else { return $this->execute($params); } } public function splitQuery($query) { $e = self::sqlExplode($query, ' '); foreach($e as $k=>$part) { $part = trim($part); switch(strtolower($part)) { case 'delete': case 'update': case 'select': case 'set': case 'from': case 'where': case 'limit': case 'offset': case 'having': $p = $part; $parts[$part] = array(); break; case 'order': case 'group': $i = ($k + 1); if(isset($e[$i]) && strtolower($e[$i]) === "by") { $p = $part; $parts[$part] = array(); } else $parts[$p][] = $part; break; case "by": continue; default: if( ! isset($p)) throw new Doctrine_Query_Exception("Couldn't parse query."); $parts[$p][] = $part; } } return $parts; } public function parseQuery($query, $clear = true) { if($clear) $this->clear(); $query = trim($query); $query = str_replace("\n", ' ', $query); $query = str_replace("\r", ' ', $query); $parts = $this->splitQuery($query); foreach($parts as $k => $part) { $part = implode(" ",$part); switch(strtoupper($k)) { case 'DELETE': $this->type = self::DELETE; break; case 'SELECT': $this->type = self::SELECT; $this->parseSelect($part); break; case 'UPDATE': $this->type = self::UPDATE; $k = 'FROM'; case 'FROM': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $parser->parse($part); break; case 'SET': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $this->parts['set'][] = $parser->parse($part); break; case 'GROUP': case 'ORDER': $k .= 'by'; case 'WHERE': case 'HAVING': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $name = strtolower($k); $this->parts[$name][] = $parser->parse($part); break; case 'LIMIT': $this->parts['limit'] = trim($part); break; case 'OFFSET': $this->parts['offset'] = trim($part); break; } } return $this; } final public function parseOrderBy($str) { $parser = new Doctrine_Query_Part_Orderby($this); return $parser->parse($str); } final public function parseFetchMode($mode) { switch(strtolower($mode)): case "i": case "immediate": $fetchmode = Doctrine::FETCH_IMMEDIATE; break; case "b": case "batch": $fetchmode = Doctrine::FETCH_BATCH; break; case "l": case "lazy": $fetchmode = Doctrine::FETCH_LAZY; break; case "o": case "offset": $fetchmode = Doctrine::FETCH_OFFSET; break; case "lo": case "lazyoffset": $fetchmode = Doctrine::FETCH_LAZYOFFSET; default: throw new Doctrine_Query_Exception("Unknown fetchmode '$mode'. The availible fetchmodes are 'i', 'b' and 'l'."); endswitch; return $fetchmode; } public static function bracketTrim($str,$e1 = '(',$e2 = ')') { if(substr($str,0,1) == $e1 && substr($str,-1) == $e2) return substr($str,1,-1); else return $str; } public static function bracketExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if(is_array($d)) { $a = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $a = explode("$d",$str); $i = 0; $term = array(); foreach($a as $key=>$val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i], "$e1"); $s2 = substr_count($term[$i], "$e2"); if($s1 == $s2) $i++; } else { $term[$i] .= "$d".trim($val); $c1 = substr_count($term[$i], "$e1"); $c2 = substr_count($term[$i], "$e2"); if($c1 == $c2) $i++; } } return $term; } public static function quoteExplode($str, $d = ' ') { if(is_array($d)) { $a = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $a = explode("$d",$str); $i = 0; $term = array(); foreach($a as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); if( ! (substr_count($term[$i], "'") & 1)) $i++; } else { $term[$i] .= "$d".trim($val); if( ! (substr_count($term[$i], "'") & 1)) $i++; } } return $term; } public static function sqlExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if(is_array($d)) { $str = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $str = explode("$d",$str); $i = 0; $term = array(); foreach($str as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i],"$e1"); $s2 = substr_count($term[$i],"$e2"); if (substr($term[$i],0,1) == "(") { if($s1 == $s2) { $i++; } } else { if ( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1) && ! (substr_count($term[$i], "") & 1) ) { $i++; } } } else { $term[$i] .= "$d".trim($val); $c1 = substr_count($term[$i],"$e1"); $c2 = substr_count($term[$i],"$e2"); if(substr($term[$i],0,1) == "(") { if($c1 == $c2) { $i++; } } else { if ( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1) && ! (substr_count($term[$i], "") & 1) ) { $i++; } } } } return $term; } public function generateAlias($tableName) { if(isset($this->tableIndexes[$tableName])) { return $tableName.++$this->tableIndexes[$tableName]; } else { $this->tableIndexes[$tableName] = 1; return $tableName; } } final public function load($path, $loadFields = true) { $e = explode(' ON ', $path); $joinCondition = ''; if(count($e) > 1) { $joinCondition = ' AND ' . $e[1]; $path = $e[0]; } $tmp = explode(' ',$path); $componentAlias = (count($tmp) > 1) ? end($tmp) : false; $e = preg_split("/[.:]/", $tmp[0], -1); if(isset($this->compAliases[$e[0]])) { $end = substr($tmp[0], strlen($e[0])); $path = $this->compAliases[$e[0]] . $end; $e = preg_split("/[.:]/", $path, -1); } else { $path = $tmp[0]; } $index = 0; $currPath = ''; $this->tableStack = array(); foreach($e as $key => $fullname) { try { $e2 = preg_split("/[-(]/",$fullname); $name = $e2[0]; $currPath .= '.' . $name; if($key == 0) { $currPath = substr($currPath,1); $this->conn = Doctrine_Manager::getInstance() ->getConnectionForComponent($name); $table = $this->conn->getTable($name); $tname = $this->aliasHandler->getShortAlias($table->getTableName()); if( ! isset($this->tableAliases[$currPath])) { $this->tableIndexes[$tname] = 1; } $this->parts["from"] = $this->conn->quoteIdentifier($table->getTableName()) . ' ' . $tname; $this->tableAliases[$currPath] = $tname; $tableName = $tname; } else { $index += strlen($e[($key - 1)]) + 1; $mark = substr($path, ($index - 1), 1); if(isset($this->tableAliases[$prevPath])) { $tname = $this->tableAliases[$prevPath]; } else { $tname = $this->aliasHandler->getShortAlias($table->getTableName()); } $fk = $table->getRelation($name); $name = $fk->getTable()->getComponentName(); $original = $fk->getTable()->getTableName(); if (isset($this->tableAliases[$currPath])) { $tname2 = $this->tableAliases[$currPath]; } else { $tname2 = $this->aliasHandler->generateShortAlias($original); } $aliasString = $this->conn->quoteIdentifier($original) . ' ' . $tname2; switch ($mark) { case ':': $join = 'INNER JOIN '; break; case '.': $join = 'LEFT JOIN '; break; default: throw new Doctrine_Query_Exception("Unknown operator '$mark'"); } if( ! $fk->isOneToOne()) { $this->needsSubquery = true; } $map = $fk->getTable()->inheritanceMap; if( ! $loadFields || ! empty($map) || $joinCondition) { $this->subqueryAliases[] = $tname2; } if ($fk instanceof Doctrine_Relation_Association) { $asf = $fk->getAssociationFactory(); $assocTableName = $asf->getTableName(); if( ! $loadFields || ! empty($map) || $joinCondition) { $this->subqueryAliases[] = $assocTableName; } $assocPath = $prevPath . '.' . $asf->getComponentName(); if (isset($this->tableAliases[$assocPath])) { $assocAlias = $this->tableAliases[$assocPath]; } else { $assocAlias = $this->aliasHandler->generateShortAlias($assocTableName); } $this->parts['join'][$tname][$assocTableName] = $join . $assocTableName . ' ' . $assocAlias . ' ON ' . $tname . '.' . $table->getIdentifier() . ' = ' . $assocAlias . '.' . $fk->getLocal(); if ($fk instanceof Doctrine_Relation_Association_Self) { $this->parts['join'][$tname][$assocTableName] .= ' OR ' . $tname . '.' . $table->getIdentifier() . ' = ' . $assocAlias . '.' . $fk->getForeign(); } $this->parts['join'][$tname][$tname2] = $join . $aliasString . ' ON ' . $tname2 . '.' . $fk->getTable()->getIdentifier() . ' = ' . $assocAlias . '.' . $fk->getForeign() . $joinCondition; if ($fk instanceof Doctrine_Relation_Association_Self) { $this->parts['join'][$tname][$tname2] .= ' OR ' . $tname2 . '.' . $table->getIdentifier() . ' = ' . $assocAlias . '.' . $fk->getLocal(); } } else { $this->parts['join'][$tname][$tname2] = $join . $aliasString . ' ON ' . $tname . '.' . $fk->getLocal() . ' = ' . $tname2 . '.' . $fk->getForeign() . $joinCondition; } $this->joins[$tname2] = $prevTable; $table = $fk->getTable(); $this->tableAliases[$currPath] = $tname2; $tableName = $tname2; $this->relationStack[] = $fk; } $this->components[$currPath] = $table; $this->tableStack[] = $table; if( ! isset($this->tables[$tableName])) { $this->tables[$tableName] = $table; if ($loadFields) { $skip = false; if ( ! empty($this->pendingFields) || ! empty($this->pendingAggregates)) { $skip = true; } if ($componentAlias) { $this->compAliases[$componentAlias] = $currPath; if(isset($this->pendingFields[$componentAlias])) { $this->processPendingFields($componentAlias); $skip = true; } if(isset($this->pendingAggregates[$componentAlias]) || (current($this->tables) === $table && isset($this->pendingAggregates[0])) ) { $this->processPendingAggregates($componentAlias); $skip = true; } } if ( ! $skip) { $this->parseFields($fullname, $tableName, $e2, $currPath); } } } $prevPath = $currPath; $prevTable = $tableName; } catch(Exception $e) { throw new Doctrine_Query_Exception($e->__toString()); } } if($componentAlias !== false) { $this->compAliases[$componentAlias] = $currPath; } return $table; } final public function parseFields($fullName, $tableName, array $exploded, $currPath) { $table = $this->tables[$tableName]; $fields = array(); if(strpos($fullName, '-') === false) { $fetchmode = $table->getAttribute(Doctrine::ATTR_FETCHMODE); if(isset($exploded[1])) { if(count($exploded) > 2) { $fields = $this->parseAggregateValues($fullName, $tableName, $exploded, $currPath); } elseif(count($exploded) == 2) { $fields = explode(',',substr($exploded[1],0,-1)); } } } else { if(isset($exploded[1])) { $fetchmode = $this->parseFetchMode($exploded[1]); } else $fetchmode = $table->getAttribute(Doctrine::ATTR_FETCHMODE); if(isset($exploded[2])) { if(substr_count($exploded[2], ')') > 1) { } else { $fields = explode(',', substr($exploded[2],0,-1)); } } } if( ! $this->aggregate) $this->loadFields($table, $fetchmode, $fields, $currPath); } public function parseAggregateFunction($func,$reference) { $pos = strpos($func, '('); if($pos !== false) { $funcs = array(); $name = substr($func, 0, $pos); $func = substr($func, ($pos + 1), -1); $params = Doctrine_Query::bracketExplode($func, ',', '(', ')'); foreach($params as $k => $param) { $params[$k] = $this->parseAggregateFunction($param,$reference); } $funcs = $name . '(' . implode(', ', $params). ')'; return $funcs; } else { if( ! is_numeric($func)) { $func = $this->getTableAlias($reference).'.'.$func; return $func; } else { return $func; } } } public function parseAggregateValues($fullName, $tableName, array $exploded, $currPath) { $this->aggregate = true; $pos = strpos($fullName, '('); $name = substr($fullName, 0, $pos); $string = substr($fullName, ($pos + 1), -1); $exploded = Doctrine_Query::bracketExplode($string, ','); foreach($exploded as $k => $value) { $func = $this->parseAggregateFunction($value, $currPath); $exploded[$k] = $func; $this->parts['select'][] = $exploded[$k]; } } } abstract class Doctrine_Query_Part extends Doctrine_Access { protected $query; protected $name; protected $parts = array(); public function __construct(Doctrine_Query $query) { $this->query = $query; } public function getName() { return $this->name; } public function getQuery() { return $this->query; } public function add($value) { $method = "parse".$this->name; $this->query->$method($value); } public function get($name) { } public function set($name, $value) { } } abstract class Doctrine_Query_Condition extends Doctrine_Query_Part { final public function parse($str) { $tmp = trim($str); $parts = Doctrine_Query::bracketExplode($str, array(' \&\& ', ' AND '), '(', ')'); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $part = Doctrine_Query::bracketTrim($part, '(', ')'); $ret[] = $this->parse($part); } $r = implode(' AND ',$ret); } else { $parts = Doctrine_Query::bracketExplode($str, array(' \|\| ', ' OR '), '(', ')'); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $part = Doctrine_Query::bracketTrim($part, '(', ')'); $ret[] = $this->parse($part); } $r = implode(' OR ', $ret); } else { if (substr($parts[0],0,1) == '(' && substr($parts[0],-1) == ')') { return $this->parse(substr($parts[0],1,-1)); } else { return $this->load($parts[0]); } } } return '(' . $r . ')'; } public function parseLiteralValue($value) { if (strpos($value, '\'') === false) { $value = $this->query->getConnection() ->dataDict->parseBoolean($value); $a = explode('.', $value); if (count($a) > 1) { if ( ! is_numeric($a[0])) { $value = $this->query->getTableAlias($a[0]). '.' . $a[1]; } } } else { } return $value; } } class Doctrine_Query_Exception extends Doctrine_Exception { } class Doctrine_Query_From extends Doctrine_Query_Part { final public function parse($str) { $str = trim($str); $parts = Doctrine_Query::bracketExplode($str, 'JOIN'); $operator = false; switch (trim($parts[0])) { case 'INNER': $operator = ':'; case 'LEFT': array_shift($parts); } $last = ''; foreach ($parts as $k => $part) { $part = trim($part); if (empty($part)) { continue; } $e = explode(' ', $part); if (end($e) == 'INNER' || end($e) == 'LEFT') { $last = array_pop($e); } $part = implode(' ', $e); foreach (Doctrine_Query::bracketExplode($part, ',') as $reference) { $reference = trim($reference); $e = explode('.', $reference); if ($operator) { $reference = array_shift($e) . $operator . implode('.', $e); } $table = $this->query->load($reference); } $operator = ($last == 'INNER') ? ':' : '.'; } } public function __toString() { return ( ! empty($this->parts))?implode(", ", $this->parts):''; } } class Doctrine_Query_Groupby extends Doctrine_Query_Part { final public function parse($str) { $r = array(); foreach (explode(',', $str) as $reference) { $reference = trim($reference); $e = explode('.', $reference); $field = array_pop($e); $ref = implode('.', $e); $table = $this->query->load($ref); $component = $table->getComponentName(); $r[] = $this->query->getTableAlias($ref).".".$field; } return implode(', ', $r); } public function __toString() { return ( ! empty($this->parts))?implode(", ", $this->parts):''; } } class Doctrine_Query_Having extends Doctrine_Query_Condition { private function parseAggregateFunction($func) { $pos = strpos($func, '('); if ($pos !== false) { $funcs = array(); $name = substr($func, 0, $pos); $func = substr($func, ($pos + 1), -1); $params = Doctrine_Query::bracketExplode($func, ',', '(', ')'); foreach ($params as $k => $param) { $params[$k] = $this->parseAggregateFunction($param); } $funcs = $name . '(' . implode(', ', $params) . ')'; return $funcs; } else { if ( ! is_numeric($func)) { $a = explode('.', $func); $field = array_pop($a); $reference = implode('.', $a); $table = $this->query->load($reference, false); $field = $table->getColumnName($field); $func = $this->query->getTableAlias($reference) . '.' . $field; return $func; } else { return $func; } } } final public function load($having) { $e = Doctrine_Query::bracketExplode($having, ' ', '(', ')'); $r = array_shift($e); $t = explode('(', $r); $count = count($t); $r = $this->parseAggregateFunction($r); $operator = array_shift($e); $value = implode(' ', $e); $r .= ' ' . $operator . ' ' . $value; return $r; } public function __toString() { return ( ! empty($this->parts))?implode(' AND ', $this->parts):''; } } class Doctrine_Query_JoinCondition extends Doctrine_Query_Condition { public function load($condition) { $condition = trim($condition); $e = Doctrine_Query::sqlExplode($condition); if(count($e) > 2) { $a = explode('.', $e[0]); $field = array_pop($a); $reference = implode('.', $a); $operator = $e[1]; $value = $e[2]; $alias = $this->query->getTableAlias($reference); $table = $this->query->getTable($alias); $enumIndex = $table->enumIndex($field, trim($value, "'")); if (substr($value, 0, 1) == '(') { $trimmed = Doctrine_Query::bracketTrim($value); if (substr($trimmed, 0, 4) == 'FROM' || substr($trimmed, 0, 6) == 'SELECT') { $q = new Doctrine_Query(); $value = '(' . $q->parseQuery($trimmed)->getQuery() . ')'; } elseif (substr($trimmed, 0, 4) == 'SQL:') { $value = '(' . substr($trimmed, 4) . ')'; } else { $e = Doctrine_Query::sqlExplode($trimmed, ','); $value = array(); foreach ($e as $part) { $index = $table->enumIndex($field, trim($part, "'")); if ($index !== false) { $value[] = $index; } else { $value[] = $this->parseLiteralValue($part); } } $value = '(' . implode(', ', $value) . ')'; } } else { if ($enumIndex !== false) { $value = $enumIndex; } else { $value = $this->parseLiteralValue($value); } } switch ($operator) { case '<': case '>': case '=': case '!=': if ($enumIndex !== false) { $value = $enumIndex; } default: $condition = $alias . '.' . $field . ' ' . $operator . ' ' . $value; } } return $condition; } } class Doctrine_Query_Orderby extends Doctrine_Query_Part { public function parse($str) { $ret = array(); foreach (explode(',', trim($str)) as $r) { $r = trim($r); $e = explode(' ', $r); $a = explode('.', $e[0]); if (count($a) > 1) { $field = array_pop($a); $reference = implode('.', $a); $name = end($a); $this->query->load($reference, false); $alias = $this->query->getTableAlias($reference); $tname = $this->query->getTable($alias)->getTableName(); $r = $alias . '.' . $field; } else { $field = $this->query->getAggregateAlias($e[0]); $r = $field; } if (isset($e[1])) { $r .= ' ' . $e[1]; } $ret[] = $r; } return implode(', ', $ret); } public function __toString() { return ( ! empty($this->parts))?implode(', ', $this->parts):''; } } class Doctrine_Query_Set extends Doctrine_Query_Part { public function parse($dql) { $parts = Doctrine_Query::sqlExplode($dql, ','); $result = array(); foreach ($parts as $part) { $set = Doctrine_Query::sqlExplode($part, '='); $e = explode('.', trim($set[0])); $field = array_pop($e); $reference = implode('.', $e); $alias = $this->query->getTableAlias($reference); $fieldname = $alias ? $alias . '.' . $field : $field; $result[] = $fieldname . ' = ' . $set[1]; } return implode(', ', $result); } } class Doctrine_Query_Where extends Doctrine_Query_Condition { public function load($where) { $where = trim($where); $e = Doctrine_Query::sqlExplode($where); if (count($e) > 1) { $tmp = $e[0] . ' ' . $e[1]; if (substr($tmp, 0, 6) == 'EXISTS') { return $this->parseExists($where, true); } elseif (substr($where, 0, 10) == 'NOT EXISTS') { return $this->parseExists($where, false); } } if (count($e) < 3) { $e = Doctrine_Query::sqlExplode($where, array('=', '<', '>', '!=')); } $r = array_shift($e); $a = explode('.', $r); if (count($a) > 1) { $field = array_pop($a); $count = count($e); $slice = array_slice($e, -1, 1); $value = implode('', $slice); $operator = trim(substr($where, strlen($r), -strlen($value))); $reference = implode('.', $a); $count = count($a); $pos = strpos($field, '('); if ($pos !== false) { $func = substr($field, 0, $pos); $value = trim(substr($field, ($pos + 1), -1)); $values = Doctrine_Query::sqlExplode($value, ','); $field = array_pop($a); $reference = implode('.', $a); $table = $this->query->load($reference, false); $field = $table->getColumnName($field); array_pop($a); $reference2 = implode('.', $a); $alias = $this->query->getTableAlias($reference2); $stack = $this->query->getRelationStack(); $relation = end($stack); $stack = $this->query->getTableStack(); switch ($func) { case 'contains': case 'regexp': case 'like': $operator = $this->getOperator($func); if (empty($relation)) { throw new Doctrine_Query_Exception('DQL functions contains/regexp/like can only be used for fields of related components'); } $where = array(); foreach ($values as $value) { $where[] = $alias . '.' . $relation->getLocal() . ' IN (SELECT '.$relation->getForeign() . ' FROM ' . $relation->getTable()->getTableName() . ' WHERE ' . $field . $operator . $value . ')'; } $where = implode(' AND ', $where); break; default: throw new Doctrine_Query_Exception('Unknown DQL function: '.$func); } } else { $table = $this->query->load($reference, false); $alias = $this->query->getTableAlias($reference); $table = $this->query->getTable($alias); $field = $table->getColumnName($field); $enumIndex = $table->enumIndex($field, trim($value, "'")); if (substr($value, 0, 1) == '(') { $trimmed = Doctrine_Query::bracketTrim($value); if (substr($trimmed, 0, 4) == 'FROM' || substr($trimmed, 0, 6) == 'SELECT') { $q = new Doctrine_Query(); $value = '(' . $q->isSubquery(true)->parseQuery($trimmed)->getQuery() . ')'; } elseif (substr($trimmed, 0, 4) == 'SQL:') { $value = '(' . substr($trimmed, 4) . ')'; } else { $e = Doctrine_Query::sqlExplode($trimmed, ','); $value = array(); foreach ($e as $part) { $index = $table->enumIndex($field, trim($part, "'")); if ($index !== false) { $value[] = $index; } else { $value[] = $this->parseLiteralValue($part); } } $value = '(' . implode(', ', $value) . ')'; } } else { if ($enumIndex !== false) { $value = $enumIndex; } else { $value = $this->parseLiteralValue($value); } } switch ($operator) { case '<': case '>': case '=': case '!=': if ($enumIndex !== false) { $value = $enumIndex; } default: $fieldname = $alias ? $alias . '.' . $field : $field; $where = $fieldname . ' ' . $operator . ' ' . $value; } } } return $where; } public function parseExists($where, $negation) { $operator = ($negation) ? 'EXISTS' : 'NOT EXISTS'; $pos = strpos($where, '('); if ($pos == false) throw new Doctrine_Query_Exception("Unknown expression, expected '('"); $sub = Doctrine_Query::bracketTrim(substr($where, $pos)); return $operator . ' ('.$this->query->createSubquery()->parseQuery($sub, false)->getQuery() . ')'; } public function getOperator($func) { switch ($func) { case 'contains': $operator = ' = '; break; case 'regexp': $operator = $this->query->getConnection()->getRegexpOperator(); break; case 'like': $operator = ' LIKE '; break; } return $operator; } public function __toString() { return ( ! empty($this->parts))?implode(' AND ', $this->parts):''; } } class Doctrine_RawSql_Exception extends Doctrine_Exception { } class Doctrine_RawSql extends Doctrine_Hydrate { private $fields; public function __call($name, $args) { if ( ! isset($this->parts[$name])) { throw new Doctrine_RawSql_Exception("Unknown overload method $name. Availible overload methods are ".implode(" ",array_keys($this->parts))); } if ($name == 'select') { preg_match_all('/{([^}{]*)}/U', $args[0], $m); $this->fields = $m[1]; $this->parts["select"] = array(); } else { $this->parts[$name][] = $args[0]; } return $this; } public function get($name) { if ( ! isset($this->parts[$name])) { throw new Doctrine_RawSql_Exception('Unknown query part '.$name); } return $this->parts[$name]; } public function parseQuery($query) { preg_match_all('/{([^}{]*)}/U', $query, $m); $this->fields = $m[1]; $this->clear(); $e = Doctrine_Query::sqlExplode($query,' '); foreach ($e as $k => $part) { $low = strtolower($part); switch (strtolower($part)) { case "select": case "from": case "where": case "limit": case "offset": case "having": $p = $low; if ( ! isset($parts[$low])) { $parts[$low] = array(); } break; case "order": case "group": $i = ($k + 1); if (isset($e[$i]) && strtolower($e[$i]) === "by") { $p = $low; $p .= "by"; $parts[$low."by"] = array(); } else { $parts[$p][] = $part; } break; case "by": continue; default: if ( ! isset($parts[$p][0])) { $parts[$p][0] = $part; } else { $parts[$p][0] .= ' '.$part; } }; }; $this->parts = $parts; $this->parts["select"] = array(); return $this; } public function getQuery() { foreach ($this->fields as $field) { $e = explode(".", $field); if ( ! isset($e[1])) { throw new Doctrine_RawSql_Exception("All selected fields in Sql query must be in format tableAlias.fieldName"); } if ( ! isset($this->tables[$e[0]])) { try { $this->addComponent($e[0], ucwords($e[0])); } catch(Doctrine_Exception $exception) { throw new Doctrine_RawSql_Exception("The associated component for table alias $e[0] couldn't be found."); } } if ($e[1] == '*') { foreach ($this->tables[$e[0]]->getColumnNames() as $name) { $field = $e[0].".".$name; $this->parts["select"][$field] = $field." AS ".$e[0]."__".$name; } } else { $field = $e[0].".".$e[1]; $this->parts["select"][$field] = $field." AS ".$e[0]."__".$e[1]; } } foreach ($this->tableAliases as $alias) { foreach ($this->tables[$alias]->getPrimaryKeys() as $key) { $field = $alias . '.' . $key; if ( ! isset($this->parts["select"][$field])) { $this->parts["select"][$field] = $field." AS ".$alias."__".$key; } } } $q = 'SELECT '.implode(', ', $this->parts['select']); $string = $this->applyInheritance(); if ( ! empty($string)) { $this->parts['where'][] = $string; } $copy = $this->parts; unset($copy['select']); $q .= ( ! empty($this->parts['from']))? ' FROM ' . implode(' ', $this->parts['from']) : ''; $q .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ', $this->parts['where']) : ''; $q .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ', $this->parts['groupby']) : ''; $q .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' ', $this->parts['having']) : ''; $q .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(' ', $this->parts['orderby']) : ''; $q .= ( ! empty($this->parts['limit']))? ' LIMIT ' . implode(' ', $this->parts['limit']) : ''; $q .= ( ! empty($this->parts['offset']))? ' OFFSET ' . implode(' ', $this->parts['offset']) : ''; if ( ! empty($string)) { array_pop($this->parts['where']); } return $q; } public function getFields() { return $this->fields; } public function addComponent($tableAlias, $componentName) { $e = explode('.', $componentName); $currPath = ''; $table = null; foreach ($e as $k => $component) { $currPath .= '.' . $component; if ($k == 0) $currPath = substr($currPath,1); if (isset($this->tableAliases[$currPath])) { $alias = $this->tableAliases[$currPath]; } else { $alias = $tableAlias; } if ($table) { $tableName = $table->getAliasName($component); $table = $this->conn->getTable($tableName); } else { $table = $this->conn->getTable($component); } $this->tables[$alias] = $table; $this->fetchModes[$alias] = Doctrine::FETCH_IMMEDIATE; $this->tableAliases[$currPath] = $alias; if ($k !== 0) { $this->joins[$alias] = $prevAlias; } $prevAlias = $alias; $prevPath = $currPath; } return $this; } } abstract class Doctrine_Record extends Doctrine_Access implements Countable, IteratorAggregate, Serializable { const STATE_DIRTY = 1; const STATE_TDIRTY = 2; const STATE_CLEAN = 3; const STATE_PROXY = 4; const STATE_TCLEAN = 5; const STATE_DELETED = 6; protected $_table; protected $_node; protected $_id = array(); protected $_data = array(); protected $_values = array(); protected $_state; protected $_modified = array(); protected $_errorStack; private $references = array(); private $originals = array(); private static $index = 1; private static $null; private $oid; public function __construct($table = null, $isNewEntry = false) { if (isset($table) && $table instanceof Doctrine_Table) { $this->_table = $table; $exists = ( ! $isNewEntry); } else { $class = get_class($this); $this->_table = Doctrine_Manager::getInstance()->getConnectionForComponent($class)->getTable(get_class($this)); $exists = false; } if ($this->_table->getConnection()->hasTable($this->_table->getComponentName())) { $this->oid = self::$index; self::$index++; $keys = $this->_table->getPrimaryKeys(); if ( ! $exists) { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onPreCreate($this); } else { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onPreLoad($this); } $this->_data = $this->_table->getData(); $count = count($this->_data); $this->cleanData(); $this->prepareIdentifiers($exists); if ( ! $exists) { if ($count > 0) { $this->_state = Doctrine_Record::STATE_TDIRTY; } else { $this->_state = Doctrine_Record::STATE_TCLEAN; } $this->assignDefaultValues(); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onCreate($this); } else { $this->_state = Doctrine_Record::STATE_CLEAN; if ($count < $this->_table->getColumnCount()) { $this->_state = Doctrine_Record::STATE_PROXY; } $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); } $this->_errorStack = new Doctrine_Validator_ErrorStack(); $repository = $this->_table->getRepository(); $repository->add($this); } $this->construct(); } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public static function getNullObject() { return self::$null; } public function setUp() { } public function construct() { } public function getOID() { return $this->oid; } public function isValid() { if ( ! $this->_table->getAttribute(Doctrine::ATTR_VLD)) { return true; } $this->_errorStack->clear(); $validator = new Doctrine_Validator(); $validator->validateRecord($this); $this->validate(); if ($this->_state == self::STATE_TDIRTY || $this->_state == self::STATE_TCLEAN) { $this->validateOnInsert(); } else { $this->validateOnUpdate(); } return $this->_errorStack->count() == 0 ? true : false; } protected function validate() {} protected function validateOnUpdate() {} protected function validateOnInsert() {} public function getErrorStack() { return $this->_errorStack; } public function errorStack($stack = null) { if($stack !== null) { if( ! ($stack instanceof Doctrine_Validator_ErrorStack)) { throw new Doctrine_Record_Exception('Argument should be an instance of Doctrine_Validator_ErrorStack.'); } $this->_errorStack = $stack; } else { return $this->_errorStack; } } public function assignDefaultValues($overwrite = false) { if ( ! $this->_table->hasDefaultValues()) { return false; } foreach ($this->_data as $column => $value) { $default = $this->_table->getDefaultValueOf($column); if ($default === null) $default = self::$null; if ($value === self::$null || $overwrite) { $this->_data[$column] = $default; $this->_modified[] = $column; $this->_state = Doctrine_Record::STATE_TDIRTY; } } } private function cleanData($debug = false) { $tmp = $this->_data; $this->_data = array(); $count = 0; foreach ($this->_table->getColumnNames() as $name) { $type = $this->_table->getTypeOf($name); if ( ! isset($tmp[$name])) { $this->_data[$name] = self::$null; } else { switch ($type) { case "array": case "object": if ($tmp[$name] !== self::$null) { if (is_string($tmp[$name])) { $value = unserialize($tmp[$name]); if ($value === false) throw new Doctrine_Record_Exception("Unserialization of $name failed."); } else { $value = $tmp[$name]; } $this->_data[$name] = $value; } break; case "gzip": if ($tmp[$name] !== self::$null) { $value = gzuncompress($tmp[$name]); if ($value === false) throw new Doctrine_Record_Exception("Uncompressing of $name failed."); $this->_data[$name] = $value; } break; case "enum": $this->_data[$name] = $this->_table->enumValue($name, $tmp[$name]); break; default: $this->_data[$name] = $tmp[$name]; }; $count++; } } return $count; } private function prepareIdentifiers($exists = true) { switch ($this->_table->getIdentifierType()) { case Doctrine_Identifier::AUTO_INCREMENT: case Doctrine_Identifier::SEQUENCE: $name = $this->_table->getIdentifier(); if ($exists) { if (isset($this->_data[$name]) && $this->_data[$name] !== self::$null) { $this->_id[$name] = $this->_data[$name]; } } unset($this->_data[$name]); break; case Doctrine_Identifier::NORMAL: $this->_id = array(); $name = $this->_table->getIdentifier(); if (isset($this->_data[$name]) && $this->_data[$name] !== self::$null) { $this->_id[$name] = $this->_data[$name]; } break; case Doctrine_Identifier::COMPOSITE: $names = $this->_table->getIdentifier(); foreach ($names as $name) { if ($this->_data[$name] === self::$null) { $this->_id[$name] = null; } else { $this->_id[$name] = $this->_data[$name]; } } break; } } public function serialize() { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onSleep($this); $vars = get_object_vars($this); unset($vars['references']); unset($vars['originals']); unset($vars['_table']); $name = $this->_table->getIdentifier(); $this->_data = array_merge($this->_data, $this->_id); foreach ($this->_data as $k => $v) { if ($v instanceof Doctrine_Record) { unset($vars['_data'][$k]); } elseif ($v === self::$null) { unset($vars['_data'][$k]); } else { switch ($this->_table->getTypeOf($k)) { case "array": case "object": $vars['_data'][$k] = serialize($vars['_data'][$k]); break; } } } return serialize($vars); } public function unserialize($serialized) { $manager = Doctrine_Manager::getInstance(); $connection = $manager->getCurrentConnection(); $this->oid = self::$index; self::$index++; $this->_table = $connection->getTable(get_class($this)); $array = unserialize($serialized); foreach ($array as $name => $values) { $this->$name = $values; } $this->_table->getRepository()->add($this); $this->cleanData(); $this->prepareIdentifiers($this->exists()); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onWakeUp($this); } public function getState() { return $this->_state; } public function state($state = null) { if ($state == null) { return $this->_state; } $err = false; if (is_integer($state)) { if ($state >= 1 && $state <= 6) { $this->_state = $state; } else { $err = true; } } elseif (is_string($state)) { $upper = strtoupper($state); switch ($upper) { case 'DIRTY': case 'CLEAN': case 'TDIRTY': case 'TCLEAN': case 'PROXY': case 'DELETED': $this->_state = constant('Doctrine_Record::STATE_' . $upper); break; default: $err = true; } } if ($err) throw new Doctrine_Record_State_Exception('Unknown record state ' . $state); } final public function refresh() { $id = $this->obtainIdentifier(); if ( ! is_array($id)) { $id = array($id); } if (empty($id)) { return false; } $id = array_values($id); $query = $this->_table->getQuery()." WHERE ".implode(" = ? AND ",$this->_table->getPrimaryKeys())." = ?"; $stmt = $this->_table->getConnection()->execute($query,$id); $this->_data = $stmt->fetch(PDO::FETCH_ASSOC); if ( ! $this->_data) throw new Doctrine_Record_Exception('Failed to refresh. Record does not exist anymore'); $this->_data = array_change_key_case($this->_data, CASE_LOWER); $this->_modified = array(); $this->cleanData(true); $this->prepareIdentifiers(); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); return true; } final public function factoryRefresh() { $this->_data = $this->_table->getData(); $old = $this->_id; $this->cleanData(); $this->prepareIdentifiers(); if ($this->_id != $old) throw new Doctrine_Record_Exception("The refreshed primary key doesn't match the one in the record memory.", Doctrine::ERR_REFRESH); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); } final public function getTable() { return $this->_table; } final public function getData() { return $this->_data; } public function rawGet($name) { if ( ! isset($this->_data[$name])) { throw new Doctrine_Record_Exception('Unknown property '. $name); } if ($this->_data[$name] === self::$null) return null; return $this->_data[$name]; } public function load() { if ($this->_state == Doctrine_Record::STATE_PROXY) { $this->refresh(); $this->_state = Doctrine_Record::STATE_CLEAN; return true; } return false; } public function get($name, $invoke = true) { $listener = $this->_table->getAttribute(Doctrine::ATTR_LISTENER); $value = self::$null; $lower = strtolower($name); $lower = $this->_table->getColumnName($lower); if (isset($this->_data[$lower])) { if ($this->_data[$lower] === self::$null) { $this->load(); } if ($this->_data[$lower] === self::$null) { $value = null; } else { $value = $this->_data[$lower]; } } if ($value !== self::$null) { $value = $this->_table->invokeGet($this, $name, $value); if ($invoke && $name !== $this->_table->getIdentifier()) { return $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onGetProperty($this, $name, $value); } else { return $value; } } if (isset($this->_id[$lower])) { return $this->_id[$lower]; } if ($name === $this->_table->getIdentifier()) { return null; } if (isset($this->_values[$lower])) { return $this->_values[$lower]; } $rel = $this->_table->getRelation($name); try { if ( ! isset($this->references[$name])) { $this->loadReference($name); } } catch(Doctrine_Table_Exception $e) { throw new Doctrine_Record_Exception("Unknown property / related component '$name'."); } return $this->references[$name]; } public function mapValue($name, $value) { $name = strtolower($name); $this->_values[$name] = $value; } public function set($name, $value, $load = true) { $lower = strtolower($name); $lower = $this->_table->getColumnName($lower); if (isset($this->_data[$lower])) { if ($value instanceof Doctrine_Record) { $id = $value->getIncremented(); if ($id !== null) { $value = $id; } } if ($load) { $old = $this->get($lower, false); } else { $old = $this->_data[$lower]; } if ($old !== $value) { $value = $this->_table->invokeSet($this, $name, $value); $value = $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onSetProperty($this, $name, $value); if ($value === null) $value = self::$null; $this->_data[$lower] = $value; $this->_modified[] = $lower; switch ($this->_state) { case Doctrine_Record::STATE_CLEAN: $this->_state = Doctrine_Record::STATE_DIRTY; break; case Doctrine_Record::STATE_TCLEAN: $this->_state = Doctrine_Record::STATE_TDIRTY; break; }; } } else { try { $this->coreSetRelated($name, $value); } catch(Doctrine_Table_Exception $e) { throw new Doctrine_Record_Exception("Unknown property / related component '$name'."); } } } public function coreSetRelated($name, $value) { $rel = $this->_table->getRelation($name); if ($rel instanceof Doctrine_Relation_ForeignKey || $rel instanceof Doctrine_Relation_LocalKey) { if ( ! $rel->isOneToOne()) { if ( ! ($value instanceof Doctrine_Collection)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting one-to-many references."); } $value->setReference($this,$rel); } else { if ( ! ($value instanceof Doctrine_Record)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Record when setting one-to-one references."); } if ($rel instanceof Doctrine_Relation_LocalKey) { $this->set($rel->getLocal(), $value, false); } else { $value->set($rel->getForeign(), $this, false); } } } elseif ($rel instanceof Doctrine_Relation_Association) { if ( ! ($value instanceof Doctrine_Collection)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting many-to-many references."); } } $this->references[$name] = $value; } public function contains($name) { $lower = strtolower($name); if (isset($this->_data[$lower])) { return true; } if (isset($this->_id[$lower])) { return true; } if (isset($this->references[$name])) { return true; } return false; } public function __unset($name) { if (isset($this->_data[$name])) { $this->_data[$name] = array(); } } public function save(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } $conn->beginTransaction(); $saveLater = $conn->unitOfWork->saveRelated($this); if ($this->isValid()) { $conn->save($this); } else { $conn->transaction->addInvalid($this); } foreach ($saveLater as $fk) { $table = $fk->getTable(); $alias = $this->_table->getAlias($table->getComponentName()); if (isset($this->references[$alias])) { $obj = $this->references[$alias]; $obj->save(); } } $conn->unitOfWork->saveAssociations($this); $conn->commit(); } public function trySave(Doctrine_Connection $conn = null) { try { $this->save($conn); return true; } catch (Doctrine_Validator_Exception $ignored) { return false; } } public function replace(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } return $conn->replace($this->_table->getTableName(), $this->getPrepared(), $this->id); } public function getModified() { $a = array(); foreach ($this->_modified as $k => $v) { $a[$v] = $this->_data[$v]; } return $a; } public function getPrepared(array $array = array()) { $a = array(); if (empty($array)) { $array = $this->_modified; } foreach ($array as $k => $v) { $type = $this->_table->getTypeOf($v); if ($this->_data[$v] === self::$null) { $a[$v] = null; continue; } switch ($type) { case 'array': case 'object': $a[$v] = serialize($this->_data[$v]); break; case 'gzip': $a[$v] = gzcompress($this->_data[$v],5); break; case 'boolean': $a[$v] = (int) $this->_data[$v]; break; case 'enum': $a[$v] = $this->_table->enumIndex($v,$this->_data[$v]); break; default: if ($this->_data[$v] instanceof Doctrine_Record) $this->_data[$v] = $this->_data[$v]->getIncremented(); $a[$v] = $this->_data[$v]; } } $map = $this->_table->inheritanceMap; foreach ($map as $k => $v) { $old = $this->get($k, false); if ((string) $old !== (string) $v || $old === null) { $a[$k] = $v; $this->_data[$k] = $v; } } return $a; } public function count() { return count($this->_data); } public function columnCount() { return $this->count(); } public function toArray() { $a = array(); foreach ($this as $column => $value) { $a[$column] = $value; } if ($this->_table->getIdentifierType() == Doctrine_Identifier::AUTO_INCREMENT) { $i = $this->_table->getIdentifier(); $a[$i] = $this->getIncremented(); } return $a; } public function exists() { return ($this->_state !== Doctrine_Record::STATE_TCLEAN && $this->_state !== Doctrine_Record::STATE_TDIRTY); } public function hasRelation($name) { if (isset($this->_data[$name]) || isset($this->_id[$name])) { return true; } return $this->_table->hasRelation($name); } public function getIterator() { return new Doctrine_Record_Iterator($this); } public function obtainOriginals($name) { if (isset($this->originals[$name])) { return $this->originals[$name]; } return false; } public function delete(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->_table->getConnection(); } return $conn->delete($this); } public function copy() { $ret = $this->_table->create($this->_data); $modified = array(); foreach ($this->_data as $key => $val) { if (!($val instanceof Doctrine_Null)) { $ret->_modified[] = $key; } } return $ret; } final public function assignIdentifier($id = false) { if ($id === false) { $this->_id = array(); $this->cleanData(); $this->_state = Doctrine_Record::STATE_TCLEAN; $this->_modified = array(); } elseif ($id === true) { $this->prepareIdentifiers(false); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } else { $name = $this->_table->getIdentifier(); $this->_id[$name] = $id; $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } } public function assignOriginals($alias, Doctrine_Collection $coll) { $this->originals[$alias] = $coll; } final public function obtainIdentifier() { return $this->_id; } final public function getIncremented() { $id = current($this->_id); if ($id === false) return null; return $id; } public function getLast() { return $this; } public function hasReference($name) { return isset($this->references[$name]); } public function obtainReference($name) { if (isset($this->references[$name])) { return $this->references[$name]; } throw new Doctrine_Record_Exception("Unknown reference $name"); } public function initReference(Doctrine_Collection $coll, Doctrine_Relation $connector) { $alias = $connector->getAlias(); if (isset($this->references[$alias])) { return false; } if ( ! $connector->isOneToOne()) { if ( ! ($connector instanceof Doctrine_Relation_Association)) { $coll->setReference($this, $connector); } $this->references[$alias] = $coll; $this->originals[$alias] = clone $coll; return true; } return false; } public function lazyInitRelated(Doctrine_Collection $coll, Doctrine_Relation $connector) { } public function addReference(Doctrine_Record $record, Doctrine_Relation $connector, $key = null) { $alias = $connector->getAlias(); $this->references[$alias]->add($record, $key); $this->originals[$alias]->add($record, $key); } public function getReferences() { return $this->references; } final public function setRelated($alias, Doctrine_Access $coll) { $this->references[$alias] = $coll; $this->originals[$alias] = $coll; } final public function loadReference($name) { $fk = $this->_table->getRelation($name); if ($fk->isOneToOne()) { $this->references[$name] = $fk->fetchRelatedFor($this); } else { $coll = $fk->fetchRelatedFor($this); $this->references[$name] = $coll; $this->originals[$name] = clone $coll; } } final public function ownsOne($componentName, $foreignKey, $options = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::ONE_COMPOSITE, $options); } final public function ownsMany($componentName, $foreignKey, $options = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::MANY_COMPOSITE, $options); } final public function hasOne($componentName, $foreignKey, $options = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::ONE_AGGREGATE, $options); } final public function hasMany($componentName, $foreignKey, $options = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::MANY_AGGREGATE, $options); } final public function hasColumn($name, $type, $length = 2147483647, $options = "") { $this->_table->setColumn($name, $type, $length, $options); } public function countRelated($name) { $rel = $this->_table->getRelation($name); $componentName = $rel->getTable()->getComponentName(); $alias = $rel->getTable()->getAlias(get_class($this)); $query = new Doctrine_Query(); $query->from($componentName. '(' . 'COUNT(1)' . ')')->where($componentName. '.' .$alias. '.' . $this->getTable()->getIdentifier(). ' = ?'); $array = $query->execute(array($this->getIncremented())); return $array[0]['COUNT(1)']; } public function merge(array $values) { foreach ($this->_table->getColumnNames() as $value) { try { if (isset($values[$value])) { $this->set($value, $values[$value]); } } catch(Exception $e) { } } } public function setAttribute($attr, $value) { $this->_table->setAttribute($attr, $value); } public function setTableName($tableName) { $this->_table->setOption('tableName', $tableName); } public function setInheritanceMap($map) { $this->_table->setOption('inheritanceMap', $map); } public function setEnumValues($column, $values) { $this->_table->setEnumValues($column, $values); } public function attribute($attr, $value) { if ($value == null) { if (is_array($attr)) { foreach ($attr as $k => $v) { $this->_table->setAttribute($k, $v); } } else { return $this->_table->getAttribute($attr); } } else { $this->_table->setAttribute($attr, $value); } } public function option($name, $value = null) { if ($value == null) { if (is_array($name)) { foreach ($name as $k => $v) { $this->_table->setOption($k, $v); } } else { return $this->_table->getOption($name); } } else { $this->_table->setOption($name, $value); } } public function foreignKey(array $definition = array()) { return $this->_table->addForeignKey($definition); } public function index($name, array $definition = array()) { if ( ! $definition) { return $this->_table->getIndex($name); } else { return $this->_table->addIndex($name, $definition); } } public function addListener($listener, $name = null) { $this->_table->addListener($listener, $name = null); return $this; } public function getListener() { return $this->_table->getListener(); } public function setListener($listener) { $this->_table->setListener($listener); return $this; } public function call($callback, $column) { $args = func_get_args(); array_shift($args); if (isset($args[0])) { $column = $args[0]; $args[0] = $this->get($column); $newvalue = call_user_func_array($callback, $args); $this->_data[$column] = $newvalue; } return $this; } public function getNode() { if(!$this->_table->isTree()) return false; if(!isset($this->_node)) $this->_node = Doctrine_Node::factory($this, $this->getTable()->getOption('treeImpl'), $this->getTable()->getOption('treeOptions') ); return $this->_node; } public function deleteNode() { $this->getNode()->delete(); } public function __toString() { return Doctrine_Lib::getRecordAsString($this); } } class Doctrine_Record_Exception extends Doctrine_Exception { } class Doctrine_Record_Iterator extends ArrayIterator { private $record; private static $null; public function __construct(Doctrine_Record $record) { $this->record = $record; parent::__construct($record->getData()); } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function current() { $value = parent::current(); if ($value === self::$null) { return null; } else { return $value; } } } class Doctrine_Record_State_Exception extends Doctrine_Record_Exception { } abstract class Doctrine_Relation { const ONE_AGGREGATE = 0; const ONE_COMPOSITE = 1; const MANY_AGGREGATE = 2; const MANY_COMPOSITE = 3; const ONE = 0; const MANY = 1; protected $definition = array('alias' => true, 'foreign' => true, 'local' => true, 'class' => true, 'type' => true, 'name' => false, 'assocTable' => false, 'onDelete' => false, 'onUpdate' => false, 'deferred' => false, ); public function __construct(array $definition) { $def = array(); foreach ($this->definition as $key => $val) { if ( ! isset($definition[$key]) && $val) { throw new Doctrine_Exception($key . ' is required!'); } if (isset($definition[$key])) { $def[$key] = $definition[$key]; } } $this->definition = $def; } public function toArray() { return $this->definition; } final public function getAlias() { return $this->definition['alias']; } final public function getType() { return $this->definition['type']; } final public function getTable() { return Doctrine_Manager::connection()->getTable($this->definition['class']); } final public function getLocal() { return $this->definition['local']; } final public function getForeign() { return $this->definition['foreign']; } final public function isComposite() { return ($this->definition['type'] == Doctrine_Relation::ONE_COMPOSITE || $this->definition['type'] == Doctrine_Relation::MANY_COMPOSITE); } final public function isOneToOne() { return ($this->definition['type'] == Doctrine_Relation::ONE_AGGREGATE || $this->definition['type'] == Doctrine_Relation::ONE_COMPOSITE); } public function getRelationDql($count) { $component = $this->getTable()->getComponentName(); $dql = 'FROM ' . $component . ' WHERE ' . $component . '.' . $this->definition['foreign'] . ' IN (' . substr(str_repeat('?, ', $count), 0, -2) . ')'; return $dql; } public static function getDeleteOperations(Doctrine_Collection $old, Doctrine_Collection $new) { $r = array(); foreach ($old as $k => $record) { $id = $record->getIncremented(); if (empty($id)) { continue; } $found = false; foreach ($new as $k2 => $record2) { if ($record2->getIncremented() === $record->getIncremented()) { $found = true; break; } } if ( ! $found) { $r[] = $record; unset($old[$k]); } } return $r; } public static function getInsertOperations(Doctrine_Collection $old, Doctrine_Collection $new) { $r = array(); foreach ($new as $k => $record) { $found = false; $id = $record->getIncremented(); if ( ! empty($id)) { foreach ($old as $k2 => $record2) { if ($record2->getIncremented() === $record->getIncremented()) { $found = true; break; } } } if ( ! $found) { $old[] = $record; $r[] = $record; } } return $r; } abstract public function fetchRelatedFor(Doctrine_Record $record); public function __toString() { $r[] = "<pre>"; foreach ($this->definition as $k => $v) { if(is_object($v)) { $v = 'Object(' . get_class($v) . ')'; } $r[] = $k . ' : ' . $v; } $r[] = "</pre>"; return implode("\n", $r); } } class Doctrine_Relation_Association_Self extends Doctrine_Relation_Association { public function getRelationDql($count, $context = 'record') { switch ($context) { case 'record': $sub = 'SELECT '.$this->definition['foreign'] . ' FROM '.$this->definition['assocTable']->getTableName() . ' WHERE '.$this->definition['local'] . ' = ?'; $sub2 = 'SELECT '.$this->definition['local'] . ' FROM '.$this->definition['assocTable']->getTableName() . ' WHERE '.$this->definition['foreign'] . ' = ?'; $dql = 'FROM ' . $this->definition['table']->getComponentName() . '.' . $this->definition['assocTable']->getComponentName() . ' WHERE ' . $this->definition['table']->getComponentName() . '.' . $this->definition['table']->getIdentifier() . ' IN (' . $sub . ')' . ' || ' . $this->definition['table']->getComponentName() . '.' . $this->definition['table']->getIdentifier() . ' IN (' . $sub2 . ')'; break; case 'collection': $sub = substr(str_repeat('?, ', $count),0,-2); $dql = 'FROM '.$this->definition['assocTable']->getComponentName() . '.' . $this->definition['table']->getComponentName() . ' WHERE '.$this->definition['assocTable']->getComponentName() . '.' . $this->definition['local'] . ' IN (' . $sub . ')'; }; return $dql; } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); $q = new Doctrine_RawSql(); $assocTable = $this->getAssociationFactory()->getTableName(); $tableName = $record->getTable()->getTableName(); $identifier = $record->getTable()->getIdentifier(); $sub = 'SELECT '.$this->getForeign(). ' FROM '.$assocTable. ' WHERE '.$this->getLocal(). ' = ?'; $sub2 = 'SELECT '.$this->getLocal(). ' FROM '.$assocTable. ' WHERE '.$this->getForeign(). ' = ?'; $q->select('{'.$tableName.'.*}, {'.$assocTable.'.*}') ->from($tableName.' INNER JOIN '.$assocTable.' ON '. $tableName.'.'.$identifier.' = '.$assocTable.'.'.$this->getLocal().' OR '. $tableName.'.'.$identifier.' = '.$assocTable.'.'.$this->getForeign() ) ->where($tableName.'.'.$identifier.' IN ('.$sub.') OR '. $tableName.'.'.$identifier.' IN ('.$sub2.')' ); $q->addComponent($tableName, $record->getTable()->getComponentName()); $q->addComponent($assocTable, $record->getTable()->getComponentName(). '.' . $this->getAssociationFactory()->getComponentName()); return $q->execute(array($id, $id)); } } class Doctrine_Relation_Association extends Doctrine_Relation { public function getAssociationFactory() { return $this->definition['assocTable']; } public function processDiff(Doctrine_Record $record) { $asf = $this->getAssociationFactory(); $alias = $this->getAlias(); if ($record->hasReference($alias)) { $new = $record->obtainReference($alias); if ( ! $record->obtainOriginals($alias)) { $record->loadReference($alias); } $operations = Doctrine_Relation::getDeleteOperations($record->obtainOriginals($alias), $new); foreach ($operations as $r) { $query = 'DELETE FROM ' . $asf->getTableName() . ' WHERE ' . $this->getForeign() . ' = ?' . ' AND ' . $this->getLocal() . ' = ?'; $this->getTable()->getConnection()->execute($query, array($r->getIncremented(),$record->getIncremented())); } $operations = Doctrine_Relation::getInsertOperations($record->obtainOriginals($alias),$new); foreach ($operations as $r) { $reldao = $asf->create(); $reldao->set($this->getForeign(), $r); $reldao->set($this->getLocal(), $record); $reldao->save(); } $record->assignOriginals($alias, clone $record->get($alias)); } } public function getRelationDql($count, $context = 'record') { $component = $this->definition['assocTable']->getComponentName(); switch ($context) { case "record": $sub = 'SQL:SELECT ' . $this->definition['foreign']. ' FROM ' . $this->definition['assocTable']->getTableName(). ' WHERE ' . $this->definition['local'] . ' IN (' . substr(str_repeat("?, ", $count),0,-2) . ')'; $dql = 'FROM ' . $this->getTable()->getComponentName(); $dql .= '.' . $component; $dql .= ' WHERE ' . $this->getTable()->getComponentName() . '.' . $this->getTable()->getIdentifier() . ' IN (' . $sub . ')'; break; case "collection": $sub = substr(str_repeat("?, ", $count),0,-2); $dql = 'FROM ' . $component . '.' . $this->getTable()->getComponentName(); $dql .= ' WHERE ' . $component . '.' . $this->definition['local'] . ' IN (' . $sub . ')'; break; } return $dql; } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); if (empty($id)) { $coll = new Doctrine_Collection($this->getTable()); } else { $coll = Doctrine_Query::create()->parseQuery($this->getRelationDql(1))->execute(array($id)); } return $coll; } } class Doctrine_Relation_ForeignKey extends Doctrine_Relation { public function processDiff(Doctrine_Record $record) { $alias = $this->getAlias(); if ($this->isOneToOne()) { if ($record->obtainOriginals($alias) && $record->obtainOriginals($alias)->obtainIdentifier() != $this->obtainReference($alias)->obtainIdentifier() ) { $record->obtainOriginals($alias)->delete(); } } else { if ($record->hasReference($alias)) { $new = $record->obtainReference($alias); if ( ! $record->obtainOriginals($alias)) { $record->loadReference($alias); } $operations = Doctrine_Relation::getDeleteOperations($record->obtainOriginals($alias), $new); foreach ($operations as $r) { $r->delete(); } $record->assignOriginals($alias, clone $record->get($alias)); } } } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->get($this->definition['local']); if ($this->isOneToOne()) { if (empty($id)) { $related = $this->getTable()->create(); } else { $dql = 'FROM ' . $this->getTable()->getComponentName() . ' WHERE ' . $this->getTable()->getComponentName() . '.' . $this->definition['foreign'] . ' = ?'; $coll = $this->getTable()->getConnection()->query($dql, array($id)); $related = $coll[0]; } $related->set($this->definition['foreign'], $record, false); } else { if (empty($id)) { $related = new Doctrine_Collection($this->getTable()); } else { $query = $this->getRelationDql(1); $related = $this->getTable()->getConnection()->query($query, array($id)); } $related->setReference($record, $this); } return $related; } } class Doctrine_Relation_LocalKey extends Doctrine_Relation { public function processDiff(Doctrine_Record $record) { $alias = $this->getAlias(); if ($record->obtainOriginals($alias) && $record->obtainOriginals($alias)->obtainIdentifier() != $this->references[$alias]->obtainIdentifier() ) { $record->obtainOriginals($alias)->delete(); } } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->get($this->definition['local']); if (empty($id)) { $related = $this->getTable()->create(); } else { if ( ! ($related = $this->getTable()->find($id))) { $related = $this->getTable()->create(); } } $record->set($this->definition['local'], $related, false); return $related; } } class Doctrine_Reporter implements IteratorAggregate { protected $messages = array(); public function add($code, $message) { $this->messages[] = array($code, $message); } public function pop() { return array_pop($this->messages); } public function getAll() { return $this->messages; } public function getIterator() { return new ArrayIterator($this->messages); } } abstract class Doctrine_Schema_Object extends Doctrine_Access implements IteratorAggregate, Countable { protected $children = array(); protected $definition = array('name' => ''); public function __construct(array $definition = array()) { foreach ($this->definition as $key => $val) { if (isset($definition[$key])) { $this->definition[$key] = $definition[$key]; } } } public function get($name) { if ( ! array_key_exists($name, $this->definition)) { throw new Doctrine_Schema_Exception('Unknown definition '. $name); } return $this->definition[$name]; } public function set($name, $value) { if ( ! array_key_exists($name, $this->definition)) { throw new Doctrine_Schema_Exception('Unknown definition '. $name); } $this->definition[$name] = $value; } public function contains($name) { return array_key_exists($name, $this->definition); } public function toArray() { return $this->definition; } public function count() { if ( ! empty($this->children)) { return count($this->children); } return count($this->definition); } public function getIterator() { if ( ! empty($this->children)) { return new ArrayIterator($this->children); } return new ArrayIterator($this->definition); } } class Doctrine_Schema_Column extends Doctrine_Schema_Object implements IteratorAggregate { protected $definition = array('name' => '', 'type' => '', 'length' => null, 'unique' => false, 'primary' => false, 'notnull' => false, 'default' => false, 'autoinc' => false ); public function getName() { return $this->definition['name']; } public function getType() { return $this->definition['type']; } public function isUnique() { return $this->definition['unique']; } public function isPrimaryKey() { return $this->definition['primary']; } public function defaultValue() { return $this->definition['default']; } public function isNotNull() { return $this->definition['notnull']; } } class Doctrine_Schema_Database extends Doctrine_Schema_Object { protected $definition = array('name' => null, 'type' => null, 'charset' => null, 'description' => null, 'version' => null, 'engine' => null); private $childs = array(); public function __clone( ) { } public function __toString( ) { } public function isValid( ) { } public function addTable( $table = null ) { $this->childs[] = $table; } public function getTables() { return $this->childs; } } class Doctrine_Schema_Exception extends Exception { } class Doctrine_Schema_Relation extends Doctrine_Schema_Object { public $referencingColumn; public $referencedColumn; public $referencedTable; public static $ACTION_RESTRICT = 1; public static $ACTION_SET_NULL = 2; public static $ACTION_CASCADE = 3; public static $ACTION_NO_ACTION = 4; public static $ACTION_SET_DEFAULT = 5; public function setRelationBetween( $referencingColumn, $referencedTable, $referencedColumn ) { $this->referencingColumn = $referencingColumn; $this->referencedTable = $referencedTable; $this->referencedColumn = $referencedColumn; } public function __toString( ) { return "Relation between '".$this->referencingColumn."' and '".$this->referencedTable."'.'".$this->referencingColumn."'"; } public function isValid( ) { } } class Doctrine_Schema_Table extends Doctrine_Schema_Object implements Countable, IteratorAggregate { protected $definition = array('name' => '', 'check' => '', 'charset' => '', 'description' => ''); private $relations = array(); public function isValid( ) { } public function getColumns() { return $this->children; } public function getColumn($name) { if ( ! isset($this->children[$name])) { return false; } return $this->children[$name]; } public function addColumn(Doctrine_Schema_Column $column) { $name = $column->get('name'); $this->children[$name] = $column; return $this; } public function setRelation(Doctrine_Schema_Relation $relation){ $this->relations[] = $relation; } public function getRelations(){ return $this->relations; } } class Doctrine_Schema extends Doctrine_Schema_Object implements Countable, IteratorAggregate { private $childs; public function addDatabase( Doctrine_Schema_Database $database ) { $this->childs[] = $database; } public function getDatabases(){ return $this->childs; } public function __toString( ) { } public function isValid( ) { } } class Doctrine_Sequence extends Doctrine_Connection_Module { public function nextId($seqName, $ondemand = true) { throw new Doctrine_Sequence_Exception('method not implemented'); } public function lastInsertId($table = null, $field = null) { throw new Doctrine_Sequence_Exception('method not implemented'); } public function currId($seqName) { $this->warnings[] = 'database does not support getting current
            sequence value, the sequence value was incremented'; return $this->nextId($seqName); } } class Doctrine_Sequence_Db2 extends Doctrine_Sequence { } class Doctrine_Sequence_Exception extends Doctrine_Exception { } class Doctrine_Sequence_Firebird extends Doctrine_Sequence { public function nextID($seqName, $onDemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = 'SELECT GEN_ID(' . $sequenceName . ', 1) as the_value FROM RDB$DATABASE'; try { $result = $this->conn->fetchOne($query); } catch(Doctrine_Connection_Exception $e) { if ($onDemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName, 2); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return $this->currID($seqName); } throw $e; } return $result; } public function lastInsertId($table = null, $field = null) { return $this->conn->getDbh()->lastInsertId(); } public function currId($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = 'SELECT GEN_ID(' . $sequenceName . ', 0) as the_value FROM RDB$DATABASE'; try { $value = $this->conn->fetchOne($query); } catch(Doctrine_Connection_Exception $e) { throw new Doctrine_Sequence_Exception('Unable to select from ' . $seqName); } if ( ! is_numeric($value)) { throw new Doctrine_Sequence_Exception('could not find value in sequence table'); } return $value; } } class Doctrine_Sequence_Informix extends Doctrine_Sequence { } class Doctrine_Sequence_Mssql extends Doctrine_Sequence { public function nextId($seqName, $ondemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); if ($this->_checkSequence($sequenceName)) { $query = 'SET IDENTITY_INSERT ' . $sequenceName . ' ON ' . 'INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (0)'; } else { $query = 'INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (0)'; } try { $this->conn->exec($query); } catch(Doctrine_Connection_Exception $e) { if ($ondemand && !$this->_checkSequence($sequenceName)) { try { $result = $this->conn->export->createSequence($seqName, 2); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return 1; } } $value = $this->lastInsertId($sequenceName); if (is_numeric($value)) { $query = 'DELETE FROM ' . $sequenceName . ' WHERE ' . $seqcolName . ' < ' . $value; $this->conn->exec($query); } return $value; } public function lastInsertId($table = null, $field = null) { $serverInfo = $this->conn->getServerVersion(); if (is_array($serverInfo) && ! is_null($serverInfo['major']) && $serverInfo['major'] >= 8) { $query = 'SELECT SCOPE_IDENTITY()'; } else { $query = 'SELECT @@IDENTITY'; } return $this->conn->fetchOne($query); } public function currId($seqName) { $this->warnings[] = 'database does not support getting current
            sequence value, the sequence value was incremented'; return $this->nextId($seqName); } } class Doctrine_Sequence_Mysql extends Doctrine_Sequence { public function nextId($seqName, $ondemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (NULL)'; try { $this->conn->exec($query); } catch(Doctrine_Connection_Exception $e) { if ($ondemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName, 2); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return 1; } throw $e; } $value = $this->lastInsertId(); if (is_numeric($value)) { $query = 'DELETE FROM ' . $sequenceName . ' WHERE ' . $seqcolName . ' < ' . $value; $this->conn->exec($query); } return $value; } public function lastInsertId($table = null, $field = null) { return $this->conn->getDbh()->lastInsertId(); } public function currId($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'SELECT MAX(' . $seqcolName . ') FROM ' . $sequenceName; return (int) $this->conn->fetchOne($query); } } class Doctrine_Sequence_Oracle extends Doctrine_Sequence { public function nextID($seqName, $onDemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = 'SELECT ' . $sequenceName . '.nextval FROM DUAL'; try { $result = $this->conn->fetchOne($query); } catch(Doctrine_Connection_Exception $e) { if ($onDemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return $this->nextId($seqName, false); } throw $e; } return $result; } public function lastInsertID($table = null, $field = null) { $seqName = $table . (empty($field) ? '' : '_'.$field); $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return $this->conn->fetchOne('SELECT ' . $sequenceName . '.currval'); } public function currID($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = 'SELECT (last_number-1) FROM user_sequences'; $query .= ' WHERE sequence_name=' . $this->conn->quote($sequenceName, 'text'); $query .= ' OR sequence_name=' . $this->conn->quote(strtoupper($sequenceName), 'text'); return $this->conn->fetchOne($query); } } class Doctrine_Sequence_Pgsql extends Doctrine_Sequence { public function nextId($seqName, $onDemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $query = "SELECT NEXTVAL('" . $sequenceName . "')"; try { $result = (int) $this->conn->fetchOne($query); } catch(Doctrine_Connection_Exception $e) { if ($onDemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return $this->nextId($seqName, false); } } return $result; } public function lastInsertId($table = null, $field = null) { $seqName = $table . (empty($field) ? '' : '_' . $field); $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return (int) $this->conn->fetchOne("SELECT CURRVAL('" . $sequenceName . "')"); } public function currId($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return (int) $this->conn->fetchOne('SELECT last_value FROM ' . $sequenceName); } } class Doctrine_Sequence_Sqlite extends Doctrine_Sequence { public function nextId($seqName, $onDemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (NULL)'; try { $this->conn->exec($query); } catch(Doctrine_Connection_Exception $e) { if ($onDemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName, 2); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return 1; } } $value = $this->conn->getDbh()->lastInsertId(); if (is_numeric($value)) { $query = 'DELETE FROM ' . $sequenceName . ' WHERE ' . $seqcolName . ' < ' . $value; $this->conn->exec($query); } return $value; } public function lastInsertId($table = null, $field = null) { return $this->conn->getDbh()->lastInsertId(); } public function currId($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'SELECT MAX(' . $seqcolName . ') FROM ' . $sequenceName; return (int) $this->conn->fetchOne($query); } } class Doctrine_Table_Exception extends Doctrine_Exception { public function __construct($message = "Couldn't initialize table. One instance of this
                            table already exists. Always use Doctrine_Session::getTable(\$name)
                            to get on instance of a Doctrine_Table.") { parent::__construct($message); } } class Doctrine_Table extends Doctrine_Configurable implements Countable { private $data = array(); private $relations = array(); private $primaryKeys = array(); private $identifier; private $identifierType; private $query; private $conn; private $name; private $identityMap = array(); private $repository; protected $columns = array(); protected $columnAliases = array(); private $bound = array(); private $boundAliases = array(); private $columnCount; private $hasDefaultValues; protected $options = array('name' => null, 'tableName' => null, 'sequenceName' => null, 'inheritanceMap' => array(), 'enumMap' => array(), 'engine' => null, 'charset' => null, 'collation' => null, 'treeImpl' => null, 'treeOptions' => null, 'indexes' => array(), ); protected $tree; public function __construct($name, Doctrine_Connection $conn, $allowExport) { $this->conn = $conn; $this->setParent($this->conn); $this->options['name'] = $name; if ( ! class_exists($name) || empty($name)) { throw new Doctrine_Exception("Couldn't find class $name"); } $record = new $name($this); $names = array(); $class = $name; do { if ($class == "Doctrine_Record") break; $name = $class; $names[] = $name; } while ($class = get_parent_class($class)); $names = array_reverse($names); if (method_exists($record, 'setTableDefinition')) { $record->setTableDefinition(); if($this->isTree()) $this->getTree()->setTableDefinition(); $this->columnCount = count($this->columns); if (isset($this->columns)) { $method = new ReflectionMethod($this->options['name'], 'setTableDefinition'); $class = $method->getDeclaringClass(); $this->options['declaringClass'] = $class; if ( ! isset($this->options['tableName'])) { $this->options['tableName'] = Doctrine::tableize($class->getName()); } switch (count($this->primaryKeys)) { case 0: $this->columns = array_merge(array('id' => array('integer', 20, array('autoincrement' => true, 'primary' => true ) ) ), $this->columns); $this->primaryKeys[] = 'id'; $this->identifier = 'id'; $this->identifierType = Doctrine_Identifier::AUTO_INCREMENT; $this->columnCount++; break; default: if (count($this->primaryKeys) > 1) { $this->identifier = $this->primaryKeys; $this->identifierType = Doctrine_Identifier::COMPOSITE; } else { foreach ($this->primaryKeys as $pk) { $e = $this->columns[$pk][2]; $found = false; foreach ($e as $option => $value) { if ($found) break; $e2 = explode(':', $option); switch (strtolower($e2[0])) { case 'autoincrement': case 'autoinc': $this->identifierType = Doctrine_Identifier::AUTO_INCREMENT; $found = true; break; case 'seq': case 'sequence': $this->identifierType = Doctrine_Identifier::SEQUENCE; $found = true; if($value) { $this->options['sequenceName'] = $value; } else { $this->options['sequenceName'] = $this->conn->getSequenceName($this->options['tableName']); } break; } } if ( ! isset($this->identifierType)) { $this->identifierType = Doctrine_Identifier::NORMAL; } $this->identifier = $pk; } } }; if ($this->getAttribute(Doctrine::ATTR_CREATE_TABLES)) { $this->export(); } } } else { throw new Doctrine_Table_Exception("Class '$name' has no table definition."); } $record->setUp(); if ($this->isTree()) { $this->getTree()->setUp(); } array_pop($names); $this->options['parents'] = $names; $this->query = 'SELECT ' . implode(', ', array_keys($this->columns)) . ' FROM ' . $this->getTableName(); $this->repository = new Doctrine_Table_Repository($this); } public function export() { if ( ! Doctrine::isValidClassname($this->options['declaringClass']->getName())) { throw new Doctrine_Table_Exception('Class name not valid.'); } try { $columns = array(); $primary = array(); foreach ($this->columns as $name => $column) { $definition = $column[2]; $definition['type'] = $column[0]; $definition['length'] = $column[1]; switch ($definition['type']) { case 'enum': if (isset($definition['default'])) { $definition['default'] = $this->enumIndex($name, $definition['default']); } break; case 'boolean': if (isset($definition['default'])) { $definition['default'] = (int) $definition['default']; } break; } $columns[$name] = $definition; if(isset($definition['primary']) && $definition['primary']) { $primary[] = $name; } } $options['primary'] = $primary; $this->conn->export->createTable($this->options['tableName'], $columns, array_merge($this->options, $options)); } catch(Doctrine_Connection_Exception $e) { if($e->getPortableCode() !== Doctrine::ERR_ALREADY_EXISTS) { throw $e; } } } public function exportConstraints() { try { $this->conn->beginTransaction(); foreach ($this->options['index'] as $index => $definition) { $this->conn->export->createIndex($this->options['tableName'], $index, $definition); } $this->conn->commit(); } catch(Doctrine_Connection_Exception $e) { $this->conn->rollback(); throw $e; } } public function __get($option) { if (isset($this->options[$option])) { return $this->options[$option]; } return null; } public function __isset($option) { return isset($this->options[$option]); } public function addForeignKey(array $definition) { $this->options['foreignKeys'][] = $definition; } public function addIndex($index, array $definition) { $index = $this->conn->getIndexName($index); $this->options['indexes'][$index] = $definition; } public function getIndex($index) { if (isset($this->options['indexes'][$index])) { return $this->options['indexes'][$index]; } return false; } public function createQuery() { return Doctrine_Query::create()->from($this->getComponentName()); } public function getRepository() { return $this->repository; } public function setOption($name, $value) { switch ($name) { case 'name': case 'tableName': break; case 'enumMap': case 'inheritanceMap': case 'index': case 'treeOptions': if ( ! is_array($value)) { throw new Doctrine_Table_Exception($name . ' should be an array.'); } break; } $this->options[$name] = $value; } public function getOption($name) { if (isset($this->options[$name])) { return $this->options[$name]; } return null; } public function getColumnName($alias) { if(isset($this->columnAliases[$alias])) { return $this->columnAliases[$alias]; } return $alias; } public function setColumn($name, $type, $length = null, $options = array()) { if (is_string($options)) { $options = explode('|', $options); } foreach ($options as $k => $option) { if (is_numeric($k)) { if ( ! empty($option)) { $options[$option] = true; } unset($options[$k]); } } $name = strtolower($name); $parts = explode(' as ', $name); if (count($parts) > 1) { $this->columnAliases[$parts[1]] = $parts[0]; $name = $parts[0]; } if ($length == null) { $length = 2147483647; } if ((string) (int) $length !== (string) $length) { throw new Doctrine_Table_Exception('Invalid argument given for column length'); } $this->columns[$name] = array($type, $length, $options); if (isset($options['primary'])) { $this->primaryKeys[] = $name; } if (isset($options['default'])) { $this->hasDefaultValues = true; } } public function hasDefaultValues() { return $this->hasDefaultValues; } public function getDefaultValueOf($column) { $column = strtolower($column); if ( ! isset($this->columns[$column])) { throw new Doctrine_Table_Exception("Couldn't get default value. Column ".$column." doesn't exist."); } if (isset($this->columns[$column][2]['default'])) { return $this->columns[$column][2]['default']; } else { return null; } } final public function getIdentifier() { return $this->identifier; } final public function getIdentifierType() { return $this->identifierType; } final public function hasColumn($name) { return isset($this->columns[$name]); } final public function setPrimaryKey($key) { switch (gettype($key)) { case "array": $this->primaryKeys = array_values($key); break; case "string": $this->primaryKeys[] = $key; break; }; } final public function getPrimaryKeys() { return $this->primaryKeys; } final public function hasPrimaryKey($key) { return in_array($key,$this->primaryKeys); } public function getBounds() { return $this->bound; } public function getBound($name) { if ( ! isset($this->bound[$name])) { throw new Doctrine_Table_Exception('Unknown bound '.$name); } return $this->bound[$name]; } public function getBoundForName($name, $component) { foreach ($this->bound as $k => $bound) { $e = explode('.', $bound['field']); if ($bound['class'] == $name && $e[0] == $component) { return $this->bound[$k]; } } throw new Doctrine_Table_Exception('Unknown bound ' . $name); } public function getAlias($name) { if (isset($this->boundAliases[$name])) { return $this->boundAliases[$name]; } return $name; } public function getAliasName($alias) { if ($name = array_search($alias, $this->boundAliases)) { return $name; } return $alias; } public function unbindAll() { $this->bound = array(); $this->relations = array(); $this->boundAliases = array(); } public function unbind($name) { if ( ! isset($this->bound[$name])) { return false; } unset($this->bound[$name]); if (isset($this->relations[$name])) { unset($this->relations[$name]); } if (isset($this->boundAliases[$name])) { unset($this->boundAliases[$name]); } return true; } public function bind($name, $field, $type, $options = null) { if (isset($this->relations[$name])) { unset($this->relations[$name]); } $lower = strtolower($name); if (isset($this->columns[$lower])) { throw new Doctrine_Table_Exception("Couldn't bind relation. Column with name " . $lower . ' already exists!'); } $e = explode(' as ', $name); $name = $e[0]; if (isset($e[1])) { $alias = $e[1]; $this->boundAliases[$name] = $alias; } else { $alias = $name; } $this->bound[$alias] = array('field' => $field, 'type' => $type, 'class' => $name, 'alias' => $alias); if ($options !== null) { $opt = array(); if (is_string($options)) { $opt['local'] = $options; } else { $opt = (array) $options; } $this->bound[$alias] = array_merge($this->bound[$alias], $opt); } } public function getConnection() { return $this->conn; } final public function hasRelatedComponent($name, $component) { return (strpos($this->bound[$name]['field'], $component . '.') !== false); } final public function hasRelation($name) { if (isset($this->bound[$name])) { return true; } foreach ($this->bound as $k=>$v) { if ($this->hasRelatedComponent($k, $name)) { return true; } } return false; } public function getRelation($name, $recursive = true) { if (isset($this->relations[$name])) { return $this->relations[$name]; } if (isset($this->bound[$name])) { $definition = $this->bound[$name]; list($component, $definition['foreign']) = explode('.', $definition['field']); unset($definition['field']); $definition['table'] = $this->conn->getTable($definition['class'], false); if ($component == $this->options['name'] || in_array($component, $this->options['parents'])) { if ($definition['type'] == Doctrine_Relation::ONE_COMPOSITE || $definition['type'] == Doctrine_Relation::ONE_AGGREGATE) { if ( ! isset($definition['local'])) { $definition['local'] = $definition['foreign']; $definition['foreign'] = $definition['table']->getIdentifier(); } $relation = new Doctrine_Relation_LocalKey($definition); } else { if ( ! isset($definition['local'])) { $tmp = $definition['table']->getIdentifier(); $definition['local'] = $tmp; } $relation = new Doctrine_Relation_ForeignKey($definition); } } elseif ($component == $definition['class'] || ($component == $definition['alias'])) { if ( ! isset($defintion['local'])) { $definition['local'] = $this->identifier; } $relation = new Doctrine_Relation_ForeignKey($definition); } else { if ($definition['type'] != Doctrine_Relation::MANY_AGGREGATE) { throw new Doctrine_Table_Exception("Only aggregate relations are allowed for many-to-many relations"); } $classes = array_merge($this->options['parents'], array($this->options['name'])); foreach (array_reverse($classes) as $class) { try { $bound = $definition['table']->getBoundForName($class, $component); break; } catch(Doctrine_Table_Exception $exc) { } } if ( ! isset($bound)) { throw new Doctrine_Table_Exception("Couldn't map many-to-many relation for " . $this->options['name'] . " and $name. Components use different join tables."); } if ( ! isset($definition['local'])) { $definition['local'] = $this->identifier; } $e2 = explode('.', $bound['field']); $fields = explode('-', $e2[1]); if ($e2[0] != $component) { throw new Doctrine_Table_Exception($e2[0] . ' doesn\'t match ' . $component); } $associationTable = $this->conn->getTable($e2[0], false); if (count($fields) > 1) { $def['table'] = $associationTable; $def['local'] = $this->identifier; $def['foreign'] = $fields[0]; $def['alias'] = $e2[0]; $def['class'] = $e2[0]; $def['type'] = Doctrine_Relation::MANY_COMPOSITE; $this->relations[$e2[0]] = new Doctrine_Relation_ForeignKey($def); $definition['assocTable'] = $associationTable; $definition['local'] = $fields[0]; $definition['foreign'] = $fields[1]; $relation = new Doctrine_Relation_Association_Self($definition); } else { if($definition['table'] === $this) { } else { $associationTable->bind($this->getComponentName(), $associationTable->getComponentName(). '.' . $e2[1], Doctrine_Relation::ONE_AGGREGATE ); $associationTable->bind($definition['table']->getComponentName(), $associationTable->getComponentName(). '.' . $definition['foreign'], Doctrine_Relation::ONE_AGGREGATE ); $def['table'] = $associationTable; $def['foreign'] = $e2[1]; $def['local'] = $definition['local']; $def['alias'] = $e2[0]; $def['class'] = $e2[0]; $def['type'] = Doctrine_Relation::MANY_COMPOSITE; $this->relations[$e2[0]] = new Doctrine_Relation_ForeignKey($def); $definition['local'] = $e2[1]; $definition['assocTable'] = $associationTable; $relation = new Doctrine_Relation_Association($definition); } } } $this->relations[$name] = $relation; return $this->relations[$name]; } $this->getRelations(); if ($recursive) { return $this->getRelation($name, false); } else { throw new Doctrine_Table_Exception($this->options['name'] . " doesn't have a relation to " . $name); } } final public function getRelations() { $a = array(); foreach ($this->bound as $k => $v) { $this->getRelation($k); } return $this->relations; } public function create(array $array = array()) { $this->data = $array; $record = new $this->options['name']($this, true); $this->data = array(); return $record; } public function find($id) { if ($id !== null) { if ( ! is_array($id)) { $id = array($id); } else { $id = array_values($id); } $query = $this->query . ' WHERE ' . implode(' = ? AND ', $this->primaryKeys) . ' = ?'; $query = $this->applyInheritance($query); $params = array_merge($id, array_values($this->options['inheritanceMap'])); $stmt = $this->conn->execute($query, $params); $this->data = $stmt->fetch(PDO::FETCH_ASSOC); if ($this->data === false) return false; return $this->getRecord(); } return false; } final public function applyInheritance($where) { if ( ! empty($this->options['inheritanceMap'])) { $a = array(); foreach ($this->options['inheritanceMap'] as $field => $value) { $a[] = $field . ' = ?'; } $i = implode(' AND ', $a); $where .= ' AND ' . $i; } return $where; } public function findAll() { $graph = new Doctrine_Query($this->conn); $users = $graph->query("FROM ".$this->options['name']); return $users; } public function findBySql($dql, array $params = array()) { $q = new Doctrine_Query($this->conn); $users = $q->query("FROM ".$this->options['name']." WHERE ".$dql, $params); return $users; } public function findByDql($dql, array $params = array()) { return $this->findBySql($dql, $params); } public function clear() { $this->identityMap = array(); } public function getRecord() { $this->data = array_change_key_case($this->data, CASE_LOWER); $key = $this->getIdentifier(); if ( ! is_array($key)) { $key = array($key); } foreach ($key as $k) { if ( ! isset($this->data[$k])) { throw new Doctrine_Exception("Primary key value for $k wasn't found"); } $id[] = $this->data[$k]; } $id = implode(' ', $id); if (isset($this->identityMap[$id])) { $record = $this->identityMap[$id]; } else { $record = new $this->options['name']($this); $this->identityMap[$id] = $record; } $this->data = array(); return $record; } final public function getProxy($id = null) { if ($id !== null) { $query = 'SELECT ' . implode(', ',$this->primaryKeys) . ' FROM ' . $this->getTableName() . ' WHERE ' . implode(' = ? && ',$this->primaryKeys).' = ?'; $query = $this->applyInheritance($query); $params = array_merge(array($id), array_values($this->options['inheritanceMap'])); $this->data = $this->conn->execute($query,$params)->fetch(PDO::FETCH_ASSOC); if ($this->data === false) return false; } return $this->getRecord(); } public function count() { $a = $this->conn->getDBH()->query("SELECT COUNT(1) FROM ".$this->options['tableName'])->fetch(PDO::FETCH_NUM); return current($a); } public function getQueryObject() { $graph = new Doctrine_Query($this->getConnection()); $graph->load($this->getComponentName()); return $graph; } public function execute($query, array $array = array(), $limit = null, $offset = null) { $coll = new Doctrine_Collection($this); $query = $this->conn->modifyLimitQuery($query,$limit,$offset); if ( ! empty($array)) { $stmt = $this->conn->getDBH()->prepare($query); $stmt->execute($array); } else { $stmt = $this->conn->getDBH()->query($query); } $data = $stmt->fetchAll(PDO::FETCH_ASSOC); $stmt->closeCursor(); foreach ($data as $row) { $this->data = $row; $record = $this->getRecord(); $coll->add($record); } return $coll; } final public function getEnumValues($field) { if (isset($this->columns[$field][2]['values'])) { return $this->columns[$field][2]['values']; } else { return array(); } } public function enumValue($field, $index) { if ($index instanceof Doctrine_Null) return $index; return isset($this->columns[$field][2]['values'][$index]) ? $this->columns[$field][2]['values'][$index] : $index; } public function enumIndex($field, $value) { $values = $this->getEnumValues($field); return array_search($value, $values); } public function invokeSet(Doctrine_Record $record, $name, $value) { if ( ! ($this->getAttribute(Doctrine::ATTR_ACCESSORS) & Doctrine::ACCESSOR_SET)) { return $value; } $prefix = $this->getAttribute(Doctrine::ATTR_ACCESSOR_PREFIX_SET); if (!$prefix) $prefix = 'set'; $method = $prefix . $name; if (method_exists($record, $method)) { return $record->$method($value); } return $value; } public function invokeGet(Doctrine_Record $record, $name, $value) { if ( ! ($this->getAttribute(Doctrine::ATTR_ACCESSORS) & Doctrine::ACCESSOR_GET)) { return $value; } $prefix = $this->getAttribute(Doctrine::ATTR_ACCESSOR_PREFIX_GET); if (!$prefix) $prefix = 'get'; $method = $prefix . $name; if (method_exists($record, $method)) { return $record->$method($value); } return $value; } public function getValueWrapperOf($column) { if (isset($this->columns[$column][2]['wrapper'])) { return $this->columns[$column][2]['wrapper']; } return false; } final public function getColumnCount() { return $this->columnCount; } final public function getColumns() { return $this->columns; } public function getColumnNames() { return array_keys($this->columns); } public function getDefinitionOf($column) { if (isset($this->columns[$column])) { return $this->columns[$column]; } return false; } public function getTypeOf($column) { if (isset($this->columns[$column])) { return $this->columns[$column][0]; } return false; } public function setData(array $data) { $this->data = $data; } final public function getMaxIdentifier() { $sql = "SELECT MAX(".$this->getIdentifier().") FROM ".$this->getTableName(); $stmt = $this->conn->getDBH()->query($sql); $data = $stmt->fetch(PDO::FETCH_NUM); return isset($data[0])?$data[0]:1; } final public function getQuery() { return $this->query; } final public function getData() { return $this->data; } public function getTree() { if (isset($this->options['treeImpl'])) { if ( ! $this->tree) { $options = isset($this->options['treeOptions']) ? $this->options['treeOptions'] : array(); $this->tree = Doctrine_Tree::factory($this, $this->options['treeImpl'], $options ); } return $this->tree; } return false; } public function getComponentName() { return $this->options['name']; } public function getTableName() { return $this->options['tableName']; } public function setTableName($tableName) { $this->options['tableName'] = $tableName; } public function isTree() { return ( ! is_null($this->options['treeImpl'])) ? true : false; } public function __toString() { return Doctrine_Lib::getTableAsString($this); } public function __call($func, $args = array()) { if (0 == count($args)) return; if (preg_match('/findBy([\w]+)/', $func, $matches)) { $column = strtolower($matches[1]); if ($this->hasColumn($column)) { $results = $this->findByDql($column . ' LIKE ?', array($args[0])); if (count($results) == 1) { return $results[0]; } elseif (count($results == 0)) { return false; } return $results; } } } } class Doctrine_Table_Repository_Exception extends Doctrine_Exception { } class Doctrine_Table_Repository implements Countable, IteratorAggregate { private $table; private $registry = array(); public function __construct(Doctrine_Table $table) { $this->table = $table; } public function getTable() { return $this->table; } public function add(Doctrine_Record $record) { $oid = $record->getOID(); if (isset($this->registry[$oid])) { return false; } $this->registry[$oid] = $record; return true; } public function get($oid) { if ( ! isset($this->registry[$oid])) { throw new Doctrine_Table_Repository_Exception("Unknown object identifier"); } return $this->registry[$oid]; } public function count() { return count($this->registry); } public function evict($oid) { if ( ! isset($this->registry[$oid])) { return false; } unset($this->registry[$oid]); return true; } public function evictAll() { $evicted = 0; foreach ($this->registry as $oid=>$record) { if ($this->evict($oid)) { $evicted++; } } return $evicted; } public function getIterator() { return new ArrayIterator($this->registry); } public function contains($oid) { return isset($this->registry[$oid]); } public function loadAll() { $this->table->findAll(); } } class Doctrine_Transaction extends Doctrine_Connection_Module { const STATE_SLEEP = 0; const STATE_ACTIVE = 1; const STATE_BUSY = 2; protected $transactionLevel = 0; protected $invalid = array(); protected $delete = array(); public $savePoints = array(); public function getState() { switch ($this->transactionLevel) { case 0: return Doctrine_Transaction::STATE_SLEEP; break; case 1: return Doctrine_Transaction::STATE_ACTIVE; break; default: return Doctrine_Transaction::STATE_BUSY; } } public function addDelete(Doctrine_Record $record) { $name = $record->getTable()->getComponentName(); $this->delete[$name][] = $record; } public function addInvalid(Doctrine_Record $record) { if (in_array($record, $this->invalid)) { return false; } $this->invalid[] = $record; return true; } public function getDeletes() { return $this->delete; } public function bulkDelete() { foreach ($this->delete as $name => $deletes) { $record = false; $ids = array(); foreach ($deletes as $k => $record) { $ids[] = $record->getIncremented(); $record->assignIdentifier(false); } if ($record instanceof Doctrine_Record) { $params = substr(str_repeat("?, ",count($ids)),0,-2); $query = 'DELETE FROM ' . $record->getTable()->getTableName() . ' WHERE ' . $record->getTable()->getIdentifier() . ' IN(' . $params . ')'; $this->conn->execute($query, $ids); } } $this->delete = array(); } public function getTransactionLevel() { return $this->transactionLevel; } public function beginTransaction($savepoint = null) { if ( ! is_null($savepoint)) { $this->beginTransaction(); $this->savePoints[] = $savepoint; $this->createSavePoint($savepoint); } else { if ($this->transactionLevel == 0) { $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onPreTransactionBegin($this->conn); $this->conn->getDbh()->beginTransaction(); $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onTransactionBegin($this->conn); } } $level = ++$this->transactionLevel; return $level; } public function commit($savepoint = null) { if ($this->transactionLevel == 0) return false; if ( ! is_null($savepoint)) { $this->transactionLevel = $this->removeSavePoints($savepoint); $this->releaseSavePoint($savepoint); } else { if ($this->transactionLevel == 1) { $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onPreTransactionCommit($this->conn); try { $this->bulkDelete(); } catch(Exception $e) { $this->rollback(); throw new Doctrine_Transaction_Exception($e->__toString()); } if ( ! empty($this->invalid)) { $this->rollback(); $tmp = $this->invalid; $this->invalid = array(); throw new Doctrine_Validator_Exception($tmp); } $this->conn->getDbh()->commit(); $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onTransactionCommit($this->conn); } } $this->transactionLevel--; return true; } public function rollback($savepoint = null) { if ($this->transactionLevel == 0) return false; $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onPreTransactionRollback($this->conn); if ( ! is_null($savepoint)) { $this->transactionLevel = $this->removeSavePoints($savepoint); $this->rollbackSavePoint($savepoint); } else { $this->deteles = array(); $this->transactionLevel = 0; $this->conn->getDbh()->rollback(); } $this->conn->getAttribute(Doctrine::ATTR_LISTENER)->onTransactionRollback($this->conn); return true; } protected function createSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } protected function releaseSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } protected function rollbackSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } private function removeSavePoints($savepoint) { $i = array_search($savepoint, $this->savePoints); $c = count($this->savePoints); for ($x = $i; $x < count($this->savePoints); $x++) { unset($this->savePoints[$x]); } return ($c - $i); } public function setIsolation($isolation) { throw new Doctrine_Transaction_Exception('Transaction isolation levels not supported by this driver.'); } public function getIsolation() { throw new Doctrine_Transaction_Exception('Fetching transaction isolation level not supported by this driver.'); } } class Doctrine_Transaction_Exception extends Doctrine_Exception { } class Doctrine_Transaction_Firebird extends Doctrine_Transaction { protected function createSavePoint($savepoint) { $query = 'SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function releaseSavePoint($savepoint) { $query = 'RELEASE SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function rollbackSavePoint($savepoint) { $query = 'ROLLBACK TO SAVEPOINT '.$savepoint; return $this->conn->execute($query); } public function setIsolation($isolation, $options = array()) { switch ($isolation) { case 'READ UNCOMMITTED': $nativeIsolation = 'READ COMMITTED RECORD_VERSION'; break; case 'READ COMMITTED': $nativeIsolation = 'READ COMMITTED NO RECORD_VERSION'; break; case 'REPEATABLE READ': $nativeIsolation = 'SNAPSHOT'; break; case 'SERIALIZABLE': $nativeIsolation = 'SNAPSHOT TABLE STABILITY'; break; default: throw new Doctrine_Transaction_Exception('isolation level is not supported: ' . $isolation); } $rw = $wait = ''; if (isset($options['wait'])) { switch ($options['wait']) { case 'WAIT': case 'NO WAIT': $wait = ' ' . $options['wait']; break; default: throw new Doctrine_Transaction_Exception('wait option is not supported: ' . $options['wait']); } } if (isset($options['rw'])) { switch ($options['rw']) { case 'READ ONLY': case 'READ WRITE': $rw = ' ' . $options['rw']; break; default: throw new Doctrine_Transaction_Exception('wait option is not supported: ' . $options['rw']); } } $query = 'SET TRANSACTION' . $rw . $wait .' ISOLATION LEVEL ' . $nativeIsolation; $this->conn->execute($query); } } class Doctrine_Transaction_Informix extends Doctrine_Transaction { } class Doctrine_Transaction_Mssql extends Doctrine_Transaction { public function setIsolation($isolation, $options = array()) { switch ($isolation) { case 'READ UNCOMMITTED': case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': case 'SNAPSHOT': break; default: throw new Doctrine_Transaction_Exception('isolation level is not supported: ' . $isolation); } $query = 'SET TRANSACTION ISOLATION LEVEL ' . $isolation; $this->conn->execute($query); } } class Doctrine_Transaction_Mysql extends Doctrine_Transaction { protected function createSavePoint($savepoint) { $query = 'SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function releaseSavePoint($savepoint) { $query = 'RELEASE SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function rollbackSavePoint($savepoint) { $query = 'ROLLBACK TO SAVEPOINT '.$savepoint; return $this->conn->execute($query); } public function setIsolation($isolation) { switch ($isolation) { case 'READ UNCOMMITTED': case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': break; default: throw new Doctrine_Transaction_Exception('Isolation level ' . $isolation . ' is not supported.'); } $query = 'SET SESSION TRANSACTION ISOLATION LEVEL ' . $isolation; return $this->conn->execute($query); } public function getIsolation() { return $this->conn->fetchOne('SELECT @@tx_isolation'); } } class Doctrine_Transaction_Oracle extends Doctrine_Transaction { protected function createSavePoint($savepoint) { $query = 'SAVEPOINT ' . $savepoint; return $this->conn->execute($query); } protected function releaseSavePoint($savepoint) { return true; } protected function rollbackSavePoint($savepoint) { $query = 'ROLLBACK TO SAVEPOINT ' . $savepoint; return $this->conn->execute($query); } public function setIsolation($isolation) { switch ($isolation) { case 'READ UNCOMMITTED': $isolation = 'READ COMMITTED'; break; case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': $isolation = 'SERIALIZABLE'; break; default: throw new Doctrine_Transaction_Exception('Isolation level ' . $isolation . ' is not supported.'); } $query = 'ALTER SESSION ISOLATION LEVEL ' . $isolation; return $this->conn->execute($query); } } class Doctrine_Transaction_Pgsql extends Doctrine_Transaction { protected function createSavePoint($savepoint) { $query = 'SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function releaseSavePoint($savepoint) { $query = 'RELEASE SAVEPOINT '.$savepoint; return $this->conn->execute($query); } protected function rollbackSavePoint($savepoint) { $query = 'ROLLBACK TO SAVEPOINT '.$savepoint; return $this->conn->execute($query); } public function setIsolation($isolation) { switch ($isolation) { case 'READ UNCOMMITTED': case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': break; default: throw new Doctrine_Transaction_Exception('Isolation level '.$isolation.' is not supported.'); } $query = 'SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL ' . $isolation; return $this->conn->execute($query); } } class Doctrine_Transaction_Sqlite extends Doctrine_Transaction { public function setIsolation($isolation) { switch ($isolation) { case 'READ UNCOMMITTED': $isolation = 0; break; case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': $isolation = 1; break; default: throw new Doctrine_Transaction_Exception('Isolation level ' . $isolation . 'is not supported.'); } $query = 'PRAGMA read_uncommitted = ' . $isolation; return $this->conn->execute($query); } } class Doctrine_Validator { private static $validators = array(); private static $null; public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public static function getValidator($name) { if ( ! isset(self::$validators[$name])) { $class = 'Doctrine_Validator_' . ucwords(strtolower($name)); if (class_exists($class)) { self::$validators[$name] = new $class; } else { throw new Doctrine_Exception("Validator named '$name' not availible."); } } return self::$validators[$name]; } public function validateRecord(Doctrine_Record $record) { $columns = $record->getTable()->getColumns(); $component = $record->getTable()->getComponentName(); $errorStack = $record->getErrorStack(); $data = ($record->exists()) ? $record->getModified() : $record->getData(); $err = array(); foreach ($data as $key => $value) { if ($value === self::$null) $value = null; elseif ($value instanceof Doctrine_Record) $value = $value->getIncremented(); $column = $columns[$key]; if ($column[0] == "enum") { $value = $record->getTable()->enumIndex($key, $value); if ($value === false) { $errorStack->add($key, 'enum'); continue; } } if ($record->getTable()->getAttribute(Doctrine::ATTR_AUTO_LENGTH_VLD)) { if (!$this->validateLength($column, $key, $value)) { $errorStack->add($key, 'length'); continue; } } if ( ! is_array($column[2])) { $e = explode("|",$column[2]); } else { $e = $column[2]; } foreach ($e as $k => $arg) { if (is_string($k)) { $name = $k; $args = $arg; } else { $args = explode(":",$arg); $name = array_shift($args); if ( ! isset($args[0])) { $args[0] = ''; } } if (empty($name) || $name == 'primary' || $name == 'protected' || $name == 'autoincrement' || $name == 'default' || $name == 'values' || $name == 'sequence' ) { continue; } if (strtolower($name) == 'length') { if (!$record->getTable()->getAttribute(Doctrine::ATTR_AUTO_LENGTH_VLD)) { if (!$this->validateLength($column, $key, $value)) { $errorStack->add($key, 'length'); } } continue; } if (strtolower($name) == 'type') { if (!$record->getTable()->getAttribute(Doctrine::ATTR_AUTO_TYPE_VLD)) { if ( ! self::isValidType($value, $column[0])) { $errorStack->add($key, 'type'); } } continue; } $validator = self::getValidator($name); if ( ! $validator->validate($record, $key, $value, $args)) { $errorStack->add($key, $name); } } if ($record->getTable()->getAttribute(Doctrine::ATTR_AUTO_TYPE_VLD)) { if ( ! self::isValidType($value, $column[0])) { $errorStack->add($key, 'type'); continue; } } } } private function validateLength($column, $key, $value) { if ($column[0] == "timestamp" || $column[0] == "integer") { return true; } else if ($column[0] == "array" || $column[0] == "object") { $length = strlen(serialize($value)); } else { $length = strlen($value); } if ($length > $column[1]) { return false; } return true; } public function hasErrors() { return (count($this->stack) > 0); } public static function phpType($doctrineType) { switch ($doctrineType) { case 'enum': return 'integer'; case 'blob': case 'clob': case 'mbstring': case 'timestamp': case 'date': case 'gzip': return 'string'; break; default: return $doctrineType; } } public static function isValidType($var, $type) { if ($type == 'boolean') return true; $looseType = self::gettype($var); $type = self::phpType($type); switch ($looseType) { case 'float': case 'double': case 'integer': if ($type == 'string' || $type == 'float') return true; case 'string': case 'array': case 'object': return ($type === $looseType); break; case 'NULL': return true; break; }; } public static function gettype($var) { $type = gettype($var); switch ($type) { case 'string': if (preg_match("/^[0-9]+$/",$var)) { return 'integer'; } elseif (is_numeric($var)) { return 'float'; } else { return $type; } break; default: return $type; }; } } class Doctrine_Validator_Country { private static $countries = array( 'ad' => 'Andorra', 'ae' => 'United Arab Emirates', 'af' => 'Afghanistan', 'ag' => 'Antigua and Barbuda', 'ai' => 'Anguilla', 'al' => 'Albania', 'am' => 'Armenia', 'an' => 'Netherlands Antilles', 'ao' => 'Angola', 'aq' => 'Antarctica', 'ar' => 'Argentina', 'as' => 'American Samoa', 'at' => 'Austria', 'au' => 'Australia', 'aw' => 'Aruba', 'az' => 'Azerbaijan', 'ba' => 'Bosnia Hercegovina', 'bb' => 'Barbados', 'bd' => 'Bangladesh', 'be' => 'Belgium', 'bf' => 'Burkina Faso', 'bg' => 'Bulgaria', 'bh' => 'Bahrain', 'bi' => 'Burundi', 'bj' => 'Benin', 'bm' => 'Bermuda', 'bn' => 'Brunei Darussalam', 'bo' => 'Bolivia', 'br' => 'Brazil', 'bs' => 'Bahamas', 'bt' => 'Bhutan', 'bv' => 'Bouvet Island', 'bw' => 'Botswana', 'by' => 'Belarus (Byelorussia)', 'bz' => 'Belize', 'ca' => 'Canada', 'cc' => 'Cocos Islands', 'cd' => 'Congo, The Democratic Republic of the', 'cf' => 'Central African Republic', 'cg' => 'Congo', 'ch' => 'Switzerland', 'ci' => 'Ivory Coast', 'ck' => 'Cook Islands', 'cl' => 'Chile', 'cm' => 'Cameroon', 'cn' => 'China', 'co' => 'Colombia', 'cr' => 'Costa Rica', 'cs' => 'Czechoslovakia', 'cu' => 'Cuba', 'cv' => 'Cape Verde', 'cx' => 'Christmas Island', 'cy' => 'Cyprus', 'cz' => 'Czech Republic', 'de' => 'Germany', 'dj' => 'Djibouti', 'dk' => 'Denmark', 'dm' => 'Dominica', 'do' => 'Dominican Republic', 'dz' => 'Algeria', 'ec' => 'Ecuador', 'ee' => 'Estonia', 'eg' => 'Egypt', 'eh' => 'Western Sahara', 'er' => 'Eritrea', 'es' => 'Spain', 'et' => 'Ethiopia', 'fi' => 'Finland', 'fj' => 'Fiji', 'fk' => 'Falkland Islands', 'fm' => 'Micronesia', 'fo' => 'Faroe Islands', 'fr' => 'France', 'fx' => 'France, Metropolitan FX', 'ga' => 'Gabon', 'gb' => 'United Kingdom (Great Britain)', 'gd' => 'Grenada', 'ge' => 'Georgia', 'gf' => 'French Guiana', 'gh' => 'Ghana', 'gi' => 'Gibraltar', 'gl' => 'Greenland', 'gm' => 'Gambia', 'gn' => 'Guinea', 'gp' => 'Guadeloupe', 'gq' => 'Equatorial Guinea', 'gr' => 'Greece', 'gs' => 'South Georgia and the South Sandwich Islands', 'gt' => 'Guatemala', 'gu' => 'Guam', 'gw' => 'Guinea-bissau', 'gy' => 'Guyana', 'hk' => 'Hong Kong', 'hm' => 'Heard and McDonald Islands', 'hn' => 'Honduras', 'hr' => 'Croatia', 'ht' => 'Haiti', 'hu' => 'Hungary', 'id' => 'Indonesia', 'ie' => 'Ireland', 'il' => 'Israel', 'in' => 'India', 'io' => 'British Indian Ocean Territory', 'iq' => 'Iraq', 'ir' => 'Iran', 'is' => 'Iceland', 'it' => 'Italy', 'jm' => 'Jamaica', 'jo' => 'Jordan', 'jp' => 'Japan', 'ke' => 'Kenya', 'kg' => 'Kyrgyzstan', 'kh' => 'Cambodia', 'ki' => 'Kiribati', 'km' => 'Comoros', 'kn' => 'Saint Kitts and Nevis', 'kp' => 'North Korea', 'kr' => 'South Korea', 'kw' => 'Kuwait', 'ky' => 'Cayman Islands', 'kz' => 'Kazakhstan', 'la' => 'Laos', 'lb' => 'Lebanon', 'lc' => 'Saint Lucia', 'li' => 'Lichtenstein', 'lk' => 'Sri Lanka', 'lr' => 'Liberia', 'ls' => 'Lesotho', 'lt' => 'Lithuania', 'lu' => 'Luxembourg', 'lv' => 'Latvia', 'ly' => 'Libya', 'ma' => 'Morocco', 'mc' => 'Monaco', 'md' => 'Moldova Republic', 'mg' => 'Madagascar', 'mh' => 'Marshall Islands', 'mk' => 'Macedonia, The Former Yugoslav Republic of', 'ml' => 'Mali', 'mm' => 'Myanmar', 'mn' => 'Mongolia', 'mo' => 'Macau', 'mp' => 'Northern Mariana Islands', 'mq' => 'Martinique', 'mr' => 'Mauritania', 'ms' => 'Montserrat', 'mt' => 'Malta', 'mu' => 'Mauritius', 'mv' => 'Maldives', 'mw' => 'Malawi', 'mx' => 'Mexico', 'my' => 'Malaysia', 'mz' => 'Mozambique', 'na' => 'Namibia', 'nc' => 'New Caledonia', 'ne' => 'Niger', 'nf' => 'Norfolk Island', 'ng' => 'Nigeria', 'ni' => 'Nicaragua', 'nl' => 'Netherlands', 'no' => 'Norway', 'np' => 'Nepal', 'nr' => 'Nauru', 'nt' => 'Neutral Zone', 'nu' => 'Niue', 'nz' => 'New Zealand', 'om' => 'Oman', 'pa' => 'Panama', 'pe' => 'Peru', 'pf' => 'French Polynesia', 'pg' => 'Papua New Guinea', 'ph' => 'Philippines', 'pk' => 'Pakistan', 'pl' => 'Poland', 'pm' => 'St. Pierre and Miquelon', 'pn' => 'Pitcairn', 'pr' => 'Puerto Rico', 'pt' => 'Portugal', 'pw' => 'Palau', 'py' => 'Paraguay', 'qa' => 'Qatar', 're' => 'Reunion', 'ro' => 'Romania', 'ru' => 'Russia', 'rw' => 'Rwanda', 'sa' => 'Saudi Arabia', 'sb' => 'Solomon Islands', 'sc' => 'Seychelles', 'sd' => 'Sudan', 'se' => 'Sweden', 'sg' => 'Singapore', 'sh' => 'St. Helena', 'si' => 'Slovenia', 'sj' => 'Svalbard and Jan Mayen Islands', 'sk' => 'Slovakia (Slovak Republic)', 'sl' => 'Sierra Leone', 'sm' => 'San Marino', 'sn' => 'Senegal', 'so' => 'Somalia', 'sr' => 'Suriname', 'st' => 'Sao Tome and Principe', 'sv' => 'El Salvador', 'sy' => 'Syria', 'sz' => 'Swaziland', 'tc' => 'Turks and Caicos Islands', 'td' => 'Chad', 'tf' => 'French Southern Territories', 'tg' => 'Togo', 'th' => 'Thailand', 'tj' => 'Tajikistan', 'tk' => 'Tokelau', 'tm' => 'Turkmenistan', 'tn' => 'Tunisia', 'to' => 'Tonga', 'tp' => 'East Timor', 'tr' => 'Turkey', 'tt' => 'Trinidad, Tobago', 'tv' => 'Tuvalu', 'tw' => 'Taiwan', 'tz' => 'Tanzania', 'ua' => 'Ukraine', 'ug' => 'Uganda', 'uk' => 'United Kingdom', 'um' => 'United States Minor Islands', 'us' => 'United States of America', 'uy' => 'Uruguay', 'uz' => 'Uzbekistan', 'va' => 'Vatican City', 'vc' => 'Saint Vincent, Grenadines', 've' => 'Venezuela', 'vg' => 'Virgin Islands (British)', 'vi' => 'Virgin Islands (USA)', 'vn' => 'Viet Nam', 'vu' => 'Vanuatu', 'wf' => 'Wallis and Futuna Islands', 'ws' => 'Samoa', 'ye' => 'Yemen', 'yt' => 'Mayotte', 'yu' => 'Yugoslavia', 'za' => 'South Africa', 'zm' => 'Zambia', 'zr' => 'Zaire', 'zw' => 'Zimbabwe'); public static function getCountries() { return self::$countries; } public function validate(Doctrine_Record $record, $key, $value, $args) { $value = strtolower($value); return isset(self::$countries[$value]); } } class Doctrine_Validator_Creditcard { public function validate(Doctrine_Record $record, $key, $value, $args) { return preg_match('#^((4\d{3})|(5[1-5]\d{2})|(6011)|(7\d{3}))-?\d{4}-?\d{4}-?\d{4}|3[4,7]\d{13}$#', $value); } } class Doctrine_Validator_Date { public function validate(Doctrine_Record $record, $key, $value, $args) { if (empty($value)) { return true; } $e = explode("-", $value); if (count($e) !== 3) { return false; } return checkdate($e[1], $e[2], $e[0]); } } class Doctrine_Validator_Email { public function validate(Doctrine_Record $record, $key, $value, $args) { if (empty($value)) { return true; } if (isset($args[0])) { $parts = explode("@", $value); if (isset($parts[1]) && function_exists("checkdnsrr")) { if ( ! checkdnsrr($parts[1], "MX")) { return false; } } } $qtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]'; $dtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]'; $atom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+'; $quoted_pair = '\\x5c[\\x00-\\x7f]'; $domain_literal = "\\x5b($dtext|$quoted_pair)*\\x5d"; $quoted_string = "\\x22($qtext|$quoted_pair)*\\x22"; $domain_ref = $atom; $sub_domain = "($domain_ref|$domain_literal)"; $word = "($atom|$quoted_string)"; $domain = "$sub_domain(\\x2e$sub_domain)+"; $local_part = "$word(\\x2e$word)*"; $addr_spec = "$local_part\\x40$domain"; return (bool)preg_match("!^$addr_spec$!", $value); } } class Doctrine_Validator_Enum { public function validate(Doctrine_Record $record, $key, $value, $args) { $max = substr_count($args, '-'); $int = (int) $value; if ($int != $value) { return false; } if ($int < 0 || $int > $max) { return false; } return true; } } class Doctrine_Validator_ErrorStack extends Doctrine_Access implements Countable, IteratorAggregate { protected $errors = array(); public function __construct() {} public function add($invalidFieldName, $errorCode = 'general') { $this->errors[$invalidFieldName][] = $errorCode; } public function remove($fieldName) { if (isset($this->errors[$fieldName])) { unset($this->errors[$fieldName]); } } public function get($fieldName) { return isset($this->errors[$fieldName]) ? $this->errors[$fieldName] : null; } public function set($fieldName, $errorCode) { $this->add($fieldName, $errorCode); } public function contains($fieldName) { return array_key_exists($fieldName, $this->errors); } public function clear() { $this->errors = array(); } public function getIterator() { return new ArrayIterator($this->errors); } public function count() { return count($this->errors); } } class Doctrine_Validator_Exception extends Doctrine_Exception implements Countable, IteratorAggregate { private $invalid = array(); public function __construct(array $invalid) { $this->invalid = $invalid; } public function getInvalidRecords() { return $this->invalid; } public function getIterator() { return new ArrayIterator($this->invalid); } public function count() { return count($this->invalid); } public function __toString() { return parent::__toString(); } } class Doctrine_Validator_HtmlColor { public function validate(Doctrine_Record $record, $key, $value, $args) { if ( ! preg_match("/^#{0,1}[0-9]{6}$/", $value)) { return false; } return true; } } class Doctrine_Validator_Ip { public function validate(Doctrine_Record $record, $key, $value, $args) { return (bool) ip2long(str_replace("\0", '', $value)); } } class Doctrine_Validator_Nospace { public function validate(Doctrine_Record $record, $key, $value, $args) { return ($value === null || ! preg_match('/\s\t\r\n/',$value)); } } class Doctrine_Validator_Notblank { public function validate(Doctrine_Record $record, $key, $value, $args) { return (trim($value) != ''); } } class Doctrine_Validator_Notnull { public function validate(Doctrine_Record $record, $key, $value) { if ($value === null || $value === '') { return false; } return true; } } class Doctrine_Validator_Range { public function validate(Doctrine_Record $record, $key, $value, $args) { if (isset($args[0]) && $value < $args[0]) { return false; } if (isset($args[1]) && $value > $args[1]) { return false; } return true; } } class Doctrine_Validator_Regexp { public function validate(Doctrine_Record $record, $key, $value, $args) { if (is_array($args)) { foreach ($args as $regexp) { if ( ! preg_match($args, $value)) { return false; } } return true; } else { if (preg_match($args, $value)) { return true; } } return false; } } class Doctrine_Validator_Unique { public function validate(Doctrine_Record $record, $key, $value, $args) { $table = $record->getTable(); $sql = 'SELECT ' . $table->getIdentifier() . ' FROM ' . $table->getTableName() . ' WHERE ' . $key . ' = ?'; $stmt = $table->getConnection()->getDbh()->prepare($sql); $stmt->execute(array($value)); return ( ! is_array($stmt->fetch())); } } class Doctrine_Validator_Usstate { private static $states = array ( "AK" => true, "AL" => true, "AR" => true, "AZ" => true, "CA" => true, "CO" => true, "CT" => true, "DC" => true, "DE" => true, "FL" => true, "GA" => true, "HI" => true, "IA" => true, "ID" => true, "IL" => true, "IN" => true, "KS" => true, "KY" => true, "LA" => true, "MA" => true, "MD" => true, "ME" => true, "MI" => true, "MN" => true, "MO" => true, "MS" => true, "MT" => true, "NC" => true, "ND" => true, "NE" => true, "NH" => true, "NJ" => true, "NM" => true, "NV" => true, "NY" => true, "OH" => true, "OK" => true, "OR" => true, "PA" => true, "PR" => true, "RI" => true, "SC" => true, "SD" => true, "TN" => true, "TX" => true, "UT" => true, "VA" => true, "VI" => true, "VT" => true, "WA" => true, "WI" => true, "WV" => true, "WY" => true ); public function getStates() { return self::$states; } public function validate(Doctrine_Record $record, $key, $value, $args) { return isset(self::$states[$value]); } } class Doctrine_ValueHolder extends Doctrine_Access implements Countable { public $data = array(); private $table; public function __construct(Doctrine_Table $table) { $this->table = $table; } public function set($name, $value) { $this->data[$name] = $value; } public function get($name) { if ( ! isset($this->data[$name])) { throw new Doctrine_Exception("Unknown property $name."); } return $this->data[$name]; } public function count() { return count($this->data); } public function delete() { throw new Doctrine_Exception("Method 'delete' not availible on Doctrine_ValueHolder."); } public function save() { throw new Doctrine_Exception("Method 'save' not availible on Doctrine_ValueHolder."); } } class Doctrine_View_Exception extends Doctrine_Exception { } class Doctrine_View { const DROP = 'DROP VIEW %s'; const CREATE = 'CREATE VIEW %s AS %s'; const SELECT = 'SELECT * FROM %s'; protected $name; protected $query; protected $conn; public function __construct(Doctrine_Query $query, $viewName) { $this->name = $viewName; $this->query = $query; $this->query->setView($this); $this->conn = $query->getConnection(); } public function getQuery() { return $this->query; } public function getName() { return $this->name; } public function getConnection() { return $this->conn; } public function create() { $sql = sprintf(self::CREATE, $this->name, $this->query->getQuery()); try { $this->conn->execute($sql); } catch(Doctrine_Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function drop() { try { $this->conn->execute(sprintf(self::DROP, $this->name)); } catch(Doctrine_Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function execute() { return $this->query->execute(); } public function getSelectSql() { return sprintf(self::SELECT, $this->name); } } 