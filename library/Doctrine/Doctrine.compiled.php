<?php class InvalidKeyException extends Exception { }abstract class Doctrine_Access implements ArrayAccess { public function setArray(array $array) { foreach($array as $k=>$v): $this->set($k,$v); endforeach; return $this; } public function __set($name,$value) { $this->set($name,$value); } public function __get($name) { return $this->get($name); } public function __isset($name) { return $this->contains($name); } public function __unset($name) { return $this->remove($name); } public function offsetExists($offset) { return $this->contains($offset); } public function offsetGet($offset) { return $this->get($offset); } public function offsetSet($offset, $value) { if( ! isset($offset)) { $this->add($value); } else $this->set($offset,$value); } public function offsetUnset($offset) { return $this->remove($offset); } } interface Doctrine_Adapter_Interface { public function prepare($prepareString); public function query($queryString); public function quote($input); public function exec($statement); public function lastInsertId(); public function beginTransaction(); public function commit(); public function rollBack(); public function errorCode(); public function errorInfo(); } final class Doctrine { const ATTR_LISTENER = 1; const ATTR_PORTABILITY = 9; const ATTR_QUOTE_IDENTIFIER = 3; const ATTR_FIELD_CASE = 4; const ATTR_IDXNAME_FORMAT = 5; const ATTR_SEQNAME_FORMAT = 6; const ATTR_SEQCOL_NAME = 7; const ATTR_VLD = 12; const ATTR_COLL_KEY = 15; const ATTR_QUERY_LIMIT = 17; const ATTR_AUTO_LENGTH_VLD = 19; const ATTR_AUTO_TYPE_VLD = 20; const ATTR_DEFAULT_TABLE_TYPE = 21; const ATTR_FETCHMODE = 2; const ATTR_BATCH_SIZE = 8; const ATTR_LOCKMODE = 11; const ATTR_NAME_PREFIX = 13; const ATTR_CREATE_TABLES = 14; const ATTR_COLL_LIMIT = 16; const ATTR_ACCESSORS = 18; const ATTR_ACCESSOR_PREFIX_GET = 22; const ATTR_ACCESSOR_PREFIX_SET = 23; const LIMIT_ROWS = 1; const LIMIT_RECORDS = 2; const FETCH_IMMEDIATE = 0; const FETCH_BATCH = 1; const FETCH_LAZY = 2; const FETCH_OFFSET = 3; const FETCH_LAZY_OFFSET = 4; const FETCH_VHOLDER = 1; const FETCH_RECORD = 2; const FETCH_ARRAY = 3; const ACCESSOR_NONE = 0; const ACCESSOR_GET = 1; const ACCESSOR_SET = 2; const ACCESSOR_BOTH = 3; const PORTABILITY_NONE = 0; const PORTABILITY_FIX_CASE = 1; const PORTABILITY_RTRIM = 2; const PORTABILITY_DELETE_COUNT = 4; const PORTABILITY_EMPTY_TO_NULL = 8; const PORTABILITY_FIX_ASSOC_FIELD_NAMES = 16; const PORTABILITY_ALL = 17; const LOCK_OPTIMISTIC = 0; const LOCK_PESSIMISTIC = 1; public function __construct() { throw new Doctrine_Exception('Doctrine is static class. No instances can be created.'); } private static $path; public static function getPath() { if(! self::$path) self::$path = dirname(__FILE__); return self::$path; } public static function loadAll() { $classes = Doctrine_Compiler::getRuntimeClasses(); foreach($classes as $class) { Doctrine::autoload($class); } } public static function import($directory) { Doctrine_Import::import(); } public static function export($directory) { Doctrine_Export::export(); } public static function compile() { Doctrine_Compiler::compile(); } public static function autoload($classname) { if(! self::$path) self::$path = dirname(__FILE__); if(class_exists($classname)) return false; $class = self::$path.DIRECTORY_SEPARATOR . str_replace('_', DIRECTORY_SEPARATOR,$classname) . '.php'; if( ! file_exists($class)) return false; require_once($class); return true; } public static function tableize($classname) { return strtolower(preg_replace('~(?<=\\w)([A-Z])~', '_$1', $classname)); } public static function classify($tablename) { return preg_replace('~(_?)(_)([\w])~e', '"$1".strtoupper("$3")', ucfirst($tablename)); } public static function isValidClassname($classname) { if(preg_match('~(^[a-z])|(_[a-z])|([\W])|(_{2})~', $classname)) throw new Doctrine_Exception("Class name is not valid. Use camel case and underscores (i.e My_PerfectClass)."); return true; } } abstract class Doctrine_Configurable { private $attributes = array(); private $parent; public function setAttribute($attribute,$value) { switch($attribute): case Doctrine::ATTR_BATCH_SIZE: if($value < 0) throw new Doctrine_Exception("Batch size should be greater than or equal to zero"); break; case Doctrine::ATTR_FETCHMODE: if($value < 0) throw new Doctrine_Exception("Unknown fetchmode. See Doctrine::FETCH_* constants."); break; case Doctrine::ATTR_LISTENER: $this->setEventListener($value); break; case Doctrine::ATTR_LOCKMODE: if($this instanceof Doctrine_Connection) { if($this->transaction->getState() != Doctrine_Transaction::STATE_SLEEP) throw new Doctrine_Exception("Couldn't set lockmode. There are transactions open."); } elseif($this instanceof Doctrine_Manager) { foreach($this as $connection) { if($connection->transaction->getState() != Doctrine_Transaction::STATE_SLEEP) throw new Doctrine_Exception("Couldn't set lockmode. There are transactions open."); } } else { throw new Doctrine_Exception("Lockmode attribute can only be set at the global or connection level."); } break; case Doctrine::ATTR_CREATE_TABLES: $value = (bool) $value; break; case Doctrine::ATTR_ACCESSORS: $accessors = array('none','get','set','both'); break; case Doctrine::ATTR_COLL_LIMIT: if($value < 1) { throw new Doctrine_Exception("Collection limit should be a value greater than or equal to 1."); } break; case Doctrine::ATTR_COLL_KEY: if( ! ($this instanceof Doctrine_Table)) throw new Doctrine_Exception("This attribute can only be set at table level."); if( ! $this->hasColumn($value)) throw new Doctrine_Exception("Couldn't set collection key attribute. No such column '$value'"); break; case Doctrine::ATTR_VLD: case Doctrine::ATTR_AUTO_LENGTH_VLD: case Doctrine::ATTR_AUTO_TYPE_VLD: case Doctrine::ATTR_QUERY_LIMIT: case Doctrine::ATTR_QUOTE_IDENTIFIER: case Doctrine::ATTR_PORTABILITY: case Doctrine::ATTR_DEFAULT_TABLE_TYPE: case Doctrine::ATTR_ACCESSOR_PREFIX_GET: case Doctrine::ATTR_ACCESSOR_PREFIX_SET: break; case Doctrine::ATTR_SEQCOL_NAME: if( ! is_string($value)) throw new Doctrine_Exception('Sequence column name attribute only accepts string values'); break; case Doctrine::ATTR_FIELD_CASE: if($value != 0 && $value != CASE_LOWER && $value != CASE_UPPER) throw new Doctrine_Exception('Field case attribute should be either 0, CASE_LOWER or CASE_UPPER constant.'); break; case Doctrine::ATTR_SEQNAME_FORMAT: case Doctrine::ATTR_IDXNAME_FORMAT: if($this instanceof Doctrine_Table) { throw new Doctrine_Exception('Sequence / index name format attributes cannot be set' . 'at table level (only at connection or global level).'); } break; default: throw new Doctrine_Exception("Unknown attribute."); endswitch; $this->attributes[$attribute] = $value; } public function setEventListener($listener) { return $this->setListener($listener); } public function addListener($listener, $name = null) { if( ! ($this->attributes[Doctrine::ATTR_LISTENER] instanceof Doctrine_EventListener_Chain)) $this->attributes[Doctrine::ATTR_LISTENER] = new Doctrine_EventListener_Chain(); $this->attributes[Doctrine::ATTR_LISTENER]->add($listener, $name); return $this; } public function getListener() { if( ! isset($this->attributes[Doctrine::ATTR_LISTENER])) { if(isset($this->parent)) return $this->parent->getListener(); return null; } return $this->attributes[Doctrine::ATTR_LISTENER]; } public function setListener($listener) { if( ! ($listener instanceof Doctrine_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) throw new Doctrine_Exception("Couldn't set eventlistener. EventListeners should implement either Doctrine_EventListener_Interface or Doctrine_Overloadable"); $this->attributes[Doctrine::ATTR_LISTENER] = $listener; return $this; } public function getAttribute($attribute) { $attribute = (int) $attribute; if($attribute < 1 || $attribute > 23) throw new Doctrine_Exception('Unknown attribute.'); if( ! isset($this->attributes[$attribute])) { if(isset($this->parent)) return $this->parent->getAttribute($attribute); return null; } return $this->attributes[$attribute]; } public function getAttributes() { return $this->attributes; } public function setParent(Doctrine_Configurable $component) { $this->parent = $component; } public function getParent() { return $this->parent; } } class Doctrine_Collection extends Doctrine_Access implements Countable, IteratorAggregate, Serializable { protected $data = array(); protected $table; protected $reference; protected $reference_field; protected $relation; protected $expandable = true; protected $expanded = array(); protected $keyColumn; protected static $null; protected $aggregateValues = array(); public function __construct($table) { if( ! ($table instanceof Doctrine_Table)) $table = Doctrine_Manager::getInstance() ->getCurrentConnection() ->getTable($table); $this->table = $table; $name = $table->getAttribute(Doctrine::ATTR_COLL_KEY); if($name !== null) { $this->keyColumn = $name; } } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function getTable() { return $this->table; } public function setAggregateValue($name, $value) { $this->aggregateValues[$name] = $value; } public function getAggregateValue($name) { return $this->aggregateValues[$name]; } public function serialize() { $vars = get_object_vars($this); unset($vars['reference']); unset($vars['reference_field']); unset($vars['relation']); unset($vars['expandable']); unset($vars['expanded']); unset($vars['generator']); $vars['table'] = $vars['table']->getComponentName(); return serialize($vars); } public function unserialize($serialized) { $manager = Doctrine_Manager::getInstance(); $connection = $manager->getCurrentConnection(); $array = unserialize($serialized); foreach($array as $name => $values) { $this->$name = $values; } $this->table = $connection->getTable($this->table); $this->expanded = array(); $this->expandable = true; $name = $this->table->getAttribute(Doctrine::ATTR_COLL_KEY); if($name !== null) { $this->keyColumn = $name; } } public function isExpanded($offset) { return isset($this->expanded[$offset]); } public function isExpandable() { return $this->expandable; } public function setKeyColumn($column) { $this->keyColumn = $column; } public function getKeyColumn() { return $this->column; } public function getData() { return $this->data; } public function addData(array $data) { $this->data[] = $data; } public function getFirst() { return reset($this->data); } public function getLast() { return end($this->data); } public function setReference(Doctrine_Record $record,Doctrine_Relation $relation) { $this->reference = $record; $this->relation = $relation; if($relation instanceof Doctrine_Relation_ForeignKey || $relation instanceof Doctrine_Relation_LocalKey) { $this->reference_field = $relation->getForeign(); $value = $record->get($relation->getLocal()); foreach($this->getNormalIterator() as $record) { if($value !== null) { $record->set($this->reference_field, $value, false); } else { $record->set($this->reference_field, $this->reference, false); } } } elseif($relation instanceof Doctrine_Relation_Association) { } } public function getReference() { return $this->reference; } public function expand($key) { $where = array(); $params = array(); $limit = null; $offset = null; switch(get_class($this)): case "Doctrine_Collection_Offset": $limit = $this->getLimit(); $offset = (floor($key / $limit) * $limit); if( ! $this->expandable && isset($this->expanded[$offset])) return false; $fields = implode(", ",$this->table->getColumnNames()); break; default: if( ! $this->expandable) return false; if( ! isset($this->reference)) return false; $id = $this->reference->obtainIdentifier(); if(empty($id)) return false; switch(get_class($this)): case "Doctrine_Collection_Immediate": $fields = implode(", ",$this->table->getColumnNames()); break; default: $fields = implode(", ",$this->table->getPrimaryKeys()); endswitch; endswitch; if(isset($this->relation)) { if($this->relation instanceof Doctrine_Relation_ForeignKey) { $params[] = $this->reference->getIncremented(); $where[] = $this->reference_field." = ?"; if( ! isset($offset)) { $ids = $this->getPrimaryKeys(); if( ! empty($ids)) { $where[] = $this->table->getIdentifier()." NOT IN (".substr(str_repeat("?, ",count($ids)),0,-2).")"; $params = array_merge($params,$ids); } $this->expandable = false; } } elseif($this->relation instanceof Doctrine_Relation_Association) { $asf = $this->relation->getAssociationFactory(); $query = 'SELECT '.$foreign." FROM ".$asf->getTableName()." WHERE ".$local."=".$this->getIncremented(); $table = $fk->getTable(); $graph = new Doctrine_Query($table->getConnection()); $q = 'FROM ' . $table->getComponentName() . ' WHERE ' . $table->getComponentName() . '.' . $table->getIdentifier()." IN ($query)"; } } $query = "SELECT ".$fields." FROM ".$this->table->getTableName(); foreach($this->table->getInheritanceMap() as $k => $v) { $where[] = $k." = ?"; $params[] = $v; } if( ! empty($where)) { $query .= " WHERE ".implode(" AND ",$where); } $coll = $this->table->execute($query, $params, $limit, $offset); if( ! isset($offset)) { foreach($coll as $record) { if(isset($this->reference_field)) $record->set($this->reference_field,$this->reference, false); $this->reference->addReference($record, $this->relation); } } else { $i = $offset; foreach($coll as $record) { if(isset($this->reference)) { $this->reference->addReference($record, $this->relation, $i); } else $this->data[$i] = $record; $i++; } $this->expanded[$offset] = true; if(count($coll) < $limit) { $this->expandable = false; } } return $coll; } public function remove($key) { if( ! isset($this->data[$key])) { $this->expand($key); throw new InvalidKeyException(); } $removed = $this->data[$key]; unset($this->data[$key]); return $removed; } public function contains($key) { return isset($this->data[$key]); } public function get($key) { if( ! isset($this->data[$key])) { $this->expand($key); if( ! isset($this->data[$key])) $this->data[$key] = $this->table->create(); if(isset($this->reference_field)) { $value = $this->reference->get($this->relation->getLocal()); if($value !== null) { $this->data[$key]->set($this->reference_field, $value, false); } else { $this->data[$key]->set($this->reference_field, $this->reference, false); } } } return $this->data[$key]; } public function getPrimaryKeys() { $list = array(); $name = $this->table->getIdentifier(); foreach($this->data as $record): if(is_array($record) && isset($record[$name])) { $list[] = $record[$name]; } else { $list[] = $record->getIncremented(); } endforeach; return $list; } public function getKeys() { return array_keys($this->data); } public function count() { return count($this->data); } public function set($key, Doctrine_Record $record) { if(isset($this->reference_field)) $record->set($this->reference_field, $this->reference, false); $this->data[$key] = $record; } public function add(Doctrine_Record $record,$key = null) { if(isset($this->reference_field)) $record->set($this->reference_field, $this->reference, false); foreach($this->data as $val) { if($val === $record) return false; } if(isset($key)) { if(isset($this->data[$key])) return false; $this->data[$key] = $record; return true; } if(isset($this->keyColumn)) { $value = $record->get($this->keyColumn); if($value === null) throw new Doctrine_Collection_Exception("Couldn't create collection index. Record field '".$this->keyColumn."' was null."); $this->data[$value] = $record; } else $this->data[] = $record; return true; } public function loadRelated($name = null) { $query = new Doctrine_Query($this->table->getConnection()); if( ! isset($name)) { foreach($this->data as $record): $value = $record->getIncremented(); if($value !== null) $list[] = $value; endforeach; $query->from($this->table->getComponentName()."(".implode(", ",$this->table->getPrimaryKeys()).")"); $query->where($this->table->getComponentName().".id IN (".substr(str_repeat("?, ", count($list)),0,-2).")"); return $query; } $rel = $this->table->getRelation($name); $table = $rel->getTable(); $foreign = $rel->getForeign(); $local = $rel->getLocal(); $list = array(); if($rel instanceof Doctrine_Relation_LocalKey || $rel instanceof Doctrine_Relation_ForeignKey) { foreach($this->data as $record): $list[] = $record[$local]; endforeach; } else { foreach($this->data as $record): $value = $record->getIncremented(); if($value !== null) $list[] = $value; endforeach; } $this->table->getRelation($name); $dql = $rel->getRelationDql(count($list), 'collection'); $coll = $query->query($dql, $list); $this->populateRelated($name, $coll); } public function populateRelated($name, Doctrine_Collection $coll) { $rel = $this->table->getRelation($name); $table = $rel->getTable(); $foreign = $rel->getForeign(); $local = $rel->getLocal(); if($rel instanceof Doctrine_Relation_LocalKey) { foreach($this->data as $key => $record) { foreach($coll as $k => $related) { if($related[$foreign] == $record[$local]) { $this->data[$key]->setRelated($name, $related); } } } } elseif($rel instanceof Doctrine_Relation_ForeignKey) { foreach($this->data as $key => $record) { if($record->getState() == Doctrine_Record::STATE_TCLEAN || $record->getState() == Doctrine_Record::STATE_TDIRTY) continue; $sub = new Doctrine_Collection($table); foreach($coll as $k => $related) { if($related[$foreign] == $record[$local]) { $sub->add($related); $coll->remove($k); } } $this->data[$key]->setRelated($name, $sub); } } elseif($rel instanceof Doctrine_Relation_Association) { $identifier = $this->table->getIdentifier(); $asf = $rel->getAssociationFactory(); $name = $table->getComponentName(); foreach($this->data as $key => $record) { if($record->getState() == Doctrine_Record::STATE_TCLEAN || $record->getState() == Doctrine_Record::STATE_TDIRTY) continue; $sub = new Doctrine_Collection($table); foreach($coll as $k => $related) { if($related->get($local) == $record[$identifier]) { $sub->add($related->get($name)); } } $this->data[$key]->setRelated($name, $sub); } } } public function getNormalIterator() { return new Doctrine_Collection_Iterator_Normal($this); } public function save(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->table->getConnection(); } $conn->beginTransaction(); foreach($this as $key => $record): $record->save(); endforeach; $conn->commit(); } public function delete(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->table->getConnection(); } $conn->beginTransaction(); foreach($this as $key => $record) { $record->delete(); } $conn->commit(); $this->data = array(); } public function getIterator() { $data = $this->data; return new ArrayIterator($data); } public function __toString() { return Doctrine_Lib::getCollectionAsString($this); } } class Doctrine_Collection_Immediate extends Doctrine_Collection { public function __construct(Doctrine_Table $table) { parent::__construct($table); } } abstract class Doctrine_Connection extends Doctrine_Configurable implements Countable, IteratorAggregate { protected $dbh; protected $tables = array(); protected $driverName; protected $supported = array(); private $modules = array('transaction' => false, 'expression' => false, 'dataDict' => false, 'export' => false, 'unitOfWork' => false, ); protected $properties = array('sql_comments' => array(array('start' => '--', 'end' => "\n", 'escape' => false), array('start' => '/*', 'end' => '*/', 'escape' => false) ), 'identifier_quoting' => array('start' => '"', 'end' => '"', 'escape' => '"' ), 'string_quoting' => array('start' => "'", 'end' => "'", 'escape' => false, 'escape_pattern' => false ), 'wildcards' => array('%', '_') ); private static $availibleDrivers = array( 'Mysql', 'Pgsql', 'Oracle', 'Informix', 'Mssql', 'Sqlite', 'Firebird' ); public function __construct(Doctrine_Manager $manager, $adapter) { if( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) throw new Doctrine_Connection_Exception("First argument should be an instance of PDO or implement Doctrine_Adapter_Interface"); $this->dbh = $adapter; $this->modules['unitOfWork'] = new Doctrine_Connection_UnitOfWork($this); $this->setParent($manager); $this->dbh->setAttribute(PDO::ATTR_CASE, PDO::CASE_NATURAL); $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $this->getAttribute(Doctrine::ATTR_LISTENER)->onOpen($this); } public function getName() { return $this->driverName; } public function __get($name) { if( ! isset($this->modules[$name])) throw new Doctrine_Connection_Exception('Unknown module ' . $name); if($this->modules[$name] === false) { switch($name) { case 'unitOfWork': $this->modules[$name] = new Doctrine_Connection_UnitOfWork($this); break; default: $class = 'Doctrine_' . ucwords($name) . '_' . $this->getName(); $this->modules[$name] = new $class($this); } } if(isset($this->properties[$name])) return $this->properties[$name]; return $this->modules[$name]; } public function escapePattern($text) { if ($this->string_quoting['escape_pattern']) { $text = str_replace($this->string_quoting['escape_pattern'], $this->string_quoting['escape_pattern'] . $this->string_quoting['escape_pattern'], $text); foreach ($this->wildcards as $wildcard) { $text = str_replace($wildcard, $this->string_quoting['escape_pattern'] . $wildcard, $text); } } return $text; } public function quoteIdentifier($str, $checkOption = true) { if ($checkOption && ! $this->getAttribute(Doctrine::ATTR_QUOTE_IDENTIFIER)) { return $str; } $str = str_replace($this->properties['identifier_quoting']['end'], $this->properties['identifier_quoting']['escape'] . $this->properties['identifier_quoting']['end'], $str); return $this->properties['identifier_quoting']['start'] . $str . $this->properties['identifier_quoting']['end']; } public function getManager() { return $this->getParent(); } public function getDbh() { return $this->dbh; } public function driverName($name) { } public function supports($feature) { return (isset($this->supported[$feature]) && $this->supported[$feature] === 'emulated' || $this->supported[$feature]); } public function quote($input, $type = null) { if($type == null) { $type = gettype($input); } switch($type) { case 'integer': case 'enum': case 'boolean': return $input; case 'array': case 'object': $input = serialize($input); case 'string': case 'char': case 'varchar': case 'text': case 'gzip': case 'blob': case 'clob': return $this->dbh->quote($input); } } public function fixSequenceName($sqn) { $seqPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT)).'$/i'; $seqName = preg_replace($seqPattern, '\\1', $sqn); if ($seqName && ! strcasecmp($sqn, $db->getSequenceName($seqName))) { return $seqName; } return $sqn; } public function fixIndexName($idx) { $indexPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT)).'$/i'; $indexName = preg_replace($indexPattern, '\\1', $idx); if ($indexName && ! strcasecmp($idx, $this->getIndexName($indexName))) { return $indexName; } return $idx; } public function getSequenceName($sqn) { return sprintf($this->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT), preg_replace('/[^a-z0-9_\$.]/i', '_', $sqn)); } public function getIndexName($idx) { return sprintf($this->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT), preg_replace('/[^a-z0-9_\$]/i', '_', $idx)); } public function replace($table, array $fields, array $keys) { if(empty($keys)) throw new Doctrine_Connection_Exception('Not specified which fields are keys'); $condition = $values = array(); foreach($fields as $name => $value) { $values[$name] = $value; if(in_array($name, $keys)) { if($value === null) throw new Doctrine_Connection_Exception('key value '.$name.' may not be null'); $condition[] = $name . ' = ?'; $conditionValues[] = $value; } } $query = 'DELETE FROM '. $table . ' WHERE ' . implode(' AND ', $condition); $affectedRows = $this->dbh->exec($query); $this->insert($table, $values); $affectedRows++; return $affectedRows; } public function insert($table, array $values = array()) { if(empty($values)) return false; $cols = array_keys($values); $query = "INSERT INTO $table " . '(' . implode(', ', $cols) . ') ' . 'VALUES (' . substr(str_repeat('?, ', count($values)), 0, -2) . ')'; $stmt = $this->dbh->prepare($query); $stmt->execute(array_values($values)); return true; } public function nextId($sequence) { throw new Doctrine_Connection_Exception('NextId() for sequences not supported by this driver.'); } public function setCharset($charset) { } public function fetchAll($statement, array $params = array()) { return $this->query($statement, $params)->fetchAll(PDO::FETCH_ASSOC); } public function fetchOne($statement, array $params = array()) { return current($this->execute($statement, $params)->fetch(PDO::FETCH_NUM)); } public function fetchRow($statement, array $params = array()) { return $this->query($statement, $params)->fetch(PDO::FETCH_ASSOC); } public function fetchArray($statement, array $params = array()) { return $this->query($statement, $params)->fetch(PDO::FETCH_NUM); } public function fetchColumn($statement, array $params = array()) { $result = $this->query($statement, $params)->fetchAll(PDO::FETCH_COLUMN); if($this->options['portability'] & Doctrine::PORTABILITY_FIX_CASE) $result = array_map(($db->options['field_case'] == CASE_LOWER ? 'strtolower' : 'strtoupper'), $result); return $result; } public function fetchAssoc($statement, array $params = array()) { return $this->query($statement, $params)->fetchAll(PDO::FETCH_ASSOC); } public function fetchBoth($statement, array $params = array()) { return $this->query($statement, $params)->fetchAll(PDO::FETCH_BOTH); } public function query($query, array $params = array()) { $parser = new Doctrine_Query($this); return $parser->query($query, $params); } public function queryOne($query, array $params = array()) { $parser = new Doctrine_Query($this); $coll = $parser->query($query, $params); if( ! $coll->contains(0)) return false; return $coll[0]; } public function select($query,$limit = 0,$offset = 0) { if($limit > 0 || $offset > 0) $query = $this->modifyLimitQuery($query, $limit, $offset); return $this->dbh->query($query); } public function execute($query, array $params = array()) { if( ! empty($params)) { $stmt = $this->dbh->prepare($query); $stmt->execute($params); return $stmt; } else { return $this->dbh->query($query); } } public function hasTable($name) { return isset($this->tables[$name]); } public function getTable($name) { if(isset($this->tables[$name])) return $this->tables[$name]; $class = $name."Table"; if(class_exists($class) && in_array("Doctrine_Table", class_parents($class))) { return new $class($name, $this); } else { return new Doctrine_Table($name, $this); } } public function getTables() { return $this->tables; } public function getIterator() { return new ArrayIterator($this->tables); } public function count() { return count($this->tables); } public function addTable(Doctrine_Table $objTable) { $name = $objTable->getComponentName(); if(isset($this->tables[$name])) return false; $this->tables[$name] = $objTable; return true; } public function create($name) { return $this->getTable($name)->create(); } public function flush() { $this->beginTransaction(); $this->unitOfWork->saveAll(); $this->commit(); } public function clear() { foreach($this->tables as $k => $table) { $table->getRepository()->evictAll(); $table->clear(); } } public function evictTables() { $this->tables = array(); } public function close() { $this->getAttribute(Doctrine::ATTR_LISTENER)->onPreClose($this); $this->clear(); $this->getAttribute(Doctrine::ATTR_LISTENER)->onClose($this); } public function getTransactionLevel() { return $this->transaction->getTransactionLevel(); } public function beginTransaction() { $this->transaction->beginTransaction(); } public function commit() { $this->transaction->commit(); } public function rollback() { $this->transaction->rollback(); } public function save(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreSave($record); switch($record->getState()): case Doctrine_Record::STATE_TDIRTY: $this->unitOfWork->insert($record); break; case Doctrine_Record::STATE_DIRTY: case Doctrine_Record::STATE_PROXY: $this->unitOfWork->update($record); break; case Doctrine_Record::STATE_CLEAN: case Doctrine_Record::STATE_TCLEAN: break; endswitch; $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onSave($record); } public function delete(Doctrine_Record $record) { if( ! $record->exists()) return false; $this->beginTransaction(); $record->getTable()->getListener()->onPreDelete($record); $this->unitOfWork->deleteComposites($record); $this->transaction->addDelete($record); $record->getTable()->getListener()->onDelete($record); $this->commit(); return true; } public function __toString() { return Doctrine_Lib::getConnectionAsString($this); } } class Doctrine_Connection_Exception extends Doctrine_Exception { protected static $errorMessages = array( Doctrine::ERR => 'unknown error', Doctrine::ERR_ALREADY_EXISTS => 'already exists', Doctrine::ERR_CANNOT_CREATE => 'can not create', Doctrine::ERR_CANNOT_ALTER => 'can not alter', Doctrine::ERR_CANNOT_REPLACE => 'can not replace', Doctrine::ERR_CANNOT_DELETE => 'can not delete', Doctrine::ERR_CANNOT_DROP => 'can not drop', Doctrine::ERR_CONSTRAINT => 'constraint violation', Doctrine::ERR_CONSTRAINT_NOT_NULL=> 'null value violates not-null constraint', Doctrine::ERR_DIVZERO => 'division by zero', Doctrine::ERR_INVALID => 'invalid', Doctrine::ERR_INVALID_DATE => 'invalid date or time', Doctrine::ERR_INVALID_NUMBER => 'invalid number', Doctrine::ERR_MISMATCH => 'mismatch', Doctrine::ERR_NODBSELECTED => 'no database selected', Doctrine::ERR_NOSUCHFIELD => 'no such field', Doctrine::ERR_NOSUCHTABLE => 'no such table', Doctrine::ERR_NOT_CAPABLE => 'Doctrine backend not capable', Doctrine::ERR_NOT_FOUND => 'not found', Doctrine::ERR_NOT_LOCKED => 'not locked', Doctrine::ERR_SYNTAX => 'syntax error', Doctrine::ERR_UNSUPPORTED => 'not supported', Doctrine::ERR_VALUE_COUNT_ON_ROW => 'value count on row', Doctrine::ERR_INVALID_DSN => 'invalid DSN', Doctrine::ERR_CONNECT_FAILED => 'connect failed', Doctrine::ERR_NEED_MORE_DATA => 'insufficient data supplied', Doctrine::ERR_EXTENSION_NOT_FOUND=> 'extension not found', Doctrine::ERR_NOSUCHDB => 'no such database', Doctrine::ERR_ACCESS_VIOLATION => 'insufficient permissions', Doctrine::ERR_LOADMODULE => 'error while including on demand module', Doctrine::ERR_TRUNCATED => 'truncated', Doctrine::ERR_DEADLOCK => 'deadlock detected', ); public function errorMessage($value = null) { return isset(self::$errorMessages[$value]) ? self::$errorMessages[$value] : self::$errorMessages[Doctrine::ERR]; } } class Doctrine_Connection_UnitOfWork extends Doctrine_Connection_Module implements IteratorAggregate, Countable { public function buildFlushTree(array $tables) { $tree = array(); foreach($tables as $k => $table) { $k = $k.$table; if( ! ($table instanceof Doctrine_Table)) $table = $this->conn->getTable($table); $nm = $table->getComponentName(); $index = array_search($nm,$tree); if($index === false) { $tree[] = $nm; $index = max(array_keys($tree)); } $rels = $table->getRelations(); foreach($rels as $key => $rel) { if($rel instanceof Doctrine_Relation_ForeignKey) { unset($rels[$key]); array_unshift($rels, $rel); } } foreach($rels as $rel) { $name = $rel->getTable()->getComponentName(); $index2 = array_search($name,$tree); $type = $rel->getType(); if($name === $nm) continue; if($rel instanceof Doctrine_Relation_ForeignKey) { if($index2 !== false) { if($index2 >= $index) continue; unset($tree[$index]); array_splice($tree,$index2,0,$nm); $index = $index2; } else { $tree[] = $name; } } elseif($rel instanceof Doctrine_Relation_LocalKey) { if($index2 !== false) { if($index2 <= $index) continue; unset($tree[$index2]); array_splice($tree,$index,0,$name); } else { array_unshift($tree,$name); $index++; } } elseif($rel instanceof Doctrine_Relation_Association) { $t = $rel->getAssociationFactory(); $n = $t->getComponentName(); if($index2 !== false) unset($tree[$index2]); array_splice($tree,$index, 0,$name); $index++; $index3 = array_search($n,$tree); if($index3 !== false) { if($index3 >= $index) continue; unset($tree[$index]); array_splice($tree,$index3,0,$n); $index = $index2; } else { $tree[] = $n; } } } } return array_values($tree); } public function saveRelated(Doctrine_Record $record) { $saveLater = array(); foreach($record->getReferences() as $k=>$v) { $fk = $record->getTable()->getRelation($k); if($fk instanceof Doctrine_Relation_ForeignKey || $fk instanceof Doctrine_Relation_LocalKey) { if($fk->isComposite()) { $local = $fk->getLocal(); $foreign = $fk->getForeign(); if($record->getTable()->hasPrimaryKey($fk->getLocal())) { if( ! $record->exists()) $saveLater[$k] = $fk; else $v->save(); } else { $obj = $record->get($fk->getTable()->getComponentName()); if($obj->getState() != Doctrine_Record::STATE_TCLEAN) $obj->save(); } } } elseif($fk instanceof Doctrine_Relation_Association) { $v->save(); } } return $saveLater; } public function saveAssociations(Doctrine_Record $record) { foreach($record->getTable()->getRelations() as $rel) { $table = $rel->getTable(); $alias = $rel->getAlias(); $rel->processDiff($record); } } public function deleteComposites(Doctrine_Record $record) { foreach($record->getTable()->getRelations() as $fk) { switch($fk->getType()): case Doctrine_Relation::ONE_COMPOSITE: case Doctrine_Relation::MANY_COMPOSITE: $obj = $record->get($fk->getAlias()); $obj->delete(); break; endswitch; } } public function saveAll() { $tree = $this->buildFlushTree($this->conn->getTables()); foreach($tree as $name) { $table = $this->conn->getTable($name); foreach($table->getRepository() as $record) { $this->conn->save($record); } } foreach($tree as $name) { $table = $this->conn->getTable($name); foreach($table->getRepository() as $record) { $this->saveAssociations($record); } } } public function update(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreUpdate($record); $array = $record->getPrepared(); if(empty($array)) return false; $set = array(); foreach($array as $name => $value): $set[] = $name." = ?"; if($value instanceof Doctrine_Record) { switch($value->getState()): case Doctrine_Record::STATE_TCLEAN: case Doctrine_Record::STATE_TDIRTY: $record->save(); default: $array[$name] = $value->getIncremented(); $record->set($name, $value->getIncremented()); endswitch; } endforeach; $params = array_values($array); $id = $record->obtainIdentifier(); if( ! is_array($id)) $id = array($id); $id = array_values($id); $params = array_merge($params, $id); $sql = 'UPDATE ' . $record->getTable()->getTableName() . ' SET ' . implode(', ', $set) . ' WHERE ' . implode(' = ? AND ', $record->getTable()->getPrimaryKeys()) . ' = ?'; $stmt = $this->conn->getDBH()->prepare($sql); $stmt->execute($params); $record->assignIdentifier(true); $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onUpdate($record); return true; } public function insert(Doctrine_Record $record) { $record->getTable()->getAttribute(Doctrine::ATTR_LISTENER)->onPreInsert($record); $array = $record->getPrepared(); if(empty($array)) return false; $table = $record->getTable(); $keys = $table->getPrimaryKeys(); $seq = $record->getTable()->getSequenceName(); if( ! empty($seq)) { $id = $this->nextId($seq); $name = $record->getTable()->getIdentifier(); $array[$name] = $id; } $this->conn->insert($table->getTableName(), $array); if(count($keys) == 1 && $keys[0] == $table->getIdentifier()) { $id = $this->conn->getDBH()->lastInsertID(); if( ! $id) $id = $table->getMaxIdentifier(); $record->assignIdentifier($id); } else $record->assignIdentifier(true); $table->getAttribute(Doctrine::ATTR_LISTENER)->onInsert($record); return true; } public function getIterator() { } public function count() { } } class Doctrine_Db implements Countable, IteratorAggregate, Doctrine_Adapter_Interface { const ERR = -1; const ERR_SYNTAX = -2; const ERR_CONSTRAINT = -3; const ERR_NOT_FOUND = -4; const ERR_ALREADY_EXISTS = -5; const ERR_UNSUPPORTED = -6; const ERR_MISMATCH = -7; const ERR_INVALID = -8; const ERR_NOT_CAPABLE = -9; const ERR_TRUNCATED = -10; const ERR_INVALID_NUMBER = -11; const ERR_INVALID_DATE = -12; const ERR_DIVZERO = -13; const ERR_NODBSELECTED = -14; const ERR_CANNOT_CREATE = -15; const ERR_CANNOT_DELETE = -16; const ERR_CANNOT_DROP = -17; const ERR_NOSUCHTABLE = -18; const ERR_NOSUCHFIELD = -19; const ERR_NEED_MORE_DATA = -20; const ERR_NOT_LOCKED = -21; const ERR_VALUE_COUNT_ON_ROW = -22; const ERR_INVALID_DSN = -23; const ERR_CONNECT_FAILED = -24; const ERR_EXTENSION_NOT_FOUND = -25; const ERR_NOSUCHDB = -26; const ERR_ACCESS_VIOLATION = -27; const ERR_CANNOT_REPLACE = -28; const ERR_CONSTRAINT_NOT_NULL = -29; const ERR_DEADLOCK = -30; const ERR_CANNOT_ALTER = -31; const ERR_MANAGER = -32; const ERR_MANAGER_PARSE = -33; const ERR_LOADMODULE = -34; const ERR_INSUFFICIENT_DATA = -35; protected static $instances = array(); protected $isConnected = false; protected $dbh; protected $options = array('dsn' => null, 'username' => null, 'password' => null, ); protected $listener; protected $querySequence = 0; private static $driverMap = array('oracle' => 'oci8', 'postgres' => 'pgsql', 'oci' => 'oci8', 'sqlite2' => 'sqlite', 'sqlite3' => 'sqlite'); public function __construct($dsn, $user, $pass) { if( ! isset($user)) { $a = self::parseDSN($dsn); extract($a); } $this->options['dsn'] = $dsn; $this->options['username'] = $user; $this->options['password'] = $pass; $this->listener = new Doctrine_Db_EventListener(); } public function nextQuerySequence() { return ++$this->querySequence; } public function getQuerySequence() { return $this->querySequence; } public function getDBH() { return $this->dbh; } public function getOption($name) { if( ! array_key_exists($name, $this->options)) throw new Doctrine_Db_Exception('Unknown option ' . $name); return $this->options[$name]; } public function addListener($listener, $name = null) { if( ! ($this->listener instanceof Doctrine_Db_EventListener_Chain)) $this->listener = new Doctrine_Db_EventListener_Chain(); $this->listener->add($listener, $name); return $this; } public function getListener() { return $this->listener; } public function setListener($listener) { if( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) throw new Doctrine_Db_Exception("Couldn't set eventlistener for database handler. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); $this->listener = $listener; return $this; } public function connect() { if($this->isConnected) return false; $this->dbh = new PDO($this->options['dsn'], $this->options['username'], $this->options['password']); $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $this->dbh->setAttribute(PDO::ATTR_STATEMENT_CLASS, array("Doctrine_Db_Statement", array($this))); $this->isConnected = true; return true; } public static function getConnection($dsn = null, $username = null, $password = null) { return new self($dsn, $username, $password); } public static function driverName($name) { if(isset(self::$driverMap[$name])) return self::$driverMap[$name]; return $name; } function parseDSN($dsn) { $parts = @parse_url($dsn); $names = array('scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment'); foreach($names as $name) { if( ! isset($parts[$name])) $parts[$name] = null; } if(count($parts) == 0 || ! isset($parts['scheme'])) throw new Doctrine_Db_Exception('Empty data source name'); $drivers = self::getAvailableDrivers(); $parts['scheme'] = self::driverName($parts['scheme']); if( ! in_array($parts['scheme'], $drivers)) throw new Doctrine_Db_Exception('Driver '.$parts['scheme'].' not availible or extension not loaded'); switch($parts['scheme']) { case 'sqlite': if(isset($parts['host']) && $parts['host'] == ':memory') { $parts['database'] = ':memory:'; $parts['dsn'] = 'sqlite::memory:'; } break; case 'mysql': case 'informix': case 'oci8': case 'mssql': case 'firebird': case 'pgsql': case 'odbc': if( ! isset($parts['path']) || $parts['path'] == '/') throw new Doctrine_Db_Exception('No database availible in data source name'); if(isset($parts['path'])) $parts['database'] = substr($parts['path'], 1); if( ! isset($parts['host'])) throw new Doctrine_Db_Exception('No hostname set in data source name'); $parts['dsn'] = $parts["scheme"].":host=".$parts["host"].";dbname=".$parts["database"]; break; default: throw new Doctrine_Db_Exception('Unknown driver '.$parts['scheme']); } return $parts; } public static function clear() { self::$instances = array(); } public function errorCode() { return $this->dbh->errorCode(); } public function errorInfo() { return $this->dbh->errorInfo(); } public function prepare($statement) { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::PREPARE, $statement); $this->listener->onPrePrepare($event); $stmt = $this->dbh->prepare($statement); $this->listener->onPrepare($event); $this->querySequence++; return $stmt; } public function query($statement, array $params = array()) { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::QUERY, $statement); $this->listener->onPreQuery($event); if( ! empty($params)) $stmt = $this->dbh->query($statement)->execute($params); else $stmt = $this->dbh->query($statement); $this->listener->onQuery($event); $this->querySequence++; return $stmt; } public function quote($input) { $this->connect(); return $this->dbh->quote($input); } public function exec($statement) { $this->connect(); $args = func_get_args(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::EXEC, $statement); $this->listener->onPreExec($event); $rows = $this->dbh->exec($statement); $this->listener->onExec($event); return $rows; } public function lastInsertId() { $this->connect(); return $this->dbh->lastInsertId(); } public function beginTransaction() { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::BEGIN); $this->listener->onPreBeginTransaction($event); $return = $this->dbh->beginTransaction(); $this->listener->onBeginTransaction($event); return $return; } public function commit() { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::COMMIT); $this->listener->onPreCommit($event); $return = $this->dbh->commit(); $this->listener->onCommit($event); return $return; } public function rollBack() { $this->connect(); $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::ROLLBACK); $this->listener->onPreRollback($event); $this->dbh->rollBack(); $this->listener->onRollback($event); } public function getAttribute($attribute) { $this->connect(); return $this->dbh->getAttribute($attribute); } public static function getAvailableDrivers() { return PDO::getAvailableDrivers(); } public function setAttribute($attribute, $value) { $this->connect(); $this->dbh->setAttribute($attribute, $value); } public function getIterator() { if($this->listener instanceof Doctrine_Db_Profiler) return $this->listener; } public function count() { return $this->querySequence; } } class Doctrine_Db_Exception extends Doctrine_Exception { } class Doctrine_Db_EventListener implements Doctrine_Db_EventListener_Interface { public function onPreQuery(Doctrine_Db_Event $event) { } public function onQuery(Doctrine_Db_Event $event) { } public function onPrePrepare(Doctrine_Db_Event $event) { } public function onPrepare(Doctrine_Db_Event $event) { } public function onPreCommit(Doctrine_Db_Event $event) { } public function onCommit(Doctrine_Db_Event $event) { } public function onPreExec(Doctrine_Db_Event $event) { } public function onExec(Doctrine_Db_Event $event) { } public function onPreRollBack(Doctrine_Db_Event $event) { } public function onRollBack(Doctrine_Db_Event $event) { } public function onPreBeginTransaction(Doctrine_Db_Event $event) { } public function onBeginTransaction(Doctrine_Db_Event $event) { } public function onPreExecute(Doctrine_Db_Event $event) { } public function onExecute(Doctrine_Db_Event $event) { } } class Doctrine_Db_Event { const QUERY = 1; const EXEC = 2; const EXECUTE = 3; const PREPARE = 4; const BEGIN = 5; const COMMIT = 6; const ROLLBACK = 7; protected $invoker; protected $query; protected $type; protected $startedMicrotime; protected $endedMicrotime; public function __construct($invoker, $type, $query = null) { $this->invoker = $invoker; $this->type = $type; $this->query = $query; } public function getQuery() { return $this->query; } public function getType() { return $this->type; } public function start() { $this->startedMicrotime = microtime(true); } public function hasEnded() { return ($this->endedMicrotime != null); } public function end() { $this->endedMicrotime = microtime(true); } public function getInvoker() { return $this->invoker; } public function getElapsedSecs() { if (is_null($this->endedMicrotime)) return false; return ($this->endedMicrotime - $this->startedMicrotime); } } class Doctrine_Db_EventListener_Chain extends Doctrine_Access implements Doctrine_Db_EventListener_Interface { private $listeners = array(); public function add($listener, $name = null) { if( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) throw new Doctrine_Db_Exception("Couldn't add eventlistener. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); if($name === null) $this->listeners[] = $listener; else $this->listeners[$name] = $listener; } public function get($name) { if( ! isset($this->listeners[$name])) throw new Doctrine_Db_Exception("Unknown listener $name"); return $this->listeners[$name]; } public function set($name, $listener) { if( ! ($listener instanceof Doctrine_Db_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) throw new Doctrine_Db_Exception("Couldn't set eventlistener. EventListeners should implement either Doctrine_Db_EventListener_Interface or Doctrine_Overloadable"); $this->listeners[$name] = $listener; } public function onQuery(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onQuery($event); } } public function onPreQuery(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreQuery($event); } } public function onPreExec(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreExec($event); } } public function onExec(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onExec($event); } } public function onPrePrepare(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPrePrepare($event); } } public function onPrepare(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPrepare($event); } } public function onPreCommit(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreCommit($event); } } public function onCommit(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onCommit($event); } } public function onPreRollBack(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreRollBack($event); } } public function onRollBack(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onRollBack($event); } } public function onPreBeginTransaction(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreBeginTransaction($event); } } public function onBeginTransaction(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onBeginTransaction($event); } } public function onPreExecute(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onPreExecute($event); } } public function onExecute(Doctrine_Db_Event $event) { foreach($this->listeners as $listener) { $listener->onExecute($event); } } } interface Doctrine_Db_EventListener_Interface { public function onPreQuery(Doctrine_Db_Event $event); public function onQuery(Doctrine_Db_Event $event); public function onPrePrepare(Doctrine_Db_Event $event); public function onPrepare(Doctrine_Db_Event $event); public function onPreExec(Doctrine_Db_Event $event); public function onExec(Doctrine_Db_Event $event); public function onPreCommit(Doctrine_Db_Event $event); public function onCommit(Doctrine_Db_Event $event); public function onPreRollBack(Doctrine_Db_Event $event); public function onRollBack(Doctrine_Db_Event $event); public function onPreBeginTransaction(Doctrine_Db_Event $event); public function onBeginTransaction(Doctrine_Db_Event $event); public function onPreExecute(Doctrine_Db_Event $event); public function onExecute(Doctrine_Db_Event $event); } class Doctrine_Db_Profiler implements Doctrine_Overloadable { private $listeners = array('query', 'prepare', 'commit', 'rollback', 'begintransaction', 'exec', 'execute', ); private $events = array(); public function __call($m, $a) { if( ! ($a[0] instanceof Doctrine_Db_Event)) throw new Doctrine_Db_Profiler_Exception("Couldn't listen event. Event should be an instance of Doctrine_Db_Event."); if(substr($m, 0, 2) !== 'on') throw new Doctrine_Db_Profiler_Exception("Couldn't invoke listener $m."); if(substr($m, 2, 3) === 'Pre' && in_array(strtolower(substr($m, 3)), $this->listeners)) { $a[0]->start(); } else { $a[0]->end(); } $this->events[] = $a[0]; } public function lastEvent() { if (empty($this->events)) { return false; } end($this->events); return current($this->events); } } class Doctrine_Db_Statement extends PDOStatement { protected $dbh; protected $querySequence; protected $baseSequence; protected $executed = false; protected function __construct($dbh) { $this->dbh = $dbh; $this->baseSequence = $this->querySequence = $this->dbh->getQuerySequence(); } public function getQuerySequence() { return $this->querySequence; } public function getBaseSequence() { return $this->baseSequence; } public function getQuery() { return $this->queryString; } public function isExecuted($executed = null) { if($executed === null) return $this->executed; $this->executed = (bool) $executed; } public function execute(array $params = null) { $event = new Doctrine_Db_Event($this, Doctrine_Db_Event::EXECUTE, $this->queryString); $this->dbh->getListener()->onPreExecute($event); $ret = parent::execute($params); $this->dbh->getListener()->onExecute($event); return $this; } } class Doctrine_Exception extends Exception { } interface Doctrine_EventListener_Interface { public function onLoad(Doctrine_Record $record); public function onPreLoad(Doctrine_Record $record); public function onUpdate(Doctrine_Record $record); public function onPreUpdate(Doctrine_Record $record); public function onCreate(Doctrine_Record $record); public function onPreCreate(Doctrine_Record $record); public function onSave(Doctrine_Record $record); public function onPreSave(Doctrine_Record $record); public function onGetProperty(Doctrine_Record $record, $property, $value); public function onSetProperty(Doctrine_Record $record, $property, $value); public function onInsert(Doctrine_Record $record); public function onPreInsert(Doctrine_Record $record); public function onDelete(Doctrine_Record $record); public function onPreDelete(Doctrine_Record $record); public function onEvict(Doctrine_Record $record); public function onPreEvict(Doctrine_Record $record); public function onSleep(Doctrine_Record $record); public function onWakeUp(Doctrine_Record $record); public function onClose(Doctrine_Connection $connection); public function onPreClose(Doctrine_Connection $connection); public function onOpen(Doctrine_Connection $connection); public function onTransactionCommit(Doctrine_Connection $connection); public function onPreTransactionCommit(Doctrine_Connection $connection); public function onTransactionRollback(Doctrine_Connection $connection); public function onPreTransactionRollback(Doctrine_Connection $connection); public function onTransactionBegin(Doctrine_Connection $connection); public function onPreTransactionBegin(Doctrine_Connection $connection); public function onCollectionDelete(Doctrine_Collection $collection); public function onPreCollectionDelete(Doctrine_Collection $collection); } class Doctrine_EventListener implements Doctrine_EventListener_Interface { public function onLoad(Doctrine_Record $record) { } public function onPreLoad(Doctrine_Record $record) { } public function onSleep(Doctrine_Record $record) { } public function onWakeUp(Doctrine_Record $record) { } public function onUpdate(Doctrine_Record $record) { } public function onPreUpdate(Doctrine_Record $record) { } public function onCreate(Doctrine_Record $record) { } public function onPreCreate(Doctrine_Record $record) { } public function onSave(Doctrine_Record $record) { } public function onPreSave(Doctrine_Record $record) { } public function onGetProperty(Doctrine_Record $record, $property, $value) { return $value; } public function onSetProperty(Doctrine_Record $record, $property, $value) { return $value; } public function onInsert(Doctrine_Record $record) { } public function onPreInsert(Doctrine_Record $record) { } public function onDelete(Doctrine_Record $record) { } public function onPreDelete(Doctrine_Record $record) { } public function onEvict(Doctrine_Record $record) { } public function onPreEvict(Doctrine_Record $record) { } public function onClose(Doctrine_Connection $connection) { } public function onPreClose(Doctrine_Connection $connection) { } public function onOpen(Doctrine_Connection $connection) { } public function onTransactionCommit(Doctrine_Connection $connection) { } public function onPreTransactionCommit(Doctrine_Connection $connection) { } public function onTransactionRollback(Doctrine_Connection $connection) { } public function onPreTransactionRollback(Doctrine_Connection $connection) { } public function onTransactionBegin(Doctrine_Connection $connection) { } public function onPreTransactionBegin(Doctrine_Connection $connection) { } public function onCollectionDelete(Doctrine_Collection $collection) { } public function onPreCollectionDelete(Doctrine_Collection $collection) { } } class Doctrine_EventListener_Empty extends Doctrine_EventListener { } class Doctrine_EventListener_Chain extends Doctrine_Access implements Doctrine_EventListener_Interface { private $listeners = array(); public function add(Doctrine_EventListener $listener) { $this->listeners[] = $listener; } public function get($key) { if( ! isset($this->listeners[$key])) return null; return $this->listeners[$key]; } public function set($key, Doctrine_EventListener $listener) { $this->listeners[$key] = $listener; } public function onLoad(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onLoad($record); } } public function onPreLoad(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreLoad($record); } } public function onSleep(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onSleep($record); } } public function onWakeUp(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onWakeUp($record); } } public function onUpdate(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onUpdate($record); } } public function onPreUpdate(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreUpdate($record); } } public function onCreate(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onCreate($record); } } public function onPreCreate(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreCreate($record); } } public function onSave(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onSave($record); } } public function onPreSave(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreSave($record); } } public function onGetProperty(Doctrine_Record $record, $property, $value) { foreach($this->listeners as $listener) { $value = $listener->onGetProperty($record, $property, $value); } return $value; } public function onSetProperty(Doctrine_Record $record, $property, $value) { foreach($this->listeners as $listener) { $value = $listener->onSetProperty($record, $property, $value); } return $value; } public function onInsert(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onInsert($record); } } public function onPreInsert(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreInsert($record); } } public function onDelete(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onDelete($record); } } public function onPreDelete(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreDelete($record); } } public function onEvict(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onEvict($record); } } public function onPreEvict(Doctrine_Record $record) { foreach($this->listeners as $listener) { $listener->onPreEvict($record); } } public function onClose(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onClose($connection); } } public function onPreClose(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onPreClose($connection); } } public function onOpen(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onOpen($connection); } } public function onTransactionCommit(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onTransactionCommit($connection); } } public function onPreTransactionCommit(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onPreTransactionCommit($connection); } } public function onTransactionRollback(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onTransactionRollback($connection); } } public function onPreTransactionRollback(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onPreTransactionRollback($connection); } } public function onTransactionBegin(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onTransactionBegin($connection); } } public function onPreTransactionBegin(Doctrine_Connection $connection) { foreach($this->listeners as $listener) { $listener->onPreTransactionBegin($connection); } } public function onCollectionDelete(Doctrine_Collection $collection) { foreach($this->listeners as $listener) { $listener->onCollectionDelete($record); } } public function onPreCollectionDelete(Doctrine_Collection $collection) { foreach($this->listeners as $listener) { $listener->onPreCollectionDelete($collection); } } } abstract class Doctrine_Hydrate extends Doctrine_Access { protected $fetchModes = array(); protected $tables = array(); protected $collections = array(); protected $joins = array(); protected $params = array(); protected $conn; protected $view; protected $inheritanceApplied = false; protected $aggregate = false; protected $compAliases = array(); protected $tableAliases = array(); protected $tableIndexes = array(); protected $components = array(); protected $pendingAggregates = array(); protected $aggregateMap = array(); protected $aliasHandler; protected $parts = array( 'select' => array(), 'from' => array(), 'set' => array(), 'join' => array(), 'where' => array(), 'groupby' => array(), 'having' => array(), 'orderby' => array(), 'limit' => false, 'offset' => false, ); public function __construct($connection = null) { if( ! ($connection instanceof Doctrine_Connection)) $connection = Doctrine_Manager::getInstance()->getCurrentConnection(); $this->conn = $connection; $this->aliasHandler = new Doctrine_Hydrate_Alias(); } public function getComponentAliases() { return $this->compAliases; } public function getTableAliases() { return $this->tableAliases; } public function getTableIndexes() { return $this->tableIndexes; } public function copyAliases(Doctrine_Hydrate $query) { $this->compAliases = $query->getComponentAliases(); $this->tableAliases = $query->getTableAliases(); $this->tableIndexes = $query->getTableIndexes(); return $this; } public function getPathAlias($path) { $s = array_search($path, $this->compAliases); if($s === false) return $path; return $s; } public function createSubquery() { $class = get_class($this); $obj = new $class(); $obj->copyAliases($this); return $obj; } abstract public function getQuery(); public function isLimitSubqueryUsed() { return false; } public function remove($name) { if(isset($this->parts[$name])) { if($name == "limit" || $name == "offset") $this->parts[$name] = false; else $this->parts[$name] = array(); } return $this; } protected function clear() { $this->fetchModes = array(); $this->tables = array(); $this->parts = array( "select" => array(), "from" => array(), "join" => array(), "where" => array(), "groupby" => array(), "having" => array(), "orderby" => array(), "limit" => false, "offset" => false, ); $this->inheritanceApplied = false; $this->aggregate = false; $this->collections = array(); $this->joins = array(); $this->tableIndexes = array(); $this->tableAliases = array(); $this->aliasHandler->clear(); } public function getConnection() { return $this->conn; } public function setView(Doctrine_View $view) { $this->view = $view; } public function getView() { return $this->view; } final public function getTableAlias($path) { if(isset($this->compAliases[$path])) $path = $this->compAliases[$path]; if( ! isset($this->tableAliases[$path])) return false; return $this->tableAliases[$path]; } private function getCollection($name) { $table = $this->tables[$name]; if( ! isset($this->fetchModes[$name])) return new Doctrine_Collection($table); switch($this->fetchModes[$name]): case Doctrine::FETCH_BATCH: $coll = new Doctrine_Collection_Batch($table); break; case Doctrine::FETCH_LAZY: $coll = new Doctrine_Collection_Lazy($table); break; case Doctrine::FETCH_OFFSET: $coll = new Doctrine_Collection_Offset($table); break; case Doctrine::FETCH_IMMEDIATE: $coll = new Doctrine_Collection_Immediate($table); break; case Doctrine::FETCH_LAZY_OFFSET: $coll = new Doctrine_Collection_LazyOffset($table); break; default: throw new Doctrine_Exception("Unknown fetchmode"); endswitch; return $coll; } public static function convertBoolean(&$item) { if(is_bool($item)) $item = (int) $item; } public function execute($params = array(), $return = Doctrine::FETCH_RECORD) { $this->collections = array(); $params = array_merge($this->params, $params); array_walk($params, array(__CLASS__, 'convertBoolean')); if( ! $this->view) $query = $this->getQuery($params); else $query = $this->view->getSelectSql(); if($this->isLimitSubqueryUsed() && $this->conn->getDBH()->getAttribute(PDO::ATTR_DRIVER_NAME) !== 'mysql') $params = array_merge($params, $params); $stmt = $this->conn->execute($query, $params); if($this->aggregate) return $stmt->fetchAll(PDO::FETCH_ASSOC); if(count($this->tables) == 0) throw new Doctrine_Query_Exception("No components selected"); $keys = array_keys($this->tables); $root = $keys[0]; $previd = array(); $coll = $this->getCollection($root); $prev[$root] = $coll; if($this->aggregate) $return = Doctrine::FETCH_ARRAY; $array = $this->parseData($stmt); if($return == Doctrine::FETCH_ARRAY) return $array; foreach($array as $data) { foreach($data as $key => $row) { if(empty($row)) continue; foreach($this->tables as $k => $t) { if ( ! strcasecmp($key, $k)) $key = $k; } if ( !isset($this->tables[$key]) ) throw new Doctrine_Exception("No table named $key found."); $ids = $this->tables[$key]->getIdentifier(); $name = $key; if($this->isIdentifiable($row, $ids)) { $prev = $this->initRelated($prev, $name); if(isset($row[0])) { $path = array_search($name, $this->tableAliases); $alias = $this->getPathAlias($path); foreach($row as $index => $value) { $agg = false; if(isset($this->pendingAggregates[$alias][$index])) $agg = $this->pendingAggregates[$alias][$index][3]; $prev[$name]->setAggregateValue($agg, $value); } } continue; } if( ! isset($previd[$name])) $previd[$name] = array(); if($previd[$name] !== $row) { $this->tables[$name]->setData($row); $record = $this->tables[$name]->getRecord(); if($name == $root) { $coll->add($record); unset($previd); } else { $prev = $this->addRelated($prev, $name, $record); } if($prev[$name] !== $record) $prev[$name] = $record; } $previd[$name] = $row; } } return $coll; } public function initRelated(array $prev, $name) { $pointer = $this->joins[$name]; $path = array_search($name, $this->tableAliases); $tmp = explode(".", $path); $alias = end($tmp); if( ! isset($prev[$pointer]) ) return $prev; $fk = $this->tables[$pointer]->getRelation($alias); if( ! $fk->isOneToOne()) { if($prev[$pointer]->getLast() instanceof Doctrine_Record) { if( ! $prev[$pointer]->getLast()->hasReference($alias)) { $prev[$name] = $this->getCollection($name); $prev[$pointer]->getLast()->initReference($prev[$name],$fk); } else $prev[$name] = $prev[$pointer]->getLast()->get($alias); } } return $prev; } public function addRelated(array $prev, $name, Doctrine_Record $record) { $pointer = $this->joins[$name]; $path = array_search($name, $this->tableAliases); $tmp = explode('.', $path); $alias = end($tmp); $fk = $this->tables[$pointer]->getRelation($alias); if($fk->isOneToOne()) { $prev[$pointer]->getLast()->set($fk->getAlias(), $record); $prev[$name] = $record; } else { if( ! $prev[$pointer]->getLast()->hasReference($alias)) { $prev[$name] = $this->getCollection($name); $prev[$pointer]->getLast()->initReference($prev[$name], $fk); } else { $prev[$name] = $prev[$pointer]->getLast()->get($alias); } $prev[$pointer]->getLast()->addReference($record, $fk); } return $prev; } public function isIdentifiable(array $row, $ids) { if(is_array($ids)) { foreach($ids as $id) { if($row[$id] == null) return true; } } else { if( ! isset($row[$ids])) return true; } return false; } public function applyInheritance() { $array = array(); foreach($this->tables as $alias => $table): $array[$alias][] = $table->getInheritanceMap(); endforeach; $str = ""; $c = array(); $index = 0; foreach($array as $tableAlias => $maps) { $a = array(); foreach($maps as $map) { $b = array(); foreach($map as $field => $value) { if($index > 0) $b[] = '(' . $tableAlias . '.' . $field . ' = ' . $value . ' OR ' . $tableAlias . '.' . $field . ' IS NULL)'; else $b[] = $tableAlias . '.' . $field . ' = ' . $value; } if( ! empty($b)) $a[] = implode(' AND ', $b); } if( ! empty($a)) $c[] = implode(' AND ', $a); $index++; } $str .= implode(' AND ', $c); return $str; } public function parseData(PDOStatement $stmt) { $array = array(); while($data = $stmt->fetch(PDO::FETCH_ASSOC)): foreach($data as $key => $value): $e = explode("__",$key); $field = strtolower( array_pop($e) ); $component = strtolower( implode("__",$e) ); $data[$component][$field] = $value; unset($data[$key]); endforeach; $array[] = $data; endwhile; $stmt->closeCursor(); return $array; } public function getTable($name) { return $this->tables[$name]; } public function __toString() { return Doctrine_Lib::formatSql($this->getQuery()); } } class Doctrine_Identifier { const AUTO_INCREMENT = 1; const SEQUENCE = 2; const NORMAL = 3; const COMPOSITE = 4; } class Doctrine_Locking_Exception extends Doctrine_Exception {} class Doctrine_Manager extends Doctrine_Configurable implements Countable, IteratorAggregate { private $connections = array(); private $bound = array(); private $index = 0; private $currIndex = 0; private $root; private $null; private function __construct() { $this->root = dirname(__FILE__); $this->null = new Doctrine_Null; Doctrine_Record::initNullObject($this->null); Doctrine_Collection::initNullObject($this->null); Doctrine_Record_Iterator::initNullObject($this->null); Doctrine_Validator::initNullObject($this->null); } final public function getNullObject() { return $this->null; } final public function setDefaultAttributes() { static $init = false; if( ! $init) { $init = true; $attributes = array( Doctrine::ATTR_FETCHMODE => Doctrine::FETCH_IMMEDIATE, Doctrine::ATTR_BATCH_SIZE => 5, Doctrine::ATTR_COLL_LIMIT => 5, Doctrine::ATTR_LISTENER => new Doctrine_EventListener(), Doctrine::ATTR_LOCKMODE => 1, Doctrine::ATTR_VLD => false, Doctrine::ATTR_AUTO_LENGTH_VLD => true, Doctrine::ATTR_AUTO_TYPE_VLD => true, Doctrine::ATTR_CREATE_TABLES => true, Doctrine::ATTR_QUERY_LIMIT => Doctrine::LIMIT_RECORDS, Doctrine::ATTR_IDXNAME_FORMAT => "%s_idx", Doctrine::ATTR_SEQNAME_FORMAT => "%s_seq", Doctrine::ATTR_QUOTE_IDENTIFIER => false, Doctrine::ATTR_SEQCOL_NAME => 'id', Doctrine::ATTR_PORTABILITY => Doctrine::PORTABILITY_ALL, ); foreach($attributes as $attribute => $value) { $old = $this->getAttribute($attribute); if($old === null) $this->setAttribute($attribute,$value); } return true; } return false; } final public function getRoot() { return $this->root; } public static function getInstance() { static $instance; if( ! isset($instance)) $instance = new self(); return $instance; } public static function connection($adapter = null, $name = null) { if($adapter == null) { return Doctrine_Manager::getInstance()->getCurrentConnection(); } else { return Doctrine_Manager::getInstance()->openConnection($adapter, $name); } } public function openConnection($adapter, $name = null) { if( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) throw new Doctrine_Manager_Exception("First argument should be an instance of PDO or implement Doctrine_Adapter_Interface"); $this->setDefaultAttributes(); if($name !== null) { $name = (string) $name; if(isset($this->connections[$name])) throw new Doctrine_Manager_Exception("Connection with $name already exists!"); } else { $name = $this->index; $this->index++; } switch($adapter->getAttribute(PDO::ATTR_DRIVER_NAME)): case "mysql": $this->connections[$name] = new Doctrine_Connection_Mysql($this, $adapter); break; case "sqlite": $this->connections[$name] = new Doctrine_Connection_Sqlite($this, $adapter); break; case "pgsql": $this->connections[$name] = new Doctrine_Connection_Pgsql($this, $adapter); break; case "oci": $this->connections[$name] = new Doctrine_Connection_Oracle($this, $adapter); break; case "mssql": $this->connections[$name] = new Doctrine_Connection_Mssql($this, $adapter); break; case "firebird": $this->connections[$name] = new Doctrine_Connection_Firebird($this, $adapter); break; case "informix": $this->connections[$name] = new Doctrine_Connection_Informix($this, $adapter); break; case "mock": $this->connections[$name] = new Doctrine_Connection_Mock($this, $adapter); break; default: throw new Doctrine_Manager_Exception('Unknown connection driver '. $adapter->getAttribute(PDO::ATTR_DRIVER_NAME)); endswitch; $this->currIndex = $name; return $this->connections[$name]; } public function openSession(PDO $pdo, $name = null) { return $this->openConnection($pdo, $name); } public function getConnection($name) { if( ! isset($this->connections[$name])) throw new Doctrine_Manager_Exception('Unknown connection: ' . $name); $this->currIndex = $name; return $this->connections[$name]; } public function bindComponent($componentName, $connectionName) { $this->bound[$componentName] = $connectionName; } public function getConnectionForComponent($componentName = null) { if(isset($this->bound[$componentName])) return $this->getConnection($this->bound[$componentName]); return $this->getCurrentConnection(); } public function getTable($componentName) { return $this->getConnectionForComponent($componentName)->getTable($componentName); } public function closeConnection(Doctrine_Connection $connection) { $connection->close(); unset($connection); } public function getConnections() { return $this->connections; } public function setCurrentConnection($key) { $key = (string) $key; if( ! isset($this->connections[$key])) throw new InvalidKeyException(); $this->currIndex = $key; } public function count() { return count($this->connections); } public function getIterator() { return new ArrayIterator($this->connections); } public function getCurrentConnection() { $i = $this->currIndex; if( ! isset($this->connections[$i])) throw new Doctrine_Connection_Exception(); return $this->connections[$i]; } public function __toString() { $r[] = "<pre>"; $r[] = "Doctrine_Manager"; $r[] = "Connections : ".count($this->connections); $r[] = "</pre>"; return implode("\n",$r); } } final class Doctrine_Null { } interface Doctrine_Overloadable { public function __call($m, $a); } class Doctrine_Query extends Doctrine_Hydrate implements Countable { const SELECT = 0; const DELETE = 1; const UPDATE = 2; private $subqueryAliases = array(); private $needsSubquery = false; private $limitSubqueryUsed = false; private $tableStack; private $relationStack = array(); private $isDistinct = false; private $pendingFields = array(); protected $type = self::SELECT; public static function create() { return new Doctrine_Query(); } public function getTableStack() { return $this->tableStack; } public function getRelationStack() { return $this->relationStack; } public function isDistinct($distinct = null) { if(isset($distinct)) $this->isDistinct = (bool) $distinct; return $this->isDistinct; } public function processPendingFields($componentAlias) { $tableAlias = $this->getTableAlias($componentAlias); $componentPath = $this->compAliases[$componentAlias]; if( ! isset($this->components[$componentPath])) throw new Doctrine_Query_Exception('Unknown component path '.$componentPath); $table = $this->components[$componentPath]; if(isset($this->pendingFields[$componentAlias])) { $fields = $this->pendingFields[$componentAlias]; if(in_array('*', $fields)) $fields = $table->getColumnNames(); else $fields = array_unique(array_merge($table->getPrimaryKeys(), $fields)); } foreach($fields as $name) { $this->parts["select"][] = $tableAlias . '.' .$name . ' AS ' . $tableAlias . '__' . $name; } } public function parseSelect($dql) { $refs = Doctrine_Query::bracketExplode($dql, ','); foreach($refs as $reference) { if(strpos($reference, '(') !== false) { $this->parseAggregateFunction2($reference); } else { $e = explode('.', $reference); if(count($e) > 2) $this->pendingFields[] = $reference; else $this->pendingFields[$e[0]][] = $e[1]; } } } public function parseAggregateFunction2($func) { $e = Doctrine_Query::bracketExplode($func, ' '); $func = $e[0]; $pos = strpos($func, '('); $name = substr($func, 0, $pos); switch($name) { case 'MAX': case 'MIN': case 'COUNT': case 'AVG': case 'SUM': $reference = substr($func, ($pos + 1), -1); $e2 = explode(' ', $reference); $distinct = ''; if(count($e2) > 1) { if(strtoupper($e2[0]) == 'DISTINCT') $distinct = 'DISTINCT '; $reference = $e2[1]; } $parts = explode('.', $reference); $alias = (isset($e[1])) ? $e[1] : $name; $this->pendingAggregates[$parts[0]][] = array($name, $parts[1], $distinct, $alias); break; default: throw new Doctrine_Query_Exception('Unknown aggregate function '.$name); } } public function processPendingAggregates($componentAlias) { $tableAlias = $this->getTableAlias($componentAlias); $componentPath = $this->compAliases[$componentAlias]; if( ! isset($this->components[$componentPath])) throw new Doctrine_Query_Exception('Unknown component path '.$componentPath); $table = $this->components[$componentPath]; foreach($this->pendingAggregates[$componentAlias] as $args) { list($name, $arg, $distinct, $alias) = $args; $this->parts["select"][] = $name . '(' . $distinct . $tableAlias . '.' . $arg . ') AS ' . $tableAlias . '__' . count($this->aggregateMap); $this->aggregateMap[] = $table; } } public function count($params = array()) { $this->remove('select'); $join = $this->join; $where = $this->where; $having = $this->having; $table = reset($this->tables); $q = 'SELECT COUNT(DISTINCT ' . $this->aliasHandler->getShortAlias($table->getTableName()) . '.' . $table->getIdentifier() . ') FROM ' . $table->getTableName() . ' ' . $this->aliasHandler->getShortAlias($table->getTableName()); foreach($join as $j) { $q .= ' '.implode(' ',$j); } $string = $this->applyInheritance(); if( ! empty($where)) { $q .= ' WHERE ' . implode(' AND ', $where); if( ! empty($string)) $q .= ' AND (' . $string . ')'; } else { if( ! empty($string)) $q .= ' WHERE (' . $string . ')'; } if( ! empty($having)) $q .= ' HAVING ' . implode(' AND ',$having); $params = array_merge($this->params, $params); $a = $this->getConnection()->execute($q, $params)->fetch(PDO::FETCH_NUM); return $a[0]; } protected function loadFields(Doctrine_Table $table, $fetchmode, array $names, $cpath) { $name = $table->getComponentName(); switch($fetchmode): case Doctrine::FETCH_OFFSET: $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); case Doctrine::FETCH_IMMEDIATE: if( ! empty($names)) $names = array_unique(array_merge($table->getPrimaryKeys(), $names)); else $names = $table->getColumnNames(); break; case Doctrine::FETCH_LAZY_OFFSET: $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); case Doctrine::FETCH_LAZY: case Doctrine::FETCH_BATCH: $names = array_unique(array_merge($table->getPrimaryKeys(), $names)); break; default: throw new Doctrine_Exception("Unknown fetchmode."); endswitch; $component = $table->getComponentName(); $tablename = $this->tableAliases[$cpath]; $this->fetchModes[$tablename] = $fetchmode; $count = count($this->tables); foreach($names as $name) { if($count == 0) { $this->parts['select'][] = $tablename . '.' . $name; } else { $this->parts['select'][] = $tablename . '.' . $name . ' AS ' . $tablename . '__' . $name; } } } public function addFrom($from) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse($from); } public function leftJoin($join) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse('LEFT JOIN '. $join); } public function innerJoin($join) { $class = 'Doctrine_Query_From'; $parser = new $class($this); $parser->parse('INNER JOIN '. $join); } public function addWhere($where, $params = array()) { $class = 'Doctrine_Query_Where'; $parser = new $class($this); $this->parts['where'][] = $parser->parse($where); if(is_array($params)) { $this->params = array_merge($this->params, $params); } else { $this->params[] = $params; } } public function __call($name, $args) { $name = strtolower($name); if($name == 'select') $method = 'parse' . ucwords($name); switch($name) { case 'select': $this->type = self::SELECT; if( ! isset($args[0])) throw new Doctrine_Query_Exception('Empty select part'); $this->parseSelect($args[0]); break; case 'delete': $this->type = self::DELETE; break; case 'update': $this->type = self::UPDATE; $name = 'from'; case 'from': $this->parts['from'] = array(); $this->parts['select'] = array(); $this->parts['join'] = array(); $this->joins = array(); $this->tables = array(); $this->fetchModes = array(); $this->tableIndexes = array(); $this->tableAliases = array(); $this->aliasHandler->clear(); $class = "Doctrine_Query_".ucwords($name); $parser = new $class($this); $parser->parse($args[0]); break; case 'where': if(isset($args[1])) { if(is_array($args[1])) { $this->params = $args[1]; } else { $this->params = array($args[1]); } } case 'having': case 'orderby': case 'groupby': $class = "Doctrine_Query_".ucwords($name); $parser = new $class($this); $this->parts[$name] = array($parser->parse($args[0])); break; case 'limit': case 'offset': if($args[0] == null) $args[0] = false; $this->parts[$name] = $args[0]; break; default: $this->parts[$name] = array(); $this->$method($args[0]); throw new Doctrine_Query_Exception("Unknown overload method"); } return $this; } public function get($name) { if( ! isset($this->parts[$name])) return false; return $this->parts[$name]; } public function set($name, $value) { $class = new Doctrine_Query_Set($this); $this->parts['set'][] = $class->parse($name . ' = ' . $value); return $this; } public function isLimitSubqueryUsed() { return $this->limitSubqueryUsed; } public function getQueryBase() { switch($this->type) { case self::DELETE: if($this->conn->getName() == 'mysql') $q = 'DELETE '.end($this->tableAliases).' FROM '; else $q = 'DELETE FROM '; break; case self::UPDATE: $q = 'UPDATE '; break; case self::SELECT: $distinct = ($this->isDistinct()) ? 'DISTINCT ' : ''; $q = 'SELECT '.$distinct.implode(', ', $this->parts['select']).' FROM '; break; } return $q; } public function getQuery($params = array()) { if(empty($this->parts["select"]) || empty($this->parts["from"])) return false; $needsSubQuery = false; $subquery = ''; $k = array_keys($this->tables); $table = $this->tables[$k[0]]; if( ! empty($this->parts['limit']) && $this->needsSubquery && $table->getAttribute(Doctrine::ATTR_QUERY_LIMIT) == Doctrine::LIMIT_RECORDS) { $needsSubQuery = true; $this->limitSubqueryUsed = true; } $str = ''; if($this->isDistinct()) $str = 'DISTINCT '; $q = $this->getQueryBase(); $q .= $this->parts['from']; if( ! empty($this->parts['join'])) { foreach($this->parts['join'] as $part) { $q .= ' '.implode(' ', $part); } } if( ! empty($this->parts['set'])) { $q .= ' SET ' . implode(', ', $this->parts['set']); } $string = $this->applyInheritance(); if( ! empty($string)) $this->parts['where'][] = '('.$string.')'; $modifyLimit = true; if( ! empty($this->parts["limit"]) || ! empty($this->parts["offset"])) { if($needsSubQuery) { $subquery = $this->getLimitSubquery(); switch(strtolower($this->conn->getName())) { case 'mysql': $list = $this->conn->execute($subquery, $params)->fetchAll(PDO::FETCH_COLUMN); $subquery = implode(', ', $list); break; case 'pgsql': $subquery = 'SELECT doctrine_subquery_alias.' . $table->getIdentifier(). ' FROM (' . $subquery . ') AS doctrine_subquery_alias'; break; } $field = $this->aliasHandler->getShortAlias($table->getTableName()) . '.' . $table->getIdentifier(); if($subquery !== '') array_unshift($this->parts['where'], $field. ' IN (' . $subquery . ')'); $modifyLimit = false; } } $q .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ', $this->parts['where']):''; $q .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ', $this->parts['groupby']):''; $q .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' ', $this->parts['having']):''; $q .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(' ', $this->parts['orderby']):''; if($modifyLimit) $q = $this->conn->modifyLimitQuery($q, $this->parts['limit'], $this->parts['offset']); if( ! empty($string)) array_pop($this->parts['where']); if($needsSubQuery) array_shift($this->parts['where']); return $q; } public function getLimitSubquery() { $k = array_keys($this->tables); $table = $this->tables[$k[0]]; $alias = $this->aliasHandler->getShortAlias($table->getTableName()); $primaryKey = $alias . '.' . $table->getIdentifier(); $subquery = 'SELECT DISTINCT ' . $primaryKey; if($this->conn->getDBH()->getAttribute(PDO::ATTR_DRIVER_NAME) == 'pgsql') { foreach($this->parts['orderby'] as $part) { $e = explode(' ', $part); if($e[0] !== $primaryKey) $subquery .= ', ' . $e[0]; } } $subquery .= ' FROM ' . $this->conn->quoteIdentifier($table->getTableName()) . ' ' . $alias; foreach($this->parts['join'] as $parts) { foreach($parts as $part) { if(substr($part,0,9) === 'LEFT JOIN') { $e = explode(' ', $part); if( ! in_array($e[3], $this->subqueryAliases) && ! in_array($e[2], $this->subqueryAliases)) continue; } $subquery .= ' '.$part; } } $subquery .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ',$this->parts['where']):''; $subquery .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ',$this->parts['groupby']):''; $subquery .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' ',$this->parts['having']):''; $subquery .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(' ', $this->parts['orderby']):''; $subquery = $this->conn->modifyLimitQuery($subquery, $this->parts['limit'], $this->parts['offset']); $parts = self::quoteExplode($subquery, ' ', "'", "'"); foreach($parts as $k => $part) { if(strpos($part, "'") !== false) continue; if($this->aliasHandler->hasAliasFor($part)) { $parts[$k] = $this->aliasHandler->generateNewAlias($part); } if(strpos($part, '.') !== false) { $e = explode('.', $part); $trimmed = ltrim($e[0], '( '); $pos = strpos($e[0], $trimmed); $e[0] = substr($e[0], 0, $pos) . $this->aliasHandler->generateNewAlias($trimmed); $parts[$k] = implode('.', $e); } } $subquery = implode(' ', $parts); return $subquery; } public function query($query,$params = array()) { $this->parseQuery($query); if($this->aggregate) { $keys = array_keys($this->tables); $query = $this->getQuery(); $stmt = $this->tables[$keys[0]]->getConnection()->select($query, $this->parts["limit"], $this->parts["offset"]); $data = $stmt->fetch(PDO::FETCH_ASSOC); if(count($data) == 1) { return current($data); } else { return $data; } } else { return $this->execute($params); } } public function splitQuery($query) { $e = self::sqlExplode($query, ' '); foreach($e as $k=>$part) { $part = trim($part); switch(strtolower($part)) { case 'delete': case 'update': case 'select': case 'set': case 'from': case 'where': case 'limit': case 'offset': case 'having': $p = $part; $parts[$part] = array(); break; case 'order': case 'group': $i = ($k + 1); if(isset($e[$i]) && strtolower($e[$i]) === "by") { $p = $part; $parts[$part] = array(); } else $parts[$p][] = $part; break; case "by": continue; default: if( ! isset($p)) throw new Doctrine_Query_Exception("Couldn't parse query."); $parts[$p][] = $part; } } return $parts; } public function parseQuery($query, $clear = true) { if($clear) $this->clear(); $query = trim($query); $query = str_replace("\n", ' ', $query); $query = str_replace("\r", ' ', $query); $parts = $this->splitQuery($query); foreach($parts as $k => $part) { $part = implode(" ",$part); switch(strtoupper($k)) { case 'DELETE': $this->type = self::DELETE; break; case 'SELECT': $this->type = self::SELECT; $this->parseSelect($part); break; case 'UPDATE': $this->type = self::UPDATE; $k = 'FROM'; case 'FROM': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $parser->parse($part); break; case 'SET': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $this->parts['set'][] = $parser->parse($part); break; case 'GROUP': case 'ORDER': $k .= 'by'; case 'WHERE': case 'HAVING': $class = 'Doctrine_Query_' . ucwords(strtolower($k)); $parser = new $class($this); $name = strtolower($k); $this->parts[$name][] = $parser->parse($part); break; case 'LIMIT': $this->parts['limit'] = trim($part); break; case 'OFFSET': $this->parts['offset'] = trim($part); break; } } return $this; } final public function parseOrderBy($str) { $parser = new Doctrine_Query_Part_Orderby($this); return $parser->parse($str); } final public function parseFetchMode($mode) { switch(strtolower($mode)): case "i": case "immediate": $fetchmode = Doctrine::FETCH_IMMEDIATE; break; case "b": case "batch": $fetchmode = Doctrine::FETCH_BATCH; break; case "l": case "lazy": $fetchmode = Doctrine::FETCH_LAZY; break; case "o": case "offset": $fetchmode = Doctrine::FETCH_OFFSET; break; case "lo": case "lazyoffset": $fetchmode = Doctrine::FETCH_LAZYOFFSET; default: throw new Doctrine_Query_Exception("Unknown fetchmode '$mode'. The availible fetchmodes are 'i', 'b' and 'l'."); endswitch; return $fetchmode; } public static function bracketTrim($str,$e1 = '(',$e2 = ')') { if(substr($str,0,1) == $e1 && substr($str,-1) == $e2) return substr($str,1,-1); else return $str; } public static function bracketExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if(is_array($d)) { $a = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $a = explode("$d",$str); $i = 0; $term = array(); foreach($a as $key=>$val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i], "$e1"); $s2 = substr_count($term[$i], "$e2"); if($s1 == $s2) $i++; } else { $term[$i] .= "$d".trim($val); $c1 = substr_count($term[$i], "$e1"); $c2 = substr_count($term[$i], "$e2"); if($c1 == $c2) $i++; } } return $term; } public static function quoteExplode($str, $d = ' ') { if(is_array($d)) { $a = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $a = explode("$d",$str); $i = 0; $term = array(); foreach($a as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); if( ! (substr_count($term[$i], "'") & 1)) $i++; } else { $term[$i] .= "$d".trim($val); if( ! (substr_count($term[$i], "'") & 1)) $i++; } } return $term; } public static function sqlExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if(is_array($d)) { $str = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else $str = explode("$d",$str); $i = 0; $term = array(); foreach($str as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i],"$e1"); $s2 = substr_count($term[$i],"$e2"); if(substr($term[$i],0,1) == "(") { if($s1 == $s2) $i++; } else { if( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1) && ! (substr_count($term[$i], "") & 1) ) $i++; } } else { $term[$i] .= "$d".trim($val); $c1 = substr_count($term[$i],"$e1"); $c2 = substr_count($term[$i],"$e2"); if(substr($term[$i],0,1) == "(") { if($c1 == $c2) $i++; } else { if( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1) && ! (substr_count($term[$i], "") & 1) ) $i++; } } } return $term; } public function generateAlias($tableName) { if(isset($this->tableIndexes[$tableName])) { return $tableName.++$this->tableIndexes[$tableName]; } else { $this->tableIndexes[$tableName] = 1; return $tableName; } } final public function load($path, $loadFields = true) { $tmp = explode(' ',$path); $componentAlias = (count($tmp) > 1) ? end($tmp) : false; $e = preg_split("/[.:]/", $tmp[0], -1); if(isset($this->compAliases[$e[0]])) { $end = substr($tmp[0], strlen($e[0])); $path = $this->compAliases[$e[0]] . $end; $e = preg_split("/[.:]/", $path, -1); } else $path = $tmp[0]; $index = 0; $currPath = ''; $this->tableStack = array(); foreach($e as $key => $fullname) { try { $e2 = preg_split("/[-(]/",$fullname); $name = $e2[0]; $currPath .= '.' . $name; if($key == 0) { $currPath = substr($currPath,1); $this->conn = Doctrine_Manager::getInstance() ->getConnectionForComponent($name); $table = $this->conn->getTable($name); $tname = $this->aliasHandler->getShortAlias($table->getTableName()); if( ! isset($this->tableAliases[$currPath])) $this->tableIndexes[$tname] = 1; $this->parts["from"] = $this->conn->quoteIdentifier($table->getTableName()) . ' ' . $tname; $this->tableAliases[$currPath] = $tname; $tableName = $tname; } else { $index += strlen($e[($key - 1)]) + 1; $mark = substr($path,($index - 1),1); if(isset($this->tableAliases[$prevPath])) { $tname = $this->tableAliases[$prevPath]; } else $tname = $this->aliasHandler->getShortAlias($table->getTableName()); $fk = $table->getRelation($name); $name = $fk->getTable()->getComponentName(); $original = $fk->getTable()->getTableName(); if(isset($this->tableAliases[$currPath])) { $tname2 = $this->tableAliases[$currPath]; } else $tname2 = $this->aliasHandler->generateShortAlias($original); $aliasString = $this->conn->quoteIdentifier($original) . ' ' . $tname2; switch($mark) { case ':': $join = 'INNER JOIN '; break; case '.': $join = 'LEFT JOIN '; break; default: throw new Doctrine_Exception("Unknown operator '$mark'"); } if( ! $fk->isOneToOne()) { $this->needsSubquery = true; } if( ! $loadFields || $fk->getTable()->usesInheritanceMap()) { $this->subqueryAliases[] = $tname2; } if($fk instanceof Doctrine_Relation_Association) { $asf = $fk->getAssociationFactory(); $assocTableName = $asf->getTableName(); if( ! $loadFields) { $this->subqueryAliases[] = $assocTableName; } $this->parts["join"][$tname][$assocTableName] = $join . $assocTableName . ' ON ' . $tname . '.' . $table->getIdentifier() . ' = ' . $assocTableName . '.' . $fk->getLocal(); $this->parts["join"][$tname][$tname2] = $join . $aliasString . ' ON ' . $tname2 . '.' . $table->getIdentifier() . ' = ' . $assocTableName . '.' . $fk->getForeign(); } else { $this->parts["join"][$tname][$tname2] = $join . $aliasString . ' ON ' . $tname . '.' . $fk->getLocal() . ' = ' . $tname2 . '.' . $fk->getForeign(); } $this->joins[$tname2] = $prevTable; $table = $fk->getTable(); $this->tableAliases[$currPath] = $tname2; $tableName = $tname2; $this->relationStack[] = $fk; } $this->components[$currPath] = $table; $this->tableStack[] = $table; if( ! isset($this->tables[$tableName])) { $this->tables[$tableName] = $table; if($loadFields) { $skip = false; if( ! empty($this->pendingFields)) $skip = true; if($componentAlias) { $this->compAliases[$componentAlias] = $currPath; if(isset($this->pendingFields[$componentAlias])) { $this->processPendingFields($componentAlias); $skip = true; } if(isset($this->pendingAggregates[$componentAlias])) { $this->processPendingAggregates($componentAlias); $skip = true; } } if( ! $skip) $this->parseFields($fullname, $tableName, $e2, $currPath); } } $prevPath = $currPath; $prevTable = $tableName; } catch(Exception $e) { throw new Doctrine_Query_Exception($e->__toString()); } } if($componentAlias !== false) { $this->compAliases[$componentAlias] = $currPath; } return $table; } final public function parseFields($fullName, $tableName, array $exploded, $currPath) { $table = $this->tables[$tableName]; $fields = array(); if(strpos($fullName, "-") === false) { $fetchmode = $table->getAttribute(Doctrine::ATTR_FETCHMODE); if(isset($exploded[1])) { if(count($exploded) > 2) { $fields = $this->parseAggregateValues($fullName, $tableName, $exploded, $currPath); } elseif(count($exploded) == 2) { $fields = explode(",",substr($exploded[1],0,-1)); } } } else { if(isset($exploded[1])) { $fetchmode = $this->parseFetchMode($exploded[1]); } else $fetchmode = $table->getAttribute(Doctrine::ATTR_FETCHMODE); if(isset($exploded[2])) { if(substr_count($exploded[2], ")") > 1) { } else { $fields = explode(",",substr($exploded[2],0,-1)); } } } if( ! $this->aggregate) $this->loadFields($table, $fetchmode, $fields, $currPath); } public function parseAggregateFunction($func,$reference) { $pos = strpos($func,"("); if($pos !== false) { $funcs = array(); $name = substr($func, 0, $pos); $func = substr($func, ($pos + 1), -1); $params = Doctrine_Query::bracketExplode($func, ",", "(", ")"); foreach($params as $k => $param) { $params[$k] = $this->parseAggregateFunction($param,$reference); } $funcs = $name."(".implode(", ", $params).")"; return $funcs; } else { if( ! is_numeric($func)) { $func = $this->getTableAlias($reference).".".$func; return $func; } else { return $func; } } } public function parseAggregateValues($fullName, $tableName, array $exploded, $currPath) { $this->aggregate = true; $pos = strpos($fullName,"("); $name = substr($fullName, 0, $pos); $string = substr($fullName, ($pos + 1), -1); $exploded = Doctrine_Query::bracketExplode($string, ','); foreach($exploded as $k => $value) { $func = $this->parseAggregateFunction($value, $currPath); $exploded[$k] = $func; $this->parts["select"][] = $exploded[$k]; } } } abstract class Doctrine_Query_Part extends Doctrine_Access { protected $query; protected $name; protected $parts = array(); public function __construct(Doctrine_Query $query) { $this->query = $query; } public function getName() { return $this->name; } public function getQuery() { return $this->query; } public function add($value) { $method = "parse".$this->name; $this->query->$method($value); } public function get($name) { } public function set($name, $value) { } } class Doctrine_Query_From extends Doctrine_Query_Part { final public function parse($str) { $str = trim($str); $parts = Doctrine_Query::bracketExplode($str, 'JOIN'); $operator = false; $last = ''; foreach($parts as $k => $part) { $part = trim($part); $e = explode(" ", $part); if(end($e) == 'INNER' || end($e) == 'LEFT') $last = array_pop($e); $part = implode(" ", $e); foreach(Doctrine_Query::bracketExplode($part, ',') as $reference) { $reference = trim($reference); $e = explode('.', $reference); if($operator) { $reference = array_shift($e).$operator.implode('.', $e); } $table = $this->query->load($reference); } $operator = ($last == 'INNER') ? ':' : '.'; } } public function __toString() { return ( ! empty($this->parts))?implode(", ", $this->parts):''; } } class Doctrine_Query_Orderby extends Doctrine_Query_Part { public function parse($str) { $ret = array(); foreach(explode(',', trim($str)) as $r) { $r = trim($r); $e = explode(' ', $r); $a = explode('.', $e[0]); if(count($a) > 1) { $field = array_pop($a); $reference = implode('.', $a); $name = end($a); $this->query->load($reference, false); $alias = $this->query->getTableAlias($reference); $tname = $this->query->getTable($alias)->getTableName(); $r = $alias . '.' . $field; if(isset($e[1])) $r .= ' '.$e[1]; } $ret[] = $r; } return implode(', ', $ret); } public function __toString() { return ( ! empty($this->parts))?implode(', ', $this->parts):''; } } class Doctrine_Query_Groupby extends Doctrine_Query_Part { final public function parse($str) { $r = array(); foreach(explode(",", $str) as $reference) { $reference = trim($reference); $e = explode(".",$reference); $field = array_pop($e); $ref = implode(".", $e); $table = $this->query->load($ref); $component = $table->getComponentName(); $r[] = $this->query->getTableAlias($ref).".".$field; } return implode(", ", $r); } public function __toString() { return ( ! empty($this->parts))?implode(", ", $this->parts):''; } } abstract class Doctrine_Query_Condition extends Doctrine_Query_Part { final public function parse($str) { $tmp = trim($str); $parts = Doctrine_Query::bracketExplode($str, array(' \&\& ', ' AND '), "(", ")"); if(count($parts) > 1) { $ret = array(); foreach($parts as $part) { $part = Doctrine_Query::bracketTrim($part, "(", ")"); $ret[] = $this->parse($part); } $r = implode(" AND ",$ret); } else { $parts = Doctrine_Query::bracketExplode($str, array(' \|\| ', ' OR '), "(", ")"); if(count($parts) > 1) { $ret = array(); foreach($parts as $part) { $part = Doctrine_Query::bracketTrim($part, "(", ")"); $ret[] = $this->parse($part); } $r = implode(" OR ",$ret); } else { if(substr($parts[0],0,1) == "(" && substr($parts[0],-1) == ")") return $this->parse(substr($parts[0],1,-1)); else return $this->load($parts[0]); } } return "(".$r.")"; } } class Doctrine_Query_Where extends Doctrine_Query_Condition { public function load($where) { $where = trim($where); $e = Doctrine_Query::sqlExplode($where); if(count($e) > 1) { $tmp = $e[0].' '.$e[1]; if(substr($tmp, 0, 6) == 'EXISTS') return $this->parseExists($where, true); elseif(substr($where, 0, 10) == 'NOT EXISTS') return $this->parseExists($where, false); } if(count($e) < 3) { $e = Doctrine_Query::sqlExplode($where, array('=', '<', '>', '!=')); } $r = array_shift($e); $a = explode('.', $r); if(count($a) > 1) { $field = array_pop($a); $count = count($e); $slice = array_slice($e, -1, 1); $value = implode('', $slice); $operator = trim(substr($where, strlen($r), -strlen($value))); $reference = implode('.', $a); $count = count($a); $pos = strpos($field, "("); if($pos !== false) { $func = substr($field, 0, $pos); $value = trim(substr($field, ($pos + 1), -1)); $values = Doctrine_Query::sqlExplode($value, ','); $field = array_pop($a); $reference = implode('.', $a); $table = $this->query->load($reference, false); array_pop($a); $reference2 = implode('.', $a); $alias = $this->query->getTableAlias($reference2); $stack = $this->query->getRelationStack(); $relation = end($stack); $stack = $this->query->getTableStack(); switch($func) { case 'contains': case 'regexp': case 'like': $operator = $this->getOperator($func); if(empty($relation)) throw new Doctrine_Query_Exception('DQL functions contains/regexp/like can only be used for fields of related components'); $where = array(); foreach($values as $value) { $where[] = $alias.'.'.$relation->getLocal(). ' IN (SELECT '.$relation->getForeign(). ' FROM '.$relation->getTable()->getTableName().' WHERE '.$field.$operator.$value.')'; } $where = implode(' AND ', $where); break; default: throw new Doctrine_Query_Exception('Unknown DQL function: '.$func); } } else { $table = $this->query->load($reference, false); $alias = $this->query->getTableAlias($reference); $table = $this->query->getTable($alias); $enumIndex = $table->enumIndex($field, trim($value, "'")); if(substr($value, 0, 1) == '(') { $trimmed = Doctrine_Query::bracketTrim($value); if(substr($trimmed, 0, 4) == 'FROM' || substr($trimmed, 0, 6) == 'SELECT') { $q = new Doctrine_Query(); $value = '(' . $q->parseQuery($trimmed)->getQuery() . ')'; } elseif(substr($trimmed, 0, 4) == 'SQL:') { $value = '(' . substr($trimmed, 4) . ')'; } else { $e = Doctrine_Query::sqlExplode($trimmed, ','); $value = array(); foreach($e as $part) { $index = $table->enumIndex($field, trim($part, "'")); if($index !== false) $value[] = $index; else $value[] = $this->parseLiteralValue($part); } $value = '(' . implode(', ', $value) . ')'; } } else { if($enumIndex !== false) $value = $enumIndex; else $value = $this->parseLiteralValue($value); } switch($operator) { case '<': case '>': case '=': case '!=': if($enumIndex !== false) $value = $enumIndex; default: $where = $alias.'.'.$field.' '.$operator.' '.$value; } } } return $where; } public function parseLiteralValue($value) { if(strpos($value, '\'') === false) { if($value == 'true') $value = 1; elseif($value == 'false') $value = 0; $a = explode('.', $value); if(count($a) > 1) { if( ! is_numeric($a[0])) { $value = $this->query->getTableAlias($a[0]). '.' . $a[1]; } } } else { } return $value; } public function parseExists($where, $negation) { $operator = ($negation) ? 'EXISTS' : 'NOT EXISTS'; $pos = strpos($where, '('); if($pos == false) throw new Doctrine_Query_Exception("Unknown expression, expected '('"); $sub = Doctrine_Query::bracketTrim(substr($where, $pos)); return $operator . ' ('.$this->query->createSubquery()->parseQuery($sub, false)->getQuery() . ')'; } public function getOperator($func) { switch($func) { case 'contains': $operator = ' = '; break; case 'regexp': $operator = $this->query->getConnection()->getRegexpOperator(); break; case 'like': $operator = ' LIKE '; break; } return $operator; } public function __toString() { return ( ! empty($this->parts))?implode(' AND ', $this->parts):''; } } class Doctrine_Query_Having extends Doctrine_Query_Condition { private function parseAggregateFunction($func) { $pos = strpos($func,"("); if($pos !== false) { $funcs = array(); $name = substr($func, 0, $pos); $func = substr($func, ($pos + 1), -1); $params = Doctrine_Query::bracketExplode($func, ",", "(", ")"); foreach($params as $k => $param) { $params[$k] = $this->parseAggregateFunction($param); } $funcs = $name."(".implode(", ", $params).")"; return $funcs; } else { if( ! is_numeric($func)) { $a = explode(".",$func); $field = array_pop($a); $reference = implode(".",$a); $table = $this->query->load($reference, false); $func = $this->query->getTableAlias($reference).".".$field; return $func; } else { return $func; } } } final public function load($having) { $e = Doctrine_Query::bracketExplode($having," ","(",")"); $r = array_shift($e); $t = explode("(",$r); $count = count($t); $r = $this->parseAggregateFunction($r); $operator = array_shift($e); $value = implode(" ",$e); $r .= " ".$operator." ".$value; return $r; } public function __toString() { return ( ! empty($this->parts))?implode(" AND ", $this->parts):''; } } class Doctrine_Query_Exception extends Doctrine_Exception { } class Doctrine_Query_Set extends Doctrine_Query_Part { public function parse($dql) { $parts = Doctrine_Query::sqlExplode($dql, ','); $result = array(); foreach($parts as $part) { $set = Doctrine_Query::sqlExplode($part, '='); $e = explode('.', trim($set[0])); $field = array_pop($e); $reference = implode('.', $e); $alias = $this->query->getTableAlias($reference); $result[] = $alias . '.' . $field . ' = ' . $set[1]; } return implode(', ', $result); } } class Doctrine_RawSql extends Doctrine_Hydrate { private $fields; public function __call($name, $args) { if( ! isset($this->parts[$name])) throw new Doctrine_RawSql_Exception("Unknown overload method $name. Availible overload methods are ".implode(" ",array_keys($this->parts))); if($name == 'select') { preg_match_all('/{([^}{]*)}/U', $args[0], $m); $this->fields = $m[1]; $this->parts["select"] = array(); } else $this->parts[$name][] = $args[0]; return $this; } public function get($name) { if( ! isset($this->parts[$name])) throw new Doctrine_RawSql_Exception('Unknown query part '.$name); return $this->parts[$name]; } public function parseQuery($query) { preg_match_all('/{([^}{]*)}/U', $query, $m); $this->fields = $m[1]; $this->clear(); $e = Doctrine_Query::sqlExplode($query,' '); foreach($e as $k => $part): $low = strtolower($part); switch(strtolower($part)): case "select": case "from": case "where": case "limit": case "offset": case "having": $p = $low; if( ! isset($parts[$low])) $parts[$low] = array(); break; case "order": case "group": $i = ($k + 1); if(isset($e[$i]) && strtolower($e[$i]) === "by") { $p = $low; $p .= "by"; $parts[$low."by"] = array(); } else $parts[$p][] = $part; break; case "by": continue; default: if( ! isset($parts[$p][0])) $parts[$p][0] = $part; else $parts[$p][0] .= ' '.$part; endswitch; endforeach; $this->parts = $parts; $this->parts["select"] = array(); return $this; } public function getQuery() { foreach($this->fields as $field) { $e = explode(".", $field); if( ! isset($e[1])) throw new Doctrine_RawSql_Exception("All selected fields in Sql query must be in format tableAlias.fieldName"); if( ! isset($this->tables[$e[0]])) { try { $this->addComponent($e[0], ucwords($e[0])); } catch(Doctrine_Exception $exception) { throw new Doctrine_RawSql_Exception("The associated component for table alias $e[0] couldn't be found."); } } if($e[1] == '*') { foreach($this->tables[$e[0]]->getColumnNames() as $name) { $field = $e[0].".".$name; $this->parts["select"][$field] = $field." AS ".$e[0]."__".$name; } } else { $field = $e[0].".".$e[1]; $this->parts["select"][$field] = $field." AS ".$e[0]."__".$e[1]; } } foreach($this->tableAliases as $alias) { foreach($this->tables[$alias]->getPrimaryKeys() as $key) { $field = $alias.".".$key; if( ! isset($this->parts["select"][$field])) $this->parts["select"][$field] = $field." AS ".$alias."__".$key; } } $q = 'SELECT '.implode(', ', $this->parts['select']); $string = $this->applyInheritance(); if( ! empty($string)) $this->parts['where'][] = $string; $copy = $this->parts; unset($copy['select']); $q .= ( ! empty($this->parts['from']))? ' FROM ' . implode(' ', $this->parts['from']) : ''; $q .= ( ! empty($this->parts['where']))? ' WHERE ' . implode(' AND ', $this->parts['where']) : ''; $q .= ( ! empty($this->parts['groupby']))? ' GROUP BY ' . implode(', ', $this->parts['groupby']) : ''; $q .= ( ! empty($this->parts['having']))? ' HAVING ' . implode(' ', $this->parts['having']) : ''; $q .= ( ! empty($this->parts['orderby']))? ' ORDER BY ' . implode(' ', $this->parts['orderby']) : ''; if( ! empty($string)) array_pop($this->parts['where']); return $q; } public function getFields() { return $this->fields; } public function addComponent($tableAlias, $componentName) { $e = explode('.', $componentName); $currPath = ''; $table = null; foreach($e as $k => $component) { $currPath .= '.' . $component; if($k == 0) $currPath = substr($currPath,1); if(isset($this->tableAliases[$currPath])) $alias = $this->tableAliases[$currPath]; else $alias = $tableAlias; if($table) { $tableName = $table->getAliasName($component); $table = $this->conn->getTable($tableName); } else { $table = $this->conn->getTable($component); } $this->tables[$alias] = $table; $this->fetchModes[$alias] = Doctrine::FETCH_IMMEDIATE; $this->tableAliases[$currPath] = $alias; if($k !== 0) $this->joins[$alias] = $prevAlias; $prevAlias = $alias; $prevPath = $currPath; } return $this; } } class Doctrine_RawSql_Exception extends Doctrine_Exception { } abstract class Doctrine_Record extends Doctrine_Access implements Countable, IteratorAggregate, Serializable { const STATE_DIRTY = 1; const STATE_TDIRTY = 2; const STATE_CLEAN = 3; const STATE_PROXY = 4; const STATE_TCLEAN = 5; const STATE_DELETED = 6; protected $_table; protected $_id = array(); protected $_data = array(); protected $_state; protected $_modified = array(); protected $_errorStack; private $references = array(); private $originals = array(); private static $index = 1; private static $null; private $oid; public function __construct($table = null, $isNewEntry = false) { if(isset($table) && $table instanceof Doctrine_Table) { $this->_table = $table; $exists = ( ! $isNewEntry); } else { $class = get_class($this); $this->_table = Doctrine_Manager::getInstance()->getConnectionForComponent($class)->getTable(get_class($this)); $exists = false; } if($this->_table->getConnection()->hasTable($this->_table->getComponentName())) { $this->oid = self::$index; self::$index++; $keys = $this->_table->getPrimaryKeys(); if( ! $exists) { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onPreCreate($this); } else { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onPreLoad($this); } $this->_data = $this->_table->getData(); $count = count($this->_data); $this->cleanData(); $this->prepareIdentifiers($exists); if( ! $exists) { if($count > 0) $this->_state = Doctrine_Record::STATE_TDIRTY; else $this->_state = Doctrine_Record::STATE_TCLEAN; $this->setDefaultValues(); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onCreate($this); } else { $this->_state = Doctrine_Record::STATE_CLEAN; if($count < $this->_table->getColumnCount()) { $this->_state = Doctrine_Record::STATE_PROXY; } $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); } $this->_errorStack = new Doctrine_Validator_ErrorStack(); $repository = $this->_table->getRepository(); $repository->add($this); } $this->construct(); } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public static function getNullObject() { return self::$null; } public function setUp() { } public function construct() { } public function getOID() { return $this->oid; } public function isValid() { if( ! $this->_table->getAttribute(Doctrine::ATTR_VLD)) return true; $this->_errorStack->clear(); $validator = new Doctrine_Validator(); $validator->validateRecord($this); $this->validate(); if ($this->_state == self::STATE_TDIRTY || $this->_state == self::STATE_TCLEAN) { $this->validateOnInsert(); } else { $this->validateOnUpdate(); } return $this->_errorStack->count() == 0 ? true : false; } protected function validate() {} protected function validateOnUpdate() {} protected function validateOnInsert() {} public function getErrorStack() { return $this->_errorStack; } public function setDefaultValues($overwrite = false) { if( ! $this->_table->hasDefaultValues()) return false; foreach($this->_data as $column => $value) { $default = $this->_table->getDefaultValueOf($column); if($default === null) $default = self::$null; if($value === self::$null || $overwrite) { $this->_data[$column] = $default; $this->_modified[] = $column; $this->_state = Doctrine_Record::STATE_TDIRTY; } } } private function cleanData($debug = false) { $tmp = $this->_data; $this->_data = array(); $count = 0; foreach($this->_table->getColumnNames() as $name) { $type = $this->_table->getTypeOf($name); if( ! isset($tmp[$name])) { $this->_data[$name] = self::$null; } else { switch($type): case "array": case "object": if($tmp[$name] !== self::$null) { if(is_string($tmp[$name])) { $value = unserialize($tmp[$name]); if($value === false) throw new Doctrine_Record_Exception("Unserialization of $name failed. ".var_dump(substr($tmp[$lower],0,30)."...",true)); } else $value = $tmp[$name]; $this->_data[$name] = $value; } break; case "gzip": if($tmp[$name] !== self::$null) { $value = gzuncompress($tmp[$name]); if($value === false) throw new Doctrine_Record_Exception("Uncompressing of $name failed."); $this->_data[$name] = $value; } break; case "enum": $this->_data[$name] = $this->_table->enumValue($name, $tmp[$name]); break; default: $this->_data[$name] = $tmp[$name]; endswitch; $count++; } } return $count; } private function prepareIdentifiers($exists = true) { switch($this->_table->getIdentifierType()): case Doctrine_Identifier::AUTO_INCREMENT: case Doctrine_Identifier::SEQUENCE: $name = $this->_table->getIdentifier(); if($exists) { if(isset($this->_data[$name]) && $this->_data[$name] !== self::$null) $this->_id[$name] = $this->_data[$name]; } unset($this->_data[$name]); break; case Doctrine_Identifier::NORMAL: $this->_id = array(); $name = $this->_table->getIdentifier(); if(isset($this->_data[$name]) && $this->_data[$name] !== self::$null) $this->_id[$name] = $this->_data[$name]; break; case Doctrine_Identifier::COMPOSITE: $names = $this->_table->getIdentifier(); foreach($names as $name) { if($this->_data[$name] === self::$null) $this->_id[$name] = null; else $this->_id[$name] = $this->_data[$name]; } break; endswitch; } public function serialize() { $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onSleep($this); $vars = get_object_vars($this); unset($vars['references']); unset($vars['originals']); unset($vars['_table']); $name = $this->_table->getIdentifier(); $this->_data = array_merge($this->_data, $this->_id); foreach($this->_data as $k => $v) { if($v instanceof Doctrine_Record) unset($vars['_data'][$k]); elseif($v === self::$null) { unset($vars['_data'][$k]); } else { switch($this->_table->getTypeOf($k)): case "array": case "object": $vars['_data'][$k] = serialize($vars['_data'][$k]); break; endswitch; } } return serialize($vars); } public function unserialize($serialized) { $manager = Doctrine_Manager::getInstance(); $connection = $manager->getCurrentConnection(); $this->oid = self::$index; self::$index++; $this->_table = $connection->getTable(get_class($this)); $array = unserialize($serialized); foreach($array as $name => $values) { $this->$name = $values; } $this->_table->getRepository()->add($this); $this->cleanData(); $this->prepareIdentifiers($this->exists()); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onWakeUp($this); } public function getState() { return $this->_state; } public function state($state = null) { if($state == null) { return $this->_state; } $err = false; if(is_integer($state)) { if($state >= 1 && $state <= 6) $this->_state = $state; else $err = true; } elseif(is_string($state)) { $upper = strtoupper($state); switch($upper) { case 'DIRTY': case 'CLEAN': case 'TDIRTY': case 'TCLEAN': case 'PROXY': case 'DELETED': $this->_state = constant('Doctrine_Record::STATE_' . $upper); break; default: $err = true; } } if($err) throw new Doctrine_Record_State_Exception('Unknown record state ' . $state); } final public function refresh() { $id = $this->obtainIdentifier(); if( ! is_array($id)) $id = array($id); if(empty($id)) return false; $id = array_values($id); $query = $this->_table->getQuery()." WHERE ".implode(" = ? AND ",$this->_table->getPrimaryKeys())." = ?"; $stmt = $this->_table->getConnection()->execute($query,$id); $this->_data = $stmt->fetch(PDO::FETCH_ASSOC); if( ! $this->_data) throw new Doctrine_Record_Exception('Failed to refresh. Record does not exist anymore'); $this->_data = array_change_key_case($this->_data, CASE_LOWER); $this->_modified = array(); $this->cleanData(true); $this->prepareIdentifiers(); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); return true; } final public function factoryRefresh() { $this->_data = $this->_table->getData(); $old = $this->_id; $this->cleanData(); $this->prepareIdentifiers(); if($this->_id != $old) throw new Doctrine_Record_Exception("The refreshed primary key doesn't match the one in the record memory.", Doctrine::ERR_REFRESH); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onLoad($this); } final public function getTable() { return $this->_table; } final public function getData() { return $this->_data; } public function rawGet($name) { if( ! isset($this->_data[$name])) throw new Doctrine_Record_Exception('Unknown property '. $name); if($this->_data[$name] === self::$null) return null; return $this->_data[$name]; } public function load() { if($this->_state == Doctrine_Record::STATE_PROXY) { $this->refresh(); $this->_state = Doctrine_Record::STATE_CLEAN; return true; } return false; } public function get($name, $invoke = true) { $listener = $this->_table->getAttribute(Doctrine::ATTR_LISTENER); $value = self::$null; $lower = strtolower($name); if(isset($this->_data[$lower])) { if($this->_data[$lower] === self::$null) $this->load(); if($this->_data[$lower] === self::$null) $value = null; else $value = $this->_data[$lower]; } if($value !== self::$null) { $value = $this->_table->invokeGet($this, $name, $value); if($invoke && $name !== $this->_table->getIdentifier()) return $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onGetProperty($this, $name, $value); else return $value; return $value; } if(isset($this->_id[$lower])) return $this->_id[$lower]; if($name === $this->_table->getIdentifier()) return null; $rel = $this->_table->getRelation($name); try { if( ! isset($this->references[$name])) $this->loadReference($name); } catch(Doctrine_Table_Exception $e) { throw new Doctrine_Record_Exception("Unknown property / related component '$name'."); } return $this->references[$name]; } public function set($name, $value, $load = true) { $lower = strtolower($name); if(isset($this->_data[$lower])) { if($value instanceof Doctrine_Record) { $id = $value->getIncremented(); if($id !== null) $value = $id; } if($load) $old = $this->get($lower, false); else $old = $this->_data[$lower]; if($old !== $value) { $value = $this->_table->invokeSet($this, $name, $value); $value = $this->_table->getAttribute(Doctrine::ATTR_LISTENER)->onSetProperty($this, $name, $value); if($value === null) $value = self::$null; $this->_data[$lower] = $value; $this->_modified[] = $lower; switch($this->_state): case Doctrine_Record::STATE_CLEAN: $this->_state = Doctrine_Record::STATE_DIRTY; break; case Doctrine_Record::STATE_TCLEAN: $this->_state = Doctrine_Record::STATE_TDIRTY; break; endswitch; } } else { try { $this->coreSetRelated($name, $value); } catch(Doctrine_Table_Exception $e) { throw new Doctrine_Record_Exception("Unknown property / related component '$name'."); } } } public function coreSetRelated($name, $value) { $rel = $this->_table->getRelation($name); if($rel instanceof Doctrine_Relation_ForeignKey || $rel instanceof Doctrine_Relation_LocalKey) { if( ! $rel->isOneToOne()) { if( ! ($value instanceof Doctrine_Collection)) throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting one-to-many references."); $value->setReference($this,$rel); } else { if( ! ($value instanceof Doctrine_Record)) throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Record when setting one-to-one references."); if($rel instanceof Doctrine_Relation_LocalKey) { $this->set($rel->getLocal(), $value, false); } else { $value->set($rel->getForeign(), $this, false); } } } elseif($rel instanceof Doctrine_Relation_Association) { if( ! ($value instanceof Doctrine_Collection)) throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting many-to-many references."); } $this->references[$name] = $value; } public function contains($name) { $lower = strtolower($name); if(isset($this->_data[$lower])) return true; if(isset($this->_id[$lower])) return true; if(isset($this->references[$name])) return true; return false; } public function __unset($name) { if(isset($this->_data[$name])) $this->_data[$name] = array(); } public function save(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } $conn->beginTransaction(); $saveLater = $conn->unitOfWork->saveRelated($this); if ($this->isValid()) { $conn->save($this); } else { $conn->transaction->addInvalid($this); } foreach($saveLater as $fk) { $table = $fk->getTable(); $alias = $this->_table->getAlias($table->getComponentName()); if(isset($this->references[$alias])) { $obj = $this->references[$alias]; $obj->save(); } } $conn->unitOfWork->saveAssociations($this); $conn->commit(); } public function replace(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } return $conn->replace($this->_table->getTableName(), $this->getPrepared(), $this->id); } public function getModified() { $a = array(); foreach($this->_modified as $k => $v) { $a[$v] = $this->_data[$v]; } return $a; } public function getPrepared(array $array = array()) { $a = array(); if(empty($array)) $array = $this->_modified; foreach($array as $k => $v) { $type = $this->_table->getTypeOf($v); if($this->_data[$v] === self::$null) { $a[$v] = null; continue; } switch($type) { case 'array': case 'object': $a[$v] = serialize($this->_data[$v]); break; case 'gzip': $a[$v] = gzcompress($this->_data[$v],5); break; case 'boolean': $a[$v] = (int) $this->_data[$v]; break; case 'enum': $a[$v] = $this->_table->enumIndex($v,$this->_data[$v]); break; default: if($this->_data[$v] instanceof Doctrine_Record) $this->_data[$v] = $this->_data[$v]->getIncremented(); $a[$v] = $this->_data[$v]; } } foreach($this->_table->getInheritanceMap() as $k => $v) { $old = $this->get($k, false); if((string) $old !== (string) $v || $old === null) { $a[$k] = $v; $this->_data[$k] = $v; } } return $a; } public function count() { return count($this->_data); } public function columnCount() { return $this->count(); } public function toArray() { $a = array(); foreach($this as $column => $value) { $a[$column] = $value; } if($this->_table->getIdentifierType() == Doctrine_Identifier::AUTO_INCREMENT) { $i = $this->_table->getIdentifier(); $a[$i] = $this->getIncremented(); } return $a; } public function exists() { return ($this->_state !== Doctrine_Record::STATE_TCLEAN && $this->_state !== Doctrine_Record::STATE_TDIRTY); } public function hasRelation($name) { if(isset($this->_data[$name]) || isset($this->_id[$name])) return true; return $this->_table->hasRelation($name); } public function getIterator() { return new Doctrine_Record_Iterator($this); } public function obtainOriginals($name) { if(isset($this->originals[$name])) return $this->originals[$name]; return false; } public function delete(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->_table->getConnection(); } return $conn->delete($this); } public function copy() { $ret = $this->_table->create($this->_data); $modified = array(); foreach($this->_data as $key => $val) if (!($val instanceof Doctrine_Null)) $ret->_modified[] = $key; return $ret; } final public function assignIdentifier($id = false) { if($id === false) { $this->_id = array(); $this->cleanData(); $this->_state = Doctrine_Record::STATE_TCLEAN; $this->_modified = array(); } elseif($id === true) { $this->prepareIdentifiers(false); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } else { $name = $this->_table->getIdentifier(); $this->_id[$name] = $id; $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } } public function assignOriginals($alias, Doctrine_Collection $coll) { $this->originals[$alias] = $coll; } final public function obtainIdentifier() { return $this->_id; } final public function getIncremented() { $id = current($this->_id); if($id === false) return null; return $id; } public function getLast() { return $this; } public function hasReference($name) { return isset($this->references[$name]); } public function obtainReference($name) { if(isset($this->references[$name])) return $this->references[$name]; throw new Doctrine_Record_Exception("Unknown reference $name"); } public function initReference(Doctrine_Collection $coll, Doctrine_Relation $connector) { $alias = $connector->getAlias(); if(isset($this->references[$alias])) return false; if( ! $connector->isOneToOne()) { if( ! ($connector instanceof Doctrine_Relation_Association)) $coll->setReference($this, $connector); $this->references[$alias] = $coll; $this->originals[$alias] = clone $coll; return true; } return false; } public function lazyInitRelated(Doctrine_Collection $coll, Doctrine_Relation $connector) { } public function addReference(Doctrine_Record $record, Doctrine_Relation $connector, $key = null) { $alias = $connector->getAlias(); $this->references[$alias]->add($record, $key); $this->originals[$alias]->add($record, $key); } public function getReferences() { return $this->references; } final public function setRelated($alias, Doctrine_Access $coll) { $this->references[$alias] = $coll; $this->originals[$alias] = $coll; } final public function loadReference($name) { $fk = $this->_table->getRelation($name); if($fk->isOneToOne()) { $this->references[$name] = $fk->fetchRelatedFor($this); } else { $coll = $fk->fetchRelatedFor($this); $this->references[$name] = $coll; $this->originals[$name] = clone $coll; } } final public function ownsOne($componentName, $foreignKey, $localKey = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::ONE_COMPOSITE, $localKey); } final public function ownsMany($componentName,$foreignKey, $localKey = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::MANY_COMPOSITE, $localKey); } final public function hasOne($componentName,$foreignKey, $localKey = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::ONE_AGGREGATE, $localKey); } final public function hasMany($componentName,$foreignKey, $localKey = null) { $this->_table->bind($componentName, $foreignKey, Doctrine_Relation::MANY_AGGREGATE, $localKey); } final public function setPrimaryKey($key) { $this->_table->setPrimaryKey($key); } final public function hasColumn($name, $type, $length = 2147483647, $options = "") { $this->_table->setColumn($name, $type, $length, $options); } public function countRelated($name) { $rel = $this->_table->getRelation($name); $componentName = $rel->getTable()->getComponentName(); $alias = $rel->getTable()->getAlias(get_class($this)); $query = new Doctrine_Query(); $query->from($componentName. '(' . 'COUNT(1)' . ')')->where($componentName. '.' .$alias. '.' . $this->getTable()->getIdentifier(). ' = ?'); $array = $query->execute(array($this->getIncremented())); return $array[0]['COUNT(1)']; } public function merge(array $values) { foreach($this->_table->getColumnNames() as $value) { try { if(isset($values[$value])) $this->set($value, $values[$value]); } catch(Exception $e) { } } } public function setAttribute($attr, $value) { $this->_table->setAttribute($attr, $value); } public function setTableName($tableName) { $this->_table->setTableName($tableName); } public function setInheritanceMap($map) { $this->_table->setOption('inheritanceMap', $map); } public function setEnumValues($column, $values) { $this->_table->setEnumValues($column, $values); } public function option($name, $value = null) { if($value == null) $this->_table->getOption($name); else $this->_table->setOption($name, $value); } public function hasIndex($name ) { } public function actsAsTree($treeImplName, $args) { } public function addListener($listener, $name = null) { $this->_table->addListener($listener, $name = null); return $this; } public function getListener() { return $this->_table->getListener(); } public function setListener($listener) { $this->_table->setListener($listener); return $this; } public function call($callback, $column) { $args = func_get_args(); array_shift($args); if(isset($args[0])) { $column = $args[0]; $args[0] = $this->get($column); $newvalue = call_user_func_array($callback, $args); $this->_data[$column] = $newvalue; } return $this; } public function __toString() { return Doctrine_Lib::getRecordAsString($this); } } class Doctrine_Record_Exception extends Doctrine_Exception { } class Doctrine_Record_Iterator extends ArrayIterator { private $record; private static $null; public function __construct(Doctrine_Record $record) { $this->record = $record; parent::__construct($record->getData()); } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function current() { $value = parent::current(); if($value === self::$null) return null; else return $value; } } abstract class Doctrine_Relation { const ONE_AGGREGATE = 0; const ONE_COMPOSITE = 1; const MANY_AGGREGATE = 2; const MANY_COMPOSITE = 3; protected $table; protected $local; protected $foreign; protected $type; protected $alias; public function __construct(Doctrine_Table $table, $local, $foreign, $type, $alias) { $this->table = $table; $this->local = $local; $this->foreign = $foreign; $this->type = $type; $this->alias = $alias; } final public function getAlias() { return $this->alias; } final public function getType() { return $this->type; } final public function getTable() { return $this->table; } final public function getLocal() { return $this->local; } final public function getForeign() { return $this->foreign; } final public function isComposite() { return ($this->type == Doctrine_Relation::ONE_COMPOSITE || $this->type == Doctrine_Relation::MANY_COMPOSITE); } final public function isOneToOne() { return ($this->type == Doctrine_Relation::ONE_AGGREGATE || $this->type == Doctrine_Relation::ONE_COMPOSITE); } public function getRelationDql($count) { $dql = "FROM ".$this->table->getComponentName(). " WHERE ".$this->table->getComponentName(). '.' . $this->foreign. " IN (".substr(str_repeat("?, ", $count),0,-2).")"; return $dql; } public static function getDeleteOperations(Doctrine_Collection $old, Doctrine_Collection $new) { $r = array(); foreach($old as $k => $record) { $id = $record->getIncremented(); if(empty($id)) continue; $found = false; foreach($new as $k2 => $record2) { if($record2->getIncremented() === $record->getIncremented()) { $found = true; break; } } if( ! $found) { $r[] = $record; unset($old[$k]); } } return $r; } public static function getInsertOperations(Doctrine_Collection $old, Doctrine_Collection $new) { $r = array(); foreach($new as $k => $record) { $found = false; $id = $record->getIncremented(); if( ! empty($id)) { foreach($old as $k2 => $record2) { if($record2->getIncremented() === $record->getIncremented()) { $found = true; break; } } } if( ! $found) { $old[] = $record; $r[] = $record; } } return $r; } abstract public function fetchRelatedFor(Doctrine_Record $record); public function __toString() { $r[] = "<pre>"; $r[] = "Class       : ".get_class($this); $r[] = "Component   : ".$this->table->getComponentName(); $r[] = "Table       : ".$this->table->getTableName(); $r[] = "Local key   : ".$this->local; $r[] = "Foreign key : ".$this->foreign; $r[] = "Type        : ".$this->type; $r[] = "</pre>"; return implode("\n", $r); } } class Doctrine_Relation_ForeignKey extends Doctrine_Relation { public function processDiff(Doctrine_Record $record) { $alias = $this->getAlias(); if($this->isOneToOne()) { if($record->obtainOriginals($alias) && $record->obtainOriginals($alias)->obtainIdentifier() != $this->obtainReference($alias)->obtainIdentifier()) $record->obtainOriginals($alias)->delete(); } else { if($record->hasReference($alias)) { $new = $record->obtainReference($alias); if( ! $record->obtainOriginals($alias)) $record->loadReference($alias); $operations = Doctrine_Relation::getDeleteOperations($record->obtainOriginals($alias), $new); foreach($operations as $r) { $r->delete(); } $record->assignOriginals($alias, clone $record->get($alias)); } } } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->get($this->local); if($this->isOneToOne()) { if(empty($id)) { $related = $this->table->create(); } else { $dql = "FROM ".$this->table->getComponentName()." WHERE ".$this->table->getComponentName().".".$this->foreign." = ?"; $coll = $this->table->getConnection()->query($dql, array($id)); $related = $coll[0]; } $related->set($this->foreign, $record, false); } else { if(empty($id)) { $related = new Doctrine_Collection($this->table); } else { $query = $this->getRelationDql(1); $related = $this->table->getConnection()->query($query, array($id)); } $related->setReference($record, $this); } return $related; } } class Doctrine_Relation_LocalKey extends Doctrine_Relation { public function processDiff(Doctrine_Record $record) { $alias = $this->getAlias(); if($record->obtainOriginals($alias) && $record->obtainOriginals($alias)->obtainIdentifier() != $this->references[$alias]->obtainIdentifier()) $record->obtainOriginals($alias)->delete(); } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->get($this->local); if(empty($id)) $related = $this->table->create(); else { if( ! ($related = $this->table->find($id))) $related = $this->table->create(); } $record->set($this->local, $related, false); return $related; } } class Doctrine_Relation_Association extends Doctrine_Relation { protected $associationTable; public function __construct(Doctrine_Table $table, Doctrine_Table $associationTable, $local, $foreign, $type, $alias) { parent::__construct($table, $local, $foreign, $type, $alias); $this->associationTable = $associationTable; } public function getAssociationFactory() { return $this->associationTable; } public function processDiff(Doctrine_Record $record) { $asf = $this->getAssociationFactory(); $alias = $this->getAlias(); if($record->hasReference($alias)) { $new = $record->obtainReference($alias); if( ! $record->obtainOriginals($alias)) $record->loadReference($alias); $operations = Doctrine_Relation::getDeleteOperations($record->obtainOriginals($alias), $new); foreach($operations as $r) { $query = 'DELETE FROM ' . $asf->getTableName() . ' WHERE ' . $this->getForeign() . ' = ?' . ' AND ' . $this->getLocal() . ' = ?'; $this->getTable()->getConnection()->execute($query, array($r->getIncremented(),$record->getIncremented())); } $operations = Doctrine_Relation::getInsertOperations($record->obtainOriginals($alias),$new); foreach($operations as $r) { $reldao = $asf->create(); $reldao->set($this->getForeign(), $r); $reldao->set($this->getLocal(), $record); $reldao->save(); } $record->assignOriginals($alias, clone $record->get($alias)); } } public function getRelationDql($count, $context = 'record') { switch($context): case "record": $sub = 'SQL:SELECT ' . $this->foreign. ' FROM ' . $this->associationTable->getTableName(). ' WHERE ' . $this->local. ' IN (' . substr(str_repeat("?, ", $count),0,-2) . ')'; $dql = "FROM ".$this->table->getComponentName(); $dql .= ".".$this->associationTable->getComponentName(); $dql .= " WHERE ".$this->table->getComponentName().".".$this->table->getIdentifier()." IN ($sub)"; break; case "collection": $sub = substr(str_repeat("?, ", $count),0,-2); $dql = "FROM ".$this->associationTable->getComponentName().".".$this->table->getComponentName(); $dql .= " WHERE ".$this->associationTable->getComponentName().".".$this->local." IN ($sub)"; endswitch; return $dql; } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); if(empty($id)) $coll = new Doctrine_Collection($this->table); else $coll = Doctrine_Query::create()->parseQuery($this->getRelationDql(1))->execute(array($id)); return $coll; } } class Doctrine_Relation_Association_Self extends Doctrine_Relation_Association { public function getRelationDql($count, $context = 'record') { switch($context): case 'record': $sub = 'SELECT '.$this->foreign. ' FROM '.$this->associationTable->getTableName(). ' WHERE '.$this->local. ' = ?'; $sub2 = 'SELECT '.$this->local. ' FROM '.$this->associationTable->getTableName(). ' WHERE '.$this->foreign. ' = ?'; $dql = 'FROM '.$this->table->getComponentName(); $dql .= '.'.$this->associationTable->getComponentName(); $dql .= ' WHERE '.$this->table->getComponentName().'.'.$this->table->getIdentifier().' IN ('.$sub.')'; $dql .= ' || '.$this->table->getComponentName().'.'.$this->table->getIdentifier().' IN ('.$sub2.')'; break; case 'collection': $sub = substr(str_repeat('?, ', $count),0,-2); $dql = 'FROM '.$this->associationTable->getComponentName().'.'.$this->table->getComponentName(); $dql .= ' WHERE '.$this->associationTable->getComponentName().'.'.$this->local.' IN ('.$sub.')'; endswitch; return $dql; } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); $q = new Doctrine_RawSql(); $assocTable = $this->getAssociationFactory()->getTableName(); $tableName = $record->getTable()->getTableName(); $identifier = $record->getTable()->getIdentifier(); $sub = 'SELECT '.$this->getForeign(). ' FROM '.$assocTable. ' WHERE '.$this->getLocal(). ' = ?'; $sub2 = 'SELECT '.$this->getLocal(). ' FROM '.$assocTable. ' WHERE '.$this->getForeign(). ' = ?'; $q->select('{'.$tableName.'.*}, {'.$assocTable.'.*}') ->from($tableName.' INNER JOIN '.$assocTable.' ON '. $tableName.'.'.$identifier.' = '.$assocTable.'.'.$this->getLocal().' OR '. $tableName.'.'.$identifier.' = '.$assocTable.'.'.$this->getForeign() ) ->where($tableName.'.'.$identifier.' IN ('.$sub.') OR '. $tableName.'.'.$identifier.' IN ('.$sub2.')' ); $q->addComponent($tableName, $record->getTable()->getComponentName()); $q->addComponent($assocTable, $record->getTable()->getComponentName(). '.' . $this->getAssociationFactory()->getComponentName()); return $q->execute(array($id, $id)); } } class Doctrine_Table extends Doctrine_Configurable implements Countable { private $data = array(); private $relations = array(); private $primaryKeys = array(); private $identifier; private $identifierType; private $query; private $conn; private $name; private $identityMap = array(); private $repository; protected $columns = array(); private $bound = array(); private $boundAliases = array(); private $columnCount; private $parents = array(); private $hasDefaultValues; protected $options = array('name' => null, 'tableName' => null, 'sequenceName' => null, 'inheritanceMap' => array(), 'enumMap' => array(), ); public function __construct($name, Doctrine_Connection $conn) { $this->conn = $conn; $this->setParent($this->conn); $this->options['name'] = $name; if( ! class_exists($name) || empty($name)) throw new Doctrine_Exception("Couldn't find class $name"); $record = new $name($this); $names = array(); $class = $name; do { if($class == "Doctrine_Record") break; $name = $class; $names[] = $name; } while($class = get_parent_class($class)); $names = array_reverse($names); if(method_exists($record, 'setTableDefinition')) { $record->setTableDefinition(); $this->columnCount = count($this->columns); if(isset($this->columns)) { $method = new ReflectionMethod($this->options['name'], 'setTableDefinition'); $class = $method->getDeclaringClass(); if( ! isset($this->options['tableName'])) $this->options['tableName'] = Doctrine::tableize($class->getName()); switch(count($this->primaryKeys)): case 0: $this->columns = array_merge(array('id' => array('integer', 20, array('autoincrement' => true, 'primary' => true ) ) ), $this->columns); $this->primaryKeys[] = 'id'; $this->identifier = 'id'; $this->identifierType = Doctrine_Identifier::AUTO_INCREMENT; $this->columnCount++; break; default: if(count($this->primaryKeys) > 1) { $this->identifier = $this->primaryKeys; $this->identifierType = Doctrine_Identifier::COMPOSITE; } else { foreach($this->primaryKeys as $pk) { $e = $this->columns[$pk][2]; $found = false; foreach($e as $option => $value) { if($found) break; $e2 = explode(":",$option); switch(strtolower($e2[0])): case "autoincrement": $this->identifierType = Doctrine_Identifier::AUTO_INCREMENT; $found = true; break; case "seq": $this->identifierType = Doctrine_Identifier::SEQUENCE; $found = true; break; endswitch; } if( ! isset($this->identifierType)) $this->identifierType = Doctrine_Identifier::NORMAL; $this->identifier = $pk; } } endswitch; if($this->getAttribute(Doctrine::ATTR_CREATE_TABLES)) { if(Doctrine::isValidClassname($class->getName())) { try { $columns = array(); foreach($this->columns as $name => $column) { $definition = $column[2]; $definition['type'] = $column[0]; $definition['length'] = $column[1]; if($definition['type'] == 'enum' && isset($definition['default'])) $definition['default'] = $this->enumIndex($name, $definition['default']); if($definition['type'] == 'boolean' && isset($definition['default'])) $definition['default'] = (int) $definition['default']; $columns[$name] = $definition; } $this->conn->export->createTable($this->options['tableName'], $columns); } catch(Exception $e) { } } } } } else { throw new Doctrine_Table_Exception("Class '$name' has no table definition."); } $record->setUp(); array_pop($names); $this->parents = $names; $this->query = "SELECT ".implode(", ",array_keys($this->columns))." FROM ".$this->getTableName(); if( ! $this->conn->addTable($this)) throw new Doctrine_Table_Exception(); $this->repository = new Doctrine_Table_Repository($this); } public function createQuery() { return Doctrine_Query::create()->from($this->getComponentName()); } public function getRepository() { return $this->repository; } public function setOption($name, $value) { switch($name) { case 'name': case 'tableName': break; case 'enumMap': case 'inheritanceMap': if( ! is_array($value)) throw new Doctrine_Table_Exception($name.' should be an array.'); break; } $this->options[$name] = $value; } public function usesInheritanceMap() { return ( ! empty($this->options['inheritanceMap'])); } public function getOption($name) { if(isset($this->options[$name])) return $this->options[$name]; return null; } final public function setColumn($name, $type, $length, $options = array()) { if(is_string($options)) $options = explode('|', $options); foreach($options as $k => $option) { if(is_numeric($k)) { if( ! empty($option)) $options[$option] = true; unset($options[$k]); } } $name = strtolower($name); $this->columns[$name] = array($type,$length,$options); if(isset($options['primary'])) { $this->primaryKeys[] = $name; } if(isset($options['default'])) { $this->hasDefaultValues = true; } } public function hasDefaultValues() { return $this->hasDefaultValues; } public function getDefaultValueOf($column) { $column = strtolower($column); if( ! isset($this->columns[$column])) throw new Doctrine_Table_Exception("Couldn't get default value. Column ".$column." doesn't exist."); if(isset($this->columns[$column][2]['default'])) { return $this->columns[$column][2]['default']; } else return null; } final public function getIdentifier() { return $this->identifier; } final public function getIdentifierType() { return $this->identifierType; } final public function hasColumn($name) { return isset($this->columns[$name]); } final public function setPrimaryKey($key) { switch(gettype($key)): case "array": $this->primaryKeys = array_values($key); break; case "string": $this->primaryKeys[] = $key; break; endswitch; } final public function getPrimaryKeys() { return $this->primaryKeys; } final public function hasPrimaryKey($key) { return in_array($key,$this->primaryKeys); } final public function setSequenceName($sequence) { $this->options['sequenceName'] = $sequence; } final public function getSequenceName() { return $this->options['sequenceName']; } final public function getParents() { return $this->parents; } final public function hasInheritanceMap() { return (empty($this->options['inheritanceMap'])); } final public function getInheritanceMap() { return $this->options['inheritanceMap']; } final public function getCompositePaths() { $array = array(); $name = $this->getComponentName(); foreach($this->bound as $k=>$a) { try { $fk = $this->getRelation($k); switch($fk->getType()): case Doctrine_Relation::ONE_COMPOSITE: case Doctrine_Relation::MANY_COMPOSITE: $n = $fk->getTable()->getComponentName(); $array[] = $name.".".$n; $e = $fk->getTable()->getCompositePaths(); if( ! empty($e)) { foreach($e as $name) { $array[] = $name.".".$n.".".$name; } } break; endswitch; } catch(Doctrine_Table_Exception $e) { } } return $array; } public function getBounds() { return $this->bound; } public function getBound($name) { if( ! isset($this->bound[$name])) throw new Doctrine_Table_Exception('Unknown bound '.$name); return $this->bound[$name]; } public function getBoundForName($name, $component) { foreach($this->bound as $k => $bound) { $e = explode('.', $bound[0]); if($bound[3] == $name && $e[0] == $component) { return $this->bound[$k]; } } throw new Doctrine_Table_Exception('Unknown bound '.$name); } public function getAlias($name) { if(isset($this->boundAliases[$name])) return $this->boundAliases[$name]; return $name; } public function getAliasName($alias) { if($name = array_search($alias, $this->boundAliases)) return $name; return $alias; } public function unbindAll() { $this->bound = array(); $this->relations = array(); $this->boundAliases = array(); } public function unbind($name) { if( ! isset($this->bound[$name])) return false; unset($this->bound[$name]); if(isset($this->relations[$name])) unset($this->relations[$name]); if(isset($this->boundAliases[$name])) unset($this->boundAliases[$name]); return true; } public function bind($name, $field, $type, $localKey) { if(isset($this->relations[$name])) unset($this->relations[$name]); $e = explode(" as ",$name); $name = $e[0]; if(isset($e[1])) { $alias = $e[1]; $this->boundAliases[$name] = $alias; } else $alias = $name; $this->bound[$alias] = array($field, $type, $localKey, $name); } public function getComponentName() { return $this->options['name']; } public function getConnection() { return $this->conn; } final public function hasRelatedComponent($name, $component) { return (strpos($this->bound[$name][0], $component.'.') !== false); } final public function hasRelation($name) { if(isset($this->bound[$name])) return true; foreach($this->bound as $k=>$v) { if($this->hasRelatedComponent($k, $name)) return true; } return false; } final public function getRelation($name, $recursive = true) { $original = $name; if(isset($this->relations[$name])) return $this->relations[$name]; if(isset($this->bound[$name])) { $type = $this->bound[$name][1]; $local = $this->bound[$name][2]; list($component, $foreign) = explode(".",$this->bound[$name][0]); $alias = $name; $name = $this->bound[$alias][3]; $table = $this->conn->getTable($name); if($component == $this->options['name'] || in_array($component, $this->parents)) { if($type == Doctrine_Relation::ONE_COMPOSITE || $type == Doctrine_Relation::ONE_AGGREGATE) { if( ! isset($local)) $local = $table->getIdentifier(); $relation = new Doctrine_Relation_LocalKey($table, $foreign, $local, $type, $alias); } else $relation = new Doctrine_Relation_ForeignKey($table, $foreign, $local, $type, $alias); } elseif($component == $name || ($component == $alias)) { if( ! isset($local)) $local = $this->identifier; $relation = new Doctrine_Relation_ForeignKey($table, $local, $foreign, $type, $alias); } else { if($type != Doctrine_Relation::MANY_AGGREGATE) throw new Doctrine_Table_Exception("Only aggregate relations are allowed for many-to-many relations"); $classes = array_merge($this->parents, array($this->options['name'])); foreach(array_reverse($classes) as $class) { try { $bound = $table->getBoundForName($class, $component); break; } catch(Doctrine_Table_Exception $exc) { } } if( ! isset($bound)) throw new Doctrine_Table_Exception("Couldn't map many-to-many relation for " . $this->options['name'] . " and $name. Components use different join tables."); if( ! isset($local)) $local = $this->identifier; $e2 = explode('.', $bound[0]); $fields = explode('-', $e2[1]); if($e2[0] != $component) throw new Doctrine_Table_Exception($e2[0] . ' doesn\'t match ' . $component); $associationTable = $this->conn->getTable($e2[0]); if(count($fields) > 1) { $this->relations[$e2[0]] = new Doctrine_Relation_ForeignKey($associationTable, $local, $fields[0],Doctrine_Relation::MANY_COMPOSITE, $e2[0]); $relation = new Doctrine_Relation_Association_Self($table, $associationTable, $fields[0], $fields[1], $type, $alias); } else { $associationTable->bind($this->getComponentName(), $associationTable->getComponentName(). '.' .$e2[1], Doctrine_Relation::ONE_AGGREGATE, $this->getIdentifier()); $associationTable->bind($table->getComponentName(), $associationTable->getComponentName(). '.' .$foreign, Doctrine_Relation::ONE_AGGREGATE, $table->getIdentifier()); $this->relations[$e2[0]] = new Doctrine_Relation_ForeignKey($associationTable, $local, $e2[1], Doctrine_Relation::MANY_COMPOSITE, $e2[0]); $relation = new Doctrine_Relation_Association($table, $associationTable, $e2[1], $foreign, $type, $alias); } } $this->relations[$alias] = $relation; return $this->relations[$alias]; } $this->getRelations(); if($recursive) { return $this->getRelation($original, false); } else { throw new Doctrine_Table_Exception($this->options['name'] . " doesn't have a relation to " . $original); } } final public function getRelations() { $a = array(); foreach($this->bound as $k=>$v) { $this->getRelation($k); } return $this->relations; } final public function setTableName($name) { $this->options['tableName'] = $name; } final public function getTableName() { return $this->options['tableName']; } public function create(array $array = array()) { $this->data = $array; $record = new $this->options['name']($this, true); $this->data = array(); return $record; } public function find($id) { if($id !== null) { if( ! is_array($id)) $id = array($id); else $id = array_values($id); $query = $this->query." WHERE ".implode(" = ? AND ",$this->primaryKeys)." = ?"; $query = $this->applyInheritance($query); $params = array_merge($id, array_values($this->options['inheritanceMap'])); $stmt = $this->conn->execute($query,$params); $this->data = $stmt->fetch(PDO::FETCH_ASSOC); if($this->data === false) return false; return $this->getRecord(); } return false; } final public function applyInheritance($where) { if( ! empty($this->options['inheritanceMap'])) { $a = array(); foreach($this->options['inheritanceMap'] as $field => $value) { $a[] = $field." = ?"; } $i = implode(" AND ",$a); $where .= " AND $i"; } return $where; } public function findAll() { $graph = new Doctrine_Query($this->conn); $users = $graph->query("FROM ".$this->options['name']); return $users; } public function findBySql($dql, array $params = array()) { $q = new Doctrine_Query($this->conn); $users = $q->query("FROM ".$this->options['name']." WHERE ".$dql, $params); return $users; } public function findByDql($dql, array $params = array()) { return $this->findBySql($dql, $params); } public function clear() { $this->identityMap = array(); } public function getRecord() { $this->data = array_change_key_case($this->data, CASE_LOWER); $key = $this->getIdentifier(); if( ! is_array($key)) $key = array($key); foreach($key as $k) { if( ! isset($this->data[$k])) throw new Doctrine_Exception("Primary key value for $k wasn't found"); $id[] = $this->data[$k]; } $id = implode(' ', $id); if(isset($this->identityMap[$id])) $record = $this->identityMap[$id]; else { $record = new $this->options['name']($this); $this->identityMap[$id] = $record; } $this->data = array(); return $record; } final public function getProxy($id = null) { if($id !== null) { $query = "SELECT ".implode(", ",$this->primaryKeys)." FROM ".$this->getTableName()." WHERE ".implode(" = ? && ",$this->primaryKeys)." = ?"; $query = $this->applyInheritance($query); $params = array_merge(array($id), array_values($this->options['inheritanceMap'])); $this->data = $this->conn->execute($query,$params)->fetch(PDO::FETCH_ASSOC); if($this->data === false) return false; } return $this->getRecord(); } public function count() { $a = $this->conn->getDBH()->query("SELECT COUNT(1) FROM ".$this->options['tableName'])->fetch(PDO::FETCH_NUM); return current($a); } public function getQueryObject() { $graph = new Doctrine_Query($this->getConnection()); $graph->load($this->getComponentName()); return $graph; } public function execute($query, array $array = array(), $limit = null, $offset = null) { $coll = new Doctrine_Collection($this); $query = $this->conn->modifyLimitQuery($query,$limit,$offset); if( ! empty($array)) { $stmt = $this->conn->getDBH()->prepare($query); $stmt->execute($array); } else { $stmt = $this->conn->getDBH()->query($query); } $data = $stmt->fetchAll(PDO::FETCH_ASSOC); $stmt->closeCursor(); foreach($data as $row) { $this->data = $row; $record = $this->getRecord(); $coll->add($record); } return $coll; } final public function setEnumValues($field, array $values) { $this->options['enumMap'][strtolower($field)] = $values; } final public function getEnumValues($field) { if(isset($this->options['enumMap'][$field])) return $this->options['enumMap'][$field]; else return array(); } final public function enumValue($field, $index) { if ($index instanceof Doctrine_Null) return $index; return isset($this->options['enumMap'][$field][$index]) ? $this->options['enumMap'][$field][$index] : $index; } public function invokeSet(Doctrine_Record $record, $name, $value) { if( ! ($this->getAttribute(Doctrine::ATTR_ACCESSORS) & Doctrine::ACCESSOR_SET)) return $value; $prefix = $this->getAttribute(Doctrine::ATTR_ACCESSOR_PREFIX_SET); if (!$prefix) $prefix = 'set'; $method = $prefix . $name; if(method_exists($record, $method)) { return $record->$method($value); } return $value; } public function invokeGet(Doctrine_Record $record, $name, $value) { if( ! ($this->getAttribute(Doctrine::ATTR_ACCESSORS) & Doctrine::ACCESSOR_GET)) return $value; $prefix = $this->getAttribute(Doctrine::ATTR_ACCESSOR_PREFIX_GET); if (!$prefix) $prefix = 'get'; $method = $prefix . $name; if(method_exists($record, $method)) { return $record->$method($value); } return $value; } final public function enumIndex($field, $value) { if( ! isset($this->options['enumMap'][$field])) $values = array(); else $values = $this->options['enumMap'][$field]; return array_search($value, $values); } public function getValueWrapperOf($column) { if(isset($this->columns[$column][2]['wrapper'])) return $this->columns[$column][2]['wrapper']; return false; } final public function getColumnCount() { return $this->columnCount; } final public function getColumns() { return $this->columns; } public function getColumnNames() { return array_keys($this->columns); } public function getDefinitionOf($column) { if(isset($this->columns[$column])) return $this->columns[$column]; return false; } public function getTypeOf($column) { if(isset($this->columns[$column])) return $this->columns[$column][0]; return false; } public function setData(array $data) { $this->data = $data; } final public function getMaxIdentifier() { $sql = "SELECT MAX(".$this->getIdentifier().") FROM ".$this->getTableName(); $stmt = $this->conn->getDBH()->query($sql); $data = $stmt->fetch(PDO::FETCH_NUM); return isset($data[0])?$data[0]:1; } final public function getQuery() { return $this->query; } final public function getData() { return $this->data; } public function __toString() { return Doctrine_Lib::getTableAsString($this); } } class Doctrine_Table_Exception extends Doctrine_Exception { public function __construct($message = "Couldn't initialize table. One instance of this
                            table already exists. Always use Doctrine_Session::getTable(\$name)
                            to get on instance of a Doctrine_Table.") { parent::__construct($message); } } class Doctrine_Validator { private static $validators = array(); private static $null; public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public static function getValidator($name) { if( ! isset(self::$validators[$name])) { $class = "Doctrine_Validator_".ucwords(strtolower($name)); if(class_exists($class)) { self::$validators[$name] = new $class; } else { throw new Doctrine_Exception("Validator named '$name' not availible."); } } return self::$validators[$name]; } public function validateRecord(Doctrine_Record $record) { $columns = $record->getTable()->getColumns(); $component = $record->getTable()->getComponentName(); $errorStack = $record->getErrorStack(); $data = ($record->exists()) ? $record->getModified() : $record->getData(); $err = array(); foreach($data as $key => $value) { if($value === self::$null) $value = null; elseif($value instanceof Doctrine_Record) $value = $value->getIncremented(); $column = $columns[$key]; if($column[0] == "enum") { $value = $record->getTable()->enumIndex($key, $value); if($value === false) { $errorStack->add($key, 'enum'); continue; } } if($record->getTable()->getAttribute(Doctrine::ATTR_AUTO_LENGTH_VLD)) { if(!$this->validateLength($column, $key, $value)) { $errorStack->add($key, 'length'); continue; } } if( ! is_array($column[2])) $e = explode("|",$column[2]); else $e = $column[2]; foreach($e as $k => $arg) { if(is_string($k)) { $name = $k; $args = $arg; } else { $args = explode(":",$arg); $name = array_shift($args); if( ! isset($args[0])) $args[0] = ''; } if(empty($name) || $name == 'primary' || $name == 'protected' || $name == 'autoincrement' || $name == 'default') continue; if(strtolower($name) == 'length') { if(!$record->getTable()->getAttribute(Doctrine::ATTR_AUTO_LENGTH_VLD)) { if(!$this->validateLength($column, $key, $value)) { $errorStack->add($key, 'length'); } } continue; } if(strtolower($name) == 'type') { if(!$record->getTable()->getAttribute(Doctrine::ATTR_AUTO_TYPE_VLD)) { if( ! self::isValidType($value, $column[0])) { $errorStack->add($key, 'type'); } } continue; } $validator = self::getValidator($name); if( ! $validator->validate($record, $key, $value, $args)) { $errorStack->add($key, $name); } } if($record->getTable()->getAttribute(Doctrine::ATTR_AUTO_TYPE_VLD)) { if( ! self::isValidType($value, $column[0])) { $errorStack->add($key, 'type'); continue; } } } } private function validateLength($column, $key, $value) { if($column[0] == "array" || $column[0] == "object") $length = strlen(serialize($value)); else $length = strlen($value); if($length > $column[1]) { return false; } return true; } public function hasErrors() { return (count($this->stack) > 0); } public static function phpType($doctrineType) { switch($doctrineType) { case 'enum': return 'integer'; case 'blob': case 'clob': case 'mbstring': case 'timestamp': case 'date': case 'gzip': return 'string'; break; default: return $doctrineType; } } public static function isValidType($var, $type) { if($type == 'boolean') return true; $looseType = self::gettype($var); $type = self::phpType($type); switch($looseType): case 'float': case 'double': case 'integer': if($type == 'string' || $type == 'float') return true; case 'string': case 'array': case 'object': return ($type === $looseType); break; case 'NULL': return true; break; endswitch; } public static function gettype($var) { $type = gettype($var); switch($type): case 'string': if(preg_match("/^[0-9]+$/",$var)) return 'integer'; elseif(is_numeric($var)) return 'float'; else return $type; break; default: return $type; endswitch; } } class Doctrine_Validator_Exception extends Doctrine_Exception implements Countable, IteratorAggregate { private $invalid = array(); public function __construct(array $invalid) { $this->invalid = $invalid; } public function getInvalidRecords() { return $this->invalid; } public function getIterator() { return new ArrayIterator($this->invalid); } public function count() { return count($this->invalid); } public function __toString() { return parent::__toString(); } } class Doctrine_Validator_Notnull { public function validate(Doctrine_Record $record, $key, $value) { if ($value === null || $value === '') return false; return true; } } class Doctrine_Validator_Nospace { public function validate(Doctrine_Record $record, $key, $value, $args) { return ($value === null || ! preg_match('/\s\t\r\n/',$value)); } } class Doctrine_Validator_Range { public function validate(Doctrine_Record $record, $key, $value, $args) { if(isset($args[0]) && $value < $args[0]) return false; if(isset($args[1]) && $value > $args[1]) return false; return true; } } class Doctrine_Validator_Regexp { public function validate(Doctrine_Record $record, $key, $value, $args) { if(is_array($args)) { foreach($args as $regexp) { if( ! preg_match($args, $value)) return false; } return true; } else { if(preg_match($args, $value)) return true; } return false; } } class Doctrine_Validator_Country { private static $countries = array( "ad" => "Andorra", "ae" => "United Arab Emirates", "af" => "Afghanistan", "ag" => "Antigua and Barbuda", "ai" => "Anguilla", "al" => "Albania", "am" => "Armenia", "an" => "Netherlands Antilles", "ao" => "Angola", "aq" => "Antarctica", "ar" => "Argentina", "as" => "American Samoa", "at" => "Austria", "au" => "Australia", "aw" => "Aruba", "az" => "Azerbaijan", "ba" => "Bosnia Hercegovina", "bb" => "Barbados", "bd" => "Bangladesh", "be" => "Belgium", "bf" => "Burkina Faso", "bg" => "Bulgaria", "bh" => "Bahrain", "bi" => "Burundi", "bj" => "Benin", "bm" => "Bermuda", "bn" => "Brunei Darussalam", "bo" => "Bolivia", "br" => "Brazil", "bs" => "Bahamas", "bt" => "Bhutan", "bv" => "Bouvet Island", "bw" => "Botswana", "by" => "Belarus (Byelorussia)", "bz" => "Belize", "ca" => "Canada", "cc" => "Cocos Islands", "cd" => 'Congo, The Democratic Republic of the', "cf" => "Central African Republic", "cg" => "Congo", "ch" => "Switzerland", "ci" => "Ivory Coast", "ck" => "Cook Islands", "cl" => "Chile", "cm" => "Cameroon", "cn" => "China", "co" => "Colombia", "cr" => "Costa Rica", "cs" => "Czechoslovakia", "cu" => "Cuba", "cv" => "Cape Verde", "cx" => "Christmas Island", "cy" => "Cyprus", "cz" => 'Czech Republic', "de" => "Germany", "dj" => "Djibouti", "dk" => 'Denmark', "dm" => "Dominica", "do" => "Dominican Republic", "dz" => "Algeria", "ec" => "Ecuador", "ee" => "Estonia", "eg" => "Egypt", "eh" => "Western Sahara", "er" => 'Eritrea', "es" => "Spain", "et" => "Ethiopia", "fi" => "Finland", "fj" => "Fiji", "fk" => "Falkland Islands", "fm" => "Micronesia", "fo" => "Faroe Islands", "fr" => "France", "fx" => 'France, Metropolitan FX', "ga" => "Gabon", "gb" => 'United Kingdom (Great Britain)', "gd" => "Grenada", "ge" => "Georgia", "gf" => "French Guiana", "gh" => "Ghana", "gi" => "Gibraltar", "gl" => "Greenland", "gm" => "Gambia", "gn" => "Guinea", "gp" => "Guadeloupe", "gq" => "Equatorial Guinea", "gr" => "Greece", "gs" => 'South Georgia and the South Sandwich Islands', "gt" => "Guatemala", "gu" => "Guam", "gw" => "Guinea-bissau", "gy" => "Guyana", "hk" => "Hong Kong", "hm" => "Heard and McDonald Islands", "hn" => "Honduras", "hr" => "Croatia", "ht" => "Haiti", "hu" => "Hungary", "id" => "Indonesia", "ie" => "Ireland", "il" => "Israel", "in" => "India", "io" => "British Indian Ocean Territory", "iq" => "Iraq", "ir" => "Iran", "is" => "Iceland", "it" => "Italy", "jm" => "Jamaica", "jo" => "Jordan", "jp" => "Japan", "ke" => "Kenya", "kg" => "Kyrgyzstan", "kh" => "Cambodia", "ki" => "Kiribati", "km" => "Comoros", "kn" => "Saint Kitts and Nevis", "kp" => "North Korea", "kr" => "South Korea", "kw" => "Kuwait", "ky" => "Cayman Islands", "kz" => "Kazakhstan", "la" => "Laos", "lb" => "Lebanon", "lc" => "Saint Lucia", "li" => "Lichtenstein", "lk" => "Sri Lanka", "lr" => "Liberia", "ls" => "Lesotho", "lt" => "Lithuania", "lu" => "Luxembourg", "lv" => "Latvia", "ly" => "Libya", "ma" => "Morocco", "mc" => "Monaco", "md" => "Moldova Republic", "mg" => "Madagascar", "mh" => "Marshall Islands", "mk" => 'Macedonia, The Former Yugoslav Republic of', "ml" => "Mali", "mm" => "Myanmar", "mn" => "Mongolia", "mo" => "Macau", "mp" => "Northern Mariana Islands", "mq" => "Martinique", "mr" => "Mauritania", "ms" => "Montserrat", "mt" => "Malta", "mu" => "Mauritius", "mv" => "Maldives", "mw" => "Malawi", "mx" => "Mexico", "my" => "Malaysia", "mz" => "Mozambique", "na" => "Namibia", "nc" => "New Caledonia", "ne" => "Niger", "nf" => "Norfolk Island", "ng" => "Nigeria", "ni" => "Nicaragua", "nl" => "Netherlands", "no" => "Norway", "np" => "Nepal", "nr" => "Nauru", "nt" => "Neutral Zone", "nu" => "Niue", "nz" => "New Zealand", "om" => "Oman", "pa" => "Panama", "pe" => "Peru", "pf" => "French Polynesia", "pg" => "Papua New Guinea", "ph" => "Philippines", "pk" => "Pakistan", "pl" => "Poland", "pm" => "St. Pierre and Miquelon", "pn" => "Pitcairn", "pr" => "Puerto Rico", "pt" => "Portugal", "pw" => "Palau", "py" => "Paraguay", "qa" => 'Qatar', "re" => "Reunion", "ro" => "Romania", "ru" => "Russia", "rw" => "Rwanda", "sa" => "Saudi Arabia", "sb" => "Solomon Islands", "sc" => "Seychelles", "sd" => "Sudan", "se" => "Sweden", "sg" => "Singapore", "sh" => "St. Helena", "si" => "Slovenia", "sj" => "Svalbard and Jan Mayen Islands", "sk" => 'Slovakia (Slovak Republic)', "sl" => "Sierra Leone", "sm" => "San Marino", "sn" => "Senegal", "so" => "Somalia", "sr" => "Suriname", "st" => "Sao Tome and Principe", "sv" => "El Salvador", "sy" => "Syria", "sz" => "Swaziland", "tc" => "Turks and Caicos Islands", "td" => "Chad", "tf" => "French Southern Territories", "tg" => "Togo", "th" => "Thailand", "tj" => "Tajikistan", "tk" => "Tokelau", "tm" => "Turkmenistan", "tn" => "Tunisia", "to" => "Tonga", "tp" => "East Timor", "tr" => "Turkey", "tt" => "Trinidad, Tobago", "tv" => "Tuvalu", "tw" => "Taiwan", "tz" => "Tanzania", "ua" => "Ukraine", "ug" => "Uganda", "uk" => "United Kingdom", "um" => "United States Minor Islands", "us" => "United States of America", "uy" => "Uruguay", "uz" => "Uzbekistan", "va" => "Vatican City", "vc" => "Saint Vincent, Grenadines", "ve" => "Venezuela", "vg" => "Virgin Islands (British)", "vi" => "Virgin Islands (USA)", "vn" => "Viet Nam", "vu" => "Vanuatu", "wf" => 'Wallis and Futuna Islands', "ws" => "Samoa", "ye" => 'Yemen', "yt" => 'Mayotte', "yu" => "Yugoslavia", "za" => "South Africa", "zm" => "Zambia", "zr" => "Zaire", "zw" => "Zimbabwe"); public static function getCountries() { return self::$countries; } public function validate(Doctrine_Record $record, $key, $value, $args) { $value = strtolower($value); return isset(self::$countries[$value]); } } class Doctrine_Validator_Notblank { public function validate(Doctrine_Record $record, $key, $value, $args) { return (trim($value) != ""); } } class Doctrine_Validator_Creditcard { public function validate(Doctrine_Record $record, $key, $value, $args) { return preg_match('#^((4\d{3})|(5[1-5]\d{2})|(6011)|(7\d{3}))-?\d{4}-?\d{4}-?\d{4}|3[4,7]\d{13}$#', $value); } } class Doctrine_Validator_Date { public function validate(Doctrine_Record $record, $key, $value, $args) { if(empty($value)) return true; $e = explode("-", $value); if(count($e) !== 3) return false; return checkdate($e[1], $e[0], $e[2]); } } class Doctrine_Validator_Ip { public function validate(Doctrine_Record $record, $key, $value, $args) { return (bool) ip2long(str_replace("\0", '', $value)); } } class Doctrine_Validator_Unique { public function validate(Doctrine_Record $record, $key, $value, $args) { $table = $record->getTable(); $sql = 'SELECT ' . $table->getIdentifier() . ' FROM ' . $table->getTableName() . ' WHERE ' . $key . ' = ?'; $stmt = $table->getConnection()->getDbh()->prepare($sql); $stmt->execute(array($value)); return ( ! is_array($stmt->fetch())); } } class Doctrine_Validator_Usstate { private static $states = array ( "AK" => true, "AL" => true, "AR" => true, "AZ" => true, "CA" => true, "CO" => true, "CT" => true, "DC" => true, "DE" => true, "FL" => true, "GA" => true, "HI" => true, "IA" => true, "ID" => true, "IL" => true, "IN" => true, "KS" => true, "KY" => true, "LA" => true, "MA" => true, "MD" => true, "ME" => true, "MI" => true, "MN" => true, "MO" => true, "MS" => true, "MT" => true, "NC" => true, "ND" => true, "NE" => true, "NH" => true, "NJ" => true, "NM" => true, "NV" => true, "NY" => true, "OH" => true, "OK" => true, "OR" => true, "PA" => true, "PR" => true, "RI" => true, "SC" => true, "SD" => true, "TN" => true, "TX" => true, "UT" => true, "VA" => true, "VI" => true, "VT" => true, "WA" => true, "WI" => true, "WV" => true, "WY" => true ); public function getStates() { return self::$states; } public function validate(Doctrine_Record $record, $key, $value, $args) { return isset(self::$states[$value]); } } class Doctrine_Validator_HtmlColor { public function validate(Doctrine_Record $record, $key, $value, $args) { if( ! preg_match("/^#{0,1}[0-9]{6}$/",$color)) { return false; } return true; } } class Doctrine_Validator_Email { public function validate(Doctrine_Record $record, $key, $value, $args) { if(empty($value)) return true; if(isset($args[0])) { $parts = explode("@", $value); if(isset($parts[1]) && function_exists("checkdnsrr")) { if( ! checkdnsrr($parts[1], "MX")) return false; } } $qtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]'; $dtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]'; $atom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+'; $quoted_pair = '\\x5c[\\x00-\\x7f]'; $domain_literal = "\\x5b($dtext|$quoted_pair)*\\x5d"; $quoted_string = "\\x22($qtext|$quoted_pair)*\\x22"; $domain_ref = $atom; $sub_domain = "($domain_ref|$domain_literal)"; $word = "($atom|$quoted_string)"; $domain = "$sub_domain(\\x2e$sub_domain)+"; $local_part = "$word(\\x2e$word)*"; $addr_spec = "$local_part\\x40$domain"; return (bool)preg_match("!^$addr_spec$!", $value); } } class Doctrine_View { const DROP = 'DROP VIEW %s'; const CREATE = 'CREATE VIEW %s AS %s'; const SELECT = 'SELECT * FROM %s'; protected $name; protected $query; protected $conn; public function __construct(Doctrine_Query $query, $viewName) { $this->name = $viewName; $this->query = $query; $this->query->setView($this); $this->conn = $query->getConnection(); } public function getQuery() { return $this->query; } public function getName() { return $this->name; } public function getConnection() { return $this->conn; } public function create() { $sql = sprintf(self::CREATE, $this->name, $this->query->getQuery()); try { $this->conn->getDBH()->query($sql); } catch(Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function drop() { try { $this->conn->getDBH()->query(sprintf(self::DROP, $this->name)); } catch(Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function execute() { return $this->query->execute(); } public function getSelectSql() { return sprintf(self::SELECT, $this->name); } } class Doctrine_View_Exception extends Doctrine_Exception { } 